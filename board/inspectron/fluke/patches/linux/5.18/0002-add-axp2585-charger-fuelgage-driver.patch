
--- a/drivers/power/supply/axp/axp2585/axp2585.c	1969-12-31 19:00:00.000000000 -0500
+++ b/drivers/power/supply/axp/axp2585/axp2585.c	2022-09-01 10:46:35.786464423 -0400
@@ -0,0 +1,399 @@
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/reboot.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/mutex.h>
+#include <linux/slab.h>
+#include <linux/i2c.h>
+#include <linux/delay.h>
+#include <linux/mfd/core.h>
+#include <linux/of.h>
+#include <linux/of_irq.h>
+#include <linux/of_device.h>
+#include <linux/err.h>
+//#include <linux/power/aw_pm.h>
+#include <linux/gpio.h>
+#include "../axp-core.h"
+#include "../axp-charger.h"
+#include "axp2585.h"
+
+static struct axp_dev *axp2585_pm_power;
+struct axp_config_info axp2585_config;
+struct wakeup_source *axp2585_ws;
+static int axp2585_pmu_num;
+
+static const struct axp_compatible_name_mapping axp2585_cn_mapping[] = {
+	{
+		.device_name = "axp2585",
+		.mfd_name = {
+#ifndef CONFIG_DUAL_AXP_USED
+			.powerkey_name  = "axp2585-powerkey",
+#endif
+			.charger_name   = "axp2585-charger",
+		},
+	},
+};
+
+static struct axp_regmap_irq_chip axp2585_regmap_irq_chip = {
+	.name           = "AXP2585_IRQ_chip",
+	.status_base    = AXP2585_INTSTS1,
+	.enable_base    = AXP2585_INTEN1,
+	.num_regs       = 6,
+};
+
+static struct resource axp2585_pek_resources[] = {
+	{AXP2585_IRQ_PEKRE,  AXP2585_IRQ_PEKRE,  "PEK_DBR",      IORESOURCE_IRQ,},
+	{AXP2585_IRQ_PEKFE,  AXP2585_IRQ_PEKFE,  "PEK_DBF",      IORESOURCE_IRQ,},
+};
+
+static struct resource axp2585_charger_resources[] = {
+	{AXP2585_IRQ_ACIN,   AXP2585_IRQ_ACIN,   "ac in",        IORESOURCE_IRQ,},
+	{AXP2585_IRQ_ACRE,   AXP2585_IRQ_ACRE,   "ac out",       IORESOURCE_IRQ,},
+	{AXP2585_IRQ_BATIN,  AXP2585_IRQ_BATIN,  "bat in",       IORESOURCE_IRQ,},
+	{AXP2585_IRQ_BATRE,  AXP2585_IRQ_BATRE,  "bat out",      IORESOURCE_IRQ,},
+	{AXP2585_IRQ_CHAST,  AXP2585_IRQ_CHAST,  "charging",     IORESOURCE_IRQ,},
+	{AXP2585_IRQ_CHAOV,  AXP2585_IRQ_CHAOV,  "charge over",  IORESOURCE_IRQ,},
+	{AXP2585_IRQ_LOWN1,  AXP2585_IRQ_LOWN1,  "low warning1", IORESOURCE_IRQ,},
+	{AXP2585_IRQ_LOWN2,  AXP2585_IRQ_LOWN2,  "low warning2", IORESOURCE_IRQ,},
+#ifdef TYPE_C
+	{AXP2585_IRQ_TCIN,  AXP2585_IRQ_TCIN,  "tc in", IORESOURCE_IRQ,},
+	{AXP2585_IRQ_TCRE,  AXP2585_IRQ_TCRE, "tc out", IORESOURCE_IRQ,},
+#endif
+};
+
+static struct mfd_cell axp2585_cells[] = {
+	{
+		.name          = "axp2585-powerkey",
+		.num_resources = ARRAY_SIZE(axp2585_pek_resources),
+		.resources     = axp2585_pek_resources,
+	},
+	{
+		.name          = "axp2585-charger",
+		.num_resources = ARRAY_SIZE(axp2585_charger_resources),
+		.resources     = axp2585_charger_resources,
+	},
+};
+
+void axp2585_power_off(void)
+{
+	pr_info("[%s] send power-off command!\n", axp_name[axp2585_pmu_num]);
+	axp_regmap_set_bits(axp2585_pm_power->regmap, 0x10, 0x80); /* enable */
+	axp_regmap_set_bits(axp2585_pm_power->regmap, 0x17, 0x01);
+	mdelay(20);
+	pr_warn("[%s] warning!!! axp can't power-off,\"\
+		\" maybe some error happened!\n", axp_name[axp2585_pmu_num]);
+}
+
+static int axp2585_init_chip(struct axp_dev *axp2585)
+{
+	uint8_t chip_id;
+	int err;
+
+	err = axp_regmap_read(axp2585->regmap, AXP2585_IC_TYPE, &chip_id);
+	if (err) {
+		pr_err("[%s] try to read chip id failed!\n",
+				axp_name[axp2585_pmu_num]);
+		return err;
+	}
+
+	/*only support axp2585*/
+	if (((chip_id & 0xc0) == 0x40) &&
+		((chip_id & 0x0f) == 0x06)
+		) {
+		pr_info("[%s] chip id detect 0x%x !\n",
+				axp_name[axp2585_pmu_num], chip_id);
+	} else {
+		pr_info("[%s] chip id is error 0x%x !\n",
+				axp_name[axp2585_pmu_num], chip_id);
+	}
+
+	/*Init IRQ wakeup en*/
+	if (axp2585_config.pmu_irq_wakeup)
+		axp_regmap_set_bits(axp2585->regmap, 0x17, 0x10); /* enable */
+	else
+		axp_regmap_clr_bits(axp2585->regmap, 0x17, 0x10); /* disable */
+
+	/*Init PMU Over Temperature protection*/
+	if (axp2585_config.pmu_hot_shutdown)
+		axp_regmap_set_bits(axp2585->regmap, 0xf3, 0x08); /* enable */
+	else
+		axp_regmap_clr_bits(axp2585->regmap, 0xf3, 0x08); /* disable */
+
+	/*enable send seq to pmu when power off */
+	axp_regmap_update(axp2585->regmap, 0x16, 0x40, 0xc0);
+	return 0;
+}
+
+static void axp2585_wakeup_event(void)
+{
+	__pm_wakeup_event(axp2585_ws, 0);
+}
+
+static s32 axp2585_usb_det(void)
+{
+	u8 value = 0;
+	int ret = 0;
+
+	axp_regmap_read(axp2585_pm_power->regmap, 0x0, &value);
+	if (value & 0x02) {
+		axp_usb_connect = 1;
+		ret = 1;
+	}
+	return ret;
+}
+
+static s32 axp2585_usb_vbus_output(int high)
+{
+	u8 ret = 0;
+
+	if (high) {
+		ret = axp_regmap_set_bits_sync(axp2585_pm_power->regmap,
+								0x11, 0x40);
+		if (ret)
+			return ret;
+	} else {
+		ret = axp_regmap_clr_bits_sync(axp2585_pm_power->regmap,
+								0x11, 0x40);
+		if (ret)
+			return ret;
+	}
+	return ret;
+}
+
+static int axp2585_cfg_pmux_para(int num, struct aw_pm_info *api, int *pmu_id)
+{
+	char name[8];
+	struct device_node *np;
+
+	sprintf(name, "pmu%d", num);
+
+	np = of_find_node_by_type(NULL, name);
+	if (np == NULL) {
+		pr_err("can not find device_type for %s\n", name);
+		return -1;
+	}
+
+	if (!of_device_is_available(np)) {
+		pr_err("can not find node for %s\n", name);
+		return -1;
+	}
+#if 0
+#ifdef CONFIG_AXP_TWI_USED
+	if (api != NULL) {
+		api->pmu_arg.twi_port = axp2585_pm_power->regmap->client->adapter->nr;
+		api->pmu_arg.dev_addr = axp2585_pm_power->regmap->client->addr;
+	}
+#endif
+#endif
+	*pmu_id = axp2585_config.pmu_id;
+
+	return 0;
+}
+
+static const char *axp2585_get_pmu_name(void)
+{
+	return axp_name[axp2585_pmu_num];
+}
+
+static struct axp_dev *axp2585_get_pmu_dev(void)
+{
+	return axp2585_pm_power;
+}
+
+struct axp_platform_ops axp2585_platform_ops = {
+	.usb_det = axp2585_usb_det,
+	.usb_vbus_output = axp2585_usb_vbus_output,
+	//.cfg_pmux_para = axp2585_cfg_pmux_para,
+	.get_pmu_name = axp2585_get_pmu_name,
+	.get_pmu_dev  = axp2585_get_pmu_dev,
+};
+
+static const struct i2c_device_id axp2585_id_table[] = {
+	{ "axp2585", 0 },
+	{}
+};
+
+static const struct of_device_id axp2585_dt_ids[] = {
+	{ .compatible = "axp2585", },
+	{},
+};
+MODULE_DEVICE_TABLE(of, axp2585_dt_ids);
+
+
+static int axp2585_probe(struct i2c_client *client,
+				const struct i2c_device_id *id)
+{
+    printk("[axp2585]Entering %s\n",__func__);
+	int ret;
+	struct axp_dev *axp2585;
+
+	struct device *device = &client->dev;
+	struct device_node *node = client->dev.of_node;
+
+	axp2585_pmu_num = axp_get_pmu_num(axp2585_cn_mapping,
+				ARRAY_SIZE(axp2585_cn_mapping));
+	if (axp2585_pmu_num < 0) {
+		pr_err("%s get pmu num failed\n", __func__);
+		return axp2585_pmu_num;
+	}
+
+	if (node) {
+		/* get dt and sysconfig */
+		if (!of_device_is_available(node)) {
+			axp2585_config.pmu_used = 0;
+			pr_err("%s: pmu_used = %u\n", __func__,
+					axp2585_config.pmu_used);
+			return -EPERM;
+		} else {
+			axp2585_config.pmu_used = 1;
+			ret = axp_dt_parse(node, axp2585_pmu_num,
+					&axp2585_config);
+			if (ret) {
+				pr_err("%s parse device tree err\n", __func__);
+				return -EINVAL;
+			}
+		}
+	} else {
+		pr_err("AXP2585 device tree err!\n");
+		return -EBUSY;
+	}
+
+	axp2585 = devm_kzalloc(device, sizeof(*axp2585), GFP_KERNEL);
+	if (!axp2585)
+		return -ENOMEM;
+
+	axp2585->dev = device;
+	axp2585->nr_cells = ARRAY_SIZE(axp2585_cells);
+	axp2585->cells = axp2585_cells;
+	axp2585->pmu_num = axp2585_pmu_num;
+
+	ret = axp_mfd_cell_name_init(axp2585_cn_mapping,
+				ARRAY_SIZE(axp2585_cn_mapping), axp2585->pmu_num,
+				axp2585->nr_cells, axp2585->cells);
+	if (ret)
+		return ret;
+
+	axp2585->regmap = axp_regmap_init_i2c(&client->dev);
+
+	if (IS_ERR(axp2585->regmap)) {
+		ret = PTR_ERR(axp2585->regmap);
+		dev_err(device, "regmap init failed: %d\n", ret);
+		return ret;
+	}
+
+	i2c_set_clientdata(client, axp2585);
+  printk("==%s==line:%d==file:%s==\n",__func__,__LINE__,__FILE__);
+	ret = axp2585_init_chip(axp2585);
+	if (ret)
+		return ret;
+	  printk("==%s==line:%d==file:%s==\n",__func__,__LINE__,__FILE__);
+
+	ret = axp_mfd_add_devices(axp2585);
+	if (ret) {
+		dev_err(axp2585->dev, "failed to add MFD devices: %d\n", ret);
+		return ret;
+	}
+	printk("==%s==line:%d==file:%s==\n",__func__,__LINE__,__FILE__);
+	axp2585->irq = client->irq;
+printk("[axp2585] client->irq=%d in line:%d of %s\n",client->irq,__LINE__,__func__);
+/*strong~~~~~~~~~~~
+	axp2585->irq_data = axp_irq_chip_register(axp2585->regmap, axp2585->irq,
+						IRQF_SHARED
+						| IRQF_NO_SUSPEND,
+						&axp2585_regmap_irq_chip,
+						axp2585_wakeup_event);
+	if (IS_ERR(axp2585->irq_data)) {
+		ret = PTR_ERR(axp2585->irq_data);
+		dev_err(device, "axp init irq failed: %d\n", ret);
+		return ret;
+	}
+
+	printk("%s %d:axp2585->irq_data pointer:%p\n",__func__,__LINE__,axp2585->irq_data);
+*/
+	//if(axp2585->irq_data->chip!=NULL)
+	//{
+	//    printk("[axp2585]axp2585->irq_data->chip->name=%s\n",axp2585->irq_data->chip->name);
+//	}
+/*strong~~~~~~~~
+printk("[%s]===%s===line:%d=========\n",__FILE__,__func__,__LINE__);
+printk("[axp2585]pointer to axp2585->irq_data->irqs is %p in %s line:%d\n",\
+       axp2585->irq_data->irqs,__func__,__LINE__);
+printk("[axp2585]pointer to axp2585->irq_data is %p in %s line:%d\n",\
+       axp2585->irq_data,__func__,__LINE__);
+printk("[%s]===%s===line:%d=========\n",__FILE__,__func__,__LINE__);
+*/
+	axp2585_pm_power = axp2585;
+/*
+	if (!pm_power_off)
+		pm_power_off = axp2585_power_off;
+*/
+	axp_platform_ops_set(axp2585->pmu_num, &axp2585_platform_ops);
+	printk("[%s]===%s===line:%d=========\n",__FILE__,__func__,__LINE__);
+
+	axp2585_ws = wakeup_source_register("axp2585_wakeup_source");
+printk("Quit %s\n",__func__);
+	return 0;
+}
+
+
+static int axp2585_remove(struct i2c_client *client)
+{
+	struct axp_dev *axp2585 = i2c_get_clientdata(client);
+
+	if (axp2585 == axp2585_pm_power) {
+		axp2585_pm_power = NULL;
+		pm_power_off = NULL;
+	}
+	axp_mfd_remove_devices(axp2585);
+	axp_irq_chip_unregister(axp2585->irq, axp2585->irq_data);
+
+	return 0;
+}
+
+/*
+ * enable restart pmic when pwrok drive low
+ */
+
+static void axp2585_shutdown(struct i2c_client *client)
+
+{
+	axp_regmap_set_bits(axp2585_pm_power->regmap, 0x14, 0x40);
+}
+
+
+static struct i2c_driver axp2585_driver = {
+
+	.driver = {
+		.name   = "axp2585",
+		.owner  = THIS_MODULE,
+		.of_match_table = axp2585_dt_ids,
+	},
+	.probe      = axp2585_probe,
+	.remove     = axp2585_remove,
+	.shutdown   = axp2585_shutdown,
+	.id_table   = axp2585_id_table,
+
+};
+
+static int __init axp2585_init(void)
+{
+	int ret;
+	printk("axp2585_init~~~~~~~~~~~~~~~~~~~~~~~~~~~\n");
+	ret = i2c_add_driver(&axp2585_driver);
+	if (ret != 0)
+		pr_err("[axp2585]Failed to register axp2585 I2C driver: %d\n", ret);
+	return ret;
+}
+subsys_initcall(axp2585_init);
+//arch_initcall(axp2585_init);
+
+static void __exit axp2585_exit(void)
+{
+	i2c_del_driver(&axp2585_driver);
+}
+module_exit(axp2585_exit);
+
+MODULE_DESCRIPTION("BMU Driver for axp2585");
+MODULE_AUTHOR("roy <qiuzhigang@allwinnertech.com>");
+MODULE_LICENSE("GPL");

--- a/drivers/power/supply/axp/axp2585/axp2585-charger.c	1969-12-31 19:00:00.000000000 -0500
+++ b/drivers/power/supply/axp/axp2585/axp2585-charger.c	2022-09-01 10:46:35.786464423 -0400
@@ -0,0 +1,847 @@
+#include "axp2585-charger.h"
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/device.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/workqueue.h>
+#include <linux/types.h>
+#include <linux/slab.h>
+#include <linux/interrupt.h>
+#include <linux/power_supply.h>
+#include "../axp-core.h"
+#include "../axp-charger.h"
+
+static int axp2585_get_ac_voltage(struct axp_charger_dev *cdev)
+{
+	return 0;
+}
+
+static int axp2585_get_ac_current(struct axp_charger_dev *cdev)
+{
+	return 0;
+}
+
+static int axp2585_set_ac_vhold(struct axp_charger_dev *cdev, int vol)
+{
+	return 0;
+}
+
+static int axp2585_get_ac_vhold(struct axp_charger_dev *cdev)
+{
+	return 0;
+}
+
+static int axp2585_set_ac_ihold(struct axp_charger_dev *cdev, int cur)
+{
+	return 0;
+}
+
+static int axp2585_get_ac_ihold(struct axp_charger_dev *cdev)
+{
+	return 0;
+}
+
+static struct axp_ac_info axp2585_ac_info = {
+	.det_bit         = 1,
+	.det_offset      = 0,
+	.valid_offset	 = 0,
+	.valid_bit	 = 1,
+	.get_ac_voltage  = axp2585_get_ac_voltage,
+	.get_ac_current  = axp2585_get_ac_current,
+	.set_ac_vhold    = axp2585_set_ac_vhold,
+	.get_ac_vhold    = axp2585_get_ac_vhold,
+	.set_ac_ihold    = axp2585_set_ac_ihold,
+	.get_ac_ihold    = axp2585_get_ac_ihold,
+};
+
+static int axp2585_get_usb_voltage(struct axp_charger_dev *cdev)
+{
+	return 0;
+}
+
+static int axp2585_get_usb_current(struct axp_charger_dev *cdev)
+{
+	return 0;
+}
+
+static int axp2585_set_usb_vhold(struct axp_charger_dev *cdev, int vol)
+{
+	u8 tmp;
+	struct axp_regmap *map = cdev->chip->regmap;
+
+	if (vol) {
+		/*axp_regmap_set_bits(map, 0xff,0x60);*/
+		if (vol >= 3880 && vol <= 5080) {
+			tmp = (vol - 3880)/80;
+			axp_regmap_update(map, 0x11, tmp, 0x0f);
+		} else {
+			pr_err("set usb limit voltage error, %d mV\n",
+						axp2585_config.pmu_usbpc_vol);
+		}
+	} else {
+		/*axp_regmap_clr_bits(map, 0xff,0x60);*/
+	}
+	return 0;
+}
+
+static int axp2585_get_usb_vhold(struct axp_charger_dev *cdev)
+{
+	u8 tmp;
+	struct axp_regmap *map = cdev->chip->regmap;
+
+	axp_regmap_read(map, 0x11, &tmp);
+	return (tmp*80 + 3880);
+}
+
+static int axp2585_set_usb_ihold(struct axp_charger_dev *cdev, int cur)
+{
+	u8 tmp;
+	struct axp_regmap *map = cdev->chip->regmap;
+
+	if (cur) {
+		/*axp_regmap_set_bits(map, 0xff,0x60);*/
+		if (cur >= 100 && cur <= 3250) {
+			tmp = (cur - 100)/50;
+			axp_regmap_update(map, 0x10, tmp, 0x3f);
+		} else {
+			pr_err("set usb limit voltage error, %d mV\n",
+						axp2585_config.pmu_usbpc_vol);
+		}
+	} else {
+		/*axp_regmap_clr_bits(map, 0xff,0x60);*/
+	}
+	return 0;
+}
+
+static int axp2585_get_usb_ihold(struct axp_charger_dev *cdev)
+{
+	u8 tmp;
+	struct axp_regmap *map = cdev->chip->regmap;
+
+	axp_regmap_read(map, 0x10, &tmp);
+	return (tmp*50 + 100);
+}
+
+static struct axp_usb_info axp2585_usb_info = {
+	.det_bit         = 1,
+	.det_offset      = 0,
+	.valid_offset	 = 0,
+	.valid_bit	 = 1,
+	.get_usb_voltage = axp2585_get_usb_voltage,
+	.get_usb_current = axp2585_get_usb_current,
+	.set_usb_vhold   = axp2585_set_usb_vhold,
+	.get_usb_vhold   = axp2585_get_usb_vhold,
+	.set_usb_ihold   = axp2585_set_usb_ihold,
+	.get_usb_ihold   = axp2585_get_usb_ihold,
+};
+
+static int axp2585_get_rest_cap(struct axp_charger_dev *cdev)
+{
+	u8 val, temp_val[2], tmp[2];
+	u8 ocv_percent = 0;
+	u8 coulomb_percent = 0;
+	int batt_max_cap, coulumb_counter;
+	int rest_vol;
+	struct axp_regmap *map = cdev->chip->regmap;
+
+	axp_regmap_read(map, AXP2585_CAP, &val);
+	if (!(val & 0x80))
+		return 0;
+	rest_vol = (int) (val & 0x7F);
+	axp_regmap_read(map, 0xe4, &tmp[0]);
+	if (tmp[0] & 0x80) {
+		ocv_percent = tmp[0] & 0x7f;
+		AXP_DEBUG(AXP_SPLY, cdev->chip->pmu_num,
+			"ocv_percent = %d\n", ocv_percent);
+	}
+	axp_regmap_read(map, 0xe5, &tmp[0]);
+	if (tmp[0] & 0x80) {
+		coulomb_percent = tmp[0] & 0x7f;
+		AXP_DEBUG(AXP_SPLY, cdev->chip->pmu_num,
+			"coulomb_percent = %d\n", coulomb_percent);
+	}
+	if (ocv_percent == 100 && cdev->charging == 0 && rest_vol == 99
+		&& (cdev->ac_valid == 1 || cdev->usb_valid == 1)) {
+		axp_regmap_clr_bits(map, AXP2585_COULOMB_CTL, 0x80);
+		axp_regmap_set_bits(map, AXP2585_COULOMB_CTL, 0x80);
+		AXP_DEBUG(AXP_SPLY, cdev->chip->pmu_num, "Reset coulumb\n");
+		rest_vol = 100;
+	}
+	axp_regmap_reads(map, 0xe2, 2, temp_val);
+	coulumb_counter = (((temp_val[0] & 0x7f) << 8) + temp_val[1])
+						* 1456 / 1000;
+
+	axp_regmap_reads(map, 0xe0, 2, temp_val);
+	batt_max_cap = (((temp_val[0] & 0x7f) << 8) + temp_val[1])
+						* 1456 / 1000;
+
+	AXP_DEBUG(AXP_SPLY, cdev->chip->pmu_num,
+			"batt_max_cap = %d\n", batt_max_cap);
+	return rest_vol;
+}
+
+static int axp2585_get_bat_health(struct axp_charger_dev *cdev)
+{
+	return POWER_SUPPLY_HEALTH_GOOD;
+}
+
+static inline int axp2585_vbat_to_mV(u32 reg)
+{
+	return ((int)(((reg >> 8) << 4) | (reg & 0x000F))) * 1200 / 1000;
+}
+
+static int axp2585_get_vbat(struct axp_charger_dev *cdev)
+{
+	u8 tmp[2];
+	u32 res;
+	struct axp_regmap *map = cdev->chip->regmap;
+
+	axp_regmap_reads(map, AXP2585_VBATH_RES, 2, tmp);
+	res = (tmp[0] << 8) | tmp[1];
+
+	return axp2585_vbat_to_mV(res);
+}
+
+static inline int axp2585_ibat_to_mA(u32 reg)
+{
+	return (int)((((reg >> 8) << 4) | (reg & 0x000F)) << 1);
+}
+
+static inline int axp2585_icharge_to_mA(u32 reg)
+{
+	return (int)((((reg >> 8) << 4) | (reg & 0x000F)) << 1);
+}
+
+static int axp2585_get_ibat(struct axp_charger_dev *cdev)
+{
+	u8 tmp[2];
+	u32 res;
+	struct axp_regmap *map = cdev->chip->regmap;
+
+	axp_regmap_reads(map, AXP2585_IBATH_REG, 2, tmp);
+	res = (tmp[0] << 8) | tmp[1];
+
+	return axp2585_icharge_to_mA(res);
+}
+
+static int axp2585_get_disibat(struct axp_charger_dev *cdev)
+{
+	u8 tmp[2];
+	u32 dis_res;
+	struct axp_regmap *map = cdev->chip->regmap;
+
+	axp_regmap_reads(map, AXP2585_DISIBATH_REG, 2, tmp);
+	dis_res = (tmp[0] << 8) | tmp[1];
+
+	return axp2585_ibat_to_mA(dis_res);
+}
+
+static int axp2585_set_chg_cur(struct axp_charger_dev *cdev, int cur)
+{
+	uint8_t tmp = 0;
+	struct axp_regmap *map = cdev->chip->regmap;
+/*
+	if (cur == 0)
+		axp_regmap_clr_bits(map, axp2585_CHARGE_CONTROL1, 0x80);
+	else
+		axp_regmap_set_bits(map, axp2585_CHARGE_CONTROL1, 0x80);
+*/
+	tmp = (cur) / 64;
+	if (tmp > 0x3f)
+		tmp = 0x3f;
+	axp_regmap_update(map, 0x8b, tmp, 0x3F);
+	return 0;
+}
+
+static int axp2585_set_chg_vol(struct axp_charger_dev *cdev, int vol)
+{
+	uint8_t tmp = 0;
+	struct axp_regmap *map = cdev->chip->regmap;
+
+	if (vol > 3840 && vol < 4608)
+		tmp = (vol - 3840)/16;
+	else {
+		pr_warn("unsupported voltage: %dmv, use default 4200mv\n", vol);
+		tmp = (4200 - 3840)/16;
+	}
+	axp_regmap_update(map, 0x8c, tmp << 2, 0xfc);
+	return 0;
+}
+
+static struct axp_battery_info axp2585_batt_info = {
+	.chgstat_bit          = 2,			//2--4
+	.chgstat_offset       = 0,
+	.det_bit              = 4,
+	.det_offset           = 2,
+	.det_valid_bit        = 3,
+	.det_valid            = 1,
+	.cur_direction_bit    = 0,
+	.cur_direction_offset = 2,
+	.get_rest_cap         = axp2585_get_rest_cap,
+	.get_bat_health       = axp2585_get_bat_health,
+	.get_vbat             = axp2585_get_vbat,
+	.get_ibat             = axp2585_get_ibat,
+	.get_disibat          = axp2585_get_disibat,
+	.set_chg_cur          = axp2585_set_chg_cur,
+	.set_chg_vol          = axp2585_set_chg_vol,
+};
+
+static struct power_supply_info battery_data = {
+	.name = "PTI PL336078",
+	.technology = POWER_SUPPLY_TECHNOLOGY_LiFe,
+	.voltage_max_design = 4200000,
+	.voltage_min_design = 3500000,
+	.use_for_apm = 1,
+};
+#ifdef TYPE_C
+static struct axp_tc_info axp2585_tc_info = {
+	.det_bit   = 2,			/*2--4*/
+};
+#endif
+static struct axp_supply_info axp2585_spy_info = {
+	.ac   = &axp2585_ac_info,
+	.usb  = &axp2585_usb_info,
+	.batt = &axp2585_batt_info,
+#ifdef TYPE_C
+	.tc	= &axp2585_tc_info,
+#endif
+};
+
+static int axp2585_charger_init(struct axp_dev *axp_dev)
+{
+	u8 ocv_cap[32];
+	u8 val = 0;
+	int cur_coulomb_counter, rdc;
+	struct axp_regmap *map = axp_dev->regmap;
+	int i, ocv_cou_adjust_time[4] = {60, 120, 15, 30};
+	int update_min_times[8] = {30, 60, 120, 164, 0, 5, 10, 20};
+	/*set chg time */
+	if (axp2585_config.pmu_init_chg_pretime < 40)
+		axp2585_config.pmu_init_chg_pretime = 40;
+	val = (axp2585_config.pmu_init_chg_pretime - 40)/10;
+	if (val >= 3)
+		val = 3;
+	val = 0x80 + (val<<5);
+	axp_regmap_update(map, 0x8e, val, 0xe0);
+    printk("==%s==line:%d==file:%s==\n",__func__,__LINE__,__FILE__);
+
+	if (axp2585_config.pmu_init_chg_csttime <= 60 * 5)
+		val = 0;
+	else if (axp2585_config.pmu_init_chg_csttime <= 60 * 8)
+		val = 1;
+	else if (axp2585_config.pmu_init_chg_csttime <= 60 * 12)
+		val = 2;
+	else if (axp2585_config.pmu_init_chg_csttime <= 60 * 20)
+		val = 3;
+	else
+		val = 3;
+	val = (val << 1) + 0x01;
+	axp_regmap_update(map, 0x8d, val, 0x07);
+	/* adc set */
+	val = AXP2585_ADC_BATVOL_ENABLE | AXP2585_ADC_BATCUR_ENABLE;
+	if (axp2585_config.pmu_bat_temp_enable != 0)
+		val = val | AXP2585_ADC_TSVOL_ENABLE;
+	axp_regmap_update(map, AXP2585_ADC_CONTROL, val,
+						AXP2585_ADC_BATVOL_ENABLE
+						| AXP2585_ADC_BATCUR_ENABLE
+						| AXP2585_ADC_TSVOL_ENABLE);
+
+	axp_regmap_read(map, AXP2585_TS_PIN_CONTROL, &val);
+	switch (axp2585_config.pmu_init_adc_freq / 100) {
+	case 1:
+		val &= ~(3 << 5);
+		break;
+	case 2:
+		val &= ~(3 << 5);
+		val |= 1 << 5;
+		break;
+	case 4:
+		val &= ~(3 << 5);
+		val |= 2 << 5;
+		break;
+	case 8:
+		val |= 3 << 5;
+		break;
+	default:
+		break;
+	}
+
+	if (axp2585_config.pmu_bat_temp_enable != 0)
+		val &= (~(1 << 7));
+	axp_regmap_write(map, AXP2585_TS_PIN_CONTROL, val);
+
+	/* bat para */
+	axp_regmap_write(map, AXP2585_WARNING_LEVEL,
+		((axp2585_config.pmu_battery_warning_level1 - 5) << 4)
+		+ axp2585_config.pmu_battery_warning_level2);
+
+	if (axp2585_config.pmu_init_chgvol < 3840)
+		axp2585_config.pmu_init_chgvol = 3840;
+	val = (axp2585_config.pmu_init_chgvol - 3840)/16;
+	if (val > 0x30)
+		val = 0x30;
+	val <<= 2;
+	axp_regmap_update(map, AXP2585_CHARGE_CONTROL2, val, 0xfc);
+    printk("==%s==line:%d==file:%s==\n",__func__,__LINE__,__FILE__);
+
+	ocv_cap[0]  = axp2585_config.pmu_bat_para1;
+	ocv_cap[1]  = axp2585_config.pmu_bat_para2;
+	ocv_cap[2]  = axp2585_config.pmu_bat_para3;
+	ocv_cap[3]  = axp2585_config.pmu_bat_para4;
+	ocv_cap[4]  = axp2585_config.pmu_bat_para5;
+	ocv_cap[5]  = axp2585_config.pmu_bat_para6;
+	ocv_cap[6]  = axp2585_config.pmu_bat_para7;
+	ocv_cap[7]  = axp2585_config.pmu_bat_para8;
+	ocv_cap[8]  = axp2585_config.pmu_bat_para9;
+	ocv_cap[9]  = axp2585_config.pmu_bat_para10;
+	ocv_cap[10] = axp2585_config.pmu_bat_para11;
+	ocv_cap[11] = axp2585_config.pmu_bat_para12;
+	ocv_cap[12] = axp2585_config.pmu_bat_para13;
+	ocv_cap[13] = axp2585_config.pmu_bat_para14;
+	ocv_cap[14] = axp2585_config.pmu_bat_para15;
+	ocv_cap[15] = axp2585_config.pmu_bat_para16;
+	ocv_cap[16] = axp2585_config.pmu_bat_para17;
+	ocv_cap[17] = axp2585_config.pmu_bat_para18;
+	ocv_cap[18] = axp2585_config.pmu_bat_para19;
+	ocv_cap[19] = axp2585_config.pmu_bat_para20;
+	ocv_cap[20] = axp2585_config.pmu_bat_para21;
+	ocv_cap[21] = axp2585_config.pmu_bat_para22;
+	ocv_cap[22] = axp2585_config.pmu_bat_para23;
+	ocv_cap[23] = axp2585_config.pmu_bat_para24;
+	ocv_cap[24] = axp2585_config.pmu_bat_para25;
+	ocv_cap[25] = axp2585_config.pmu_bat_para26;
+	ocv_cap[26] = axp2585_config.pmu_bat_para27;
+	ocv_cap[27] = axp2585_config.pmu_bat_para28;
+	ocv_cap[28] = axp2585_config.pmu_bat_para29;
+	ocv_cap[29] = axp2585_config.pmu_bat_para30;
+	ocv_cap[30] = axp2585_config.pmu_bat_para31;
+	ocv_cap[31] = axp2585_config.pmu_bat_para32;
+	axp_regmap_writes(map, 0xC0, 32, ocv_cap);
+
+	/*Init CHGLED function*/
+	if (axp2585_config.pmu_chgled_func)
+		axp_regmap_set_bits(map, 0x90, 0x80); /* control by charger */
+	else
+		axp_regmap_clr_bits(map, 0x90, 0x80); /* drive MOTO */
+#if 0
+	/*set CHGLED Indication Type*/
+	if (axp2585_config.pmu_chgled_type)
+		axp_regmap_set_bits(map, 0x90, 0x01); /* Type B */
+	else
+		axp_regmap_clr_bits(map, 0x90, 0x07); /* Type A */
+#else
+	axp_regmap_set_bits(map, 0x90, axp2585_config.pmu_chgled_type & 0x07);
+#endif
+	/*Init battery capacity correct function*/
+	if (axp2585_config.pmu_batt_cap_correct)
+		axp_regmap_set_bits(map, 0xb8, 0x20); /* enable */
+	else
+		axp_regmap_clr_bits(map, 0xb8, 0x20); /* disable */
+
+	/*battery detect enable*/
+	if (axp2585_config.pmu_batdeten)
+		axp_regmap_set_bits(map, 0x8e, 0x08);
+	else
+		axp_regmap_clr_bits(map, 0x8e, 0x08);
+
+	/* RDC initial */
+	axp_regmap_read(map, AXP2585_RDC0, &val);
+	if ((axp2585_config.pmu_battery_rdc) && (!(val & 0x40))) {
+		rdc = (axp2585_config.pmu_battery_rdc * 10000 + 5371) / 10742;
+		axp_regmap_write(map, AXP2585_RDC0, ((rdc >> 8) & 0x1F)|0x80);
+		axp_regmap_write(map, AXP2585_RDC1, rdc & 0x00FF);
+	}
+
+	axp_regmap_read(map, AXP2585_BATCAP0, &val);
+	if ((axp2585_config.pmu_battery_cap) && (!(val & 0x80))) {
+		cur_coulomb_counter = axp2585_config.pmu_battery_cap
+					* 1000 / 1456;
+		axp_regmap_write(map, AXP2585_BATCAP0,
+					((cur_coulomb_counter >> 8) | 0x80));
+		axp_regmap_write(map, AXP2585_BATCAP1,
+					cur_coulomb_counter & 0x00FF);
+	} else if (!axp2585_config.pmu_battery_cap) {
+		axp_regmap_write(map, AXP2585_BATCAP0, 0x00);
+		axp_regmap_write(map, AXP2585_BATCAP1, 0x00);
+	}
+
+	if (axp2585_config.pmu_bat_unused == 1)
+		axp2585_spy_info.batt->det_unused = 1;
+	else
+		axp2585_spy_info.batt->det_unused = 0;
+
+	if (axp2585_config.pmu_bat_temp_enable != 0) {
+		axp_regmap_write(map, AXP2585_VLTF_CHARGE,
+				axp2585_config.pmu_bat_charge_ltf * 10 / 128);
+		axp_regmap_write(map, AXP2585_VHTF_CHARGE,
+				axp2585_config.pmu_bat_charge_htf * 10 / 128);
+		axp_regmap_write(map, AXP2585_VLTF_WORK,
+				axp2585_config.pmu_bat_shutdown_ltf * 10 / 128);
+		axp_regmap_write(map, AXP2585_VHTF_WORK,
+				axp2585_config.pmu_bat_shutdown_htf * 10 / 128);
+	}
+	/*enable fast charge */
+	axp_regmap_update(map, 0x31, 0x04, 0x04);
+	/*set POR time as 16s*/
+	axp_regmap_update(map, AXP2585_POK_SET, 0x30, 0x30);
+	for (i = 0; i < ARRAY_SIZE(update_min_times); i++) {
+		if (update_min_times[i] == axp2585_config.pmu_update_min_time)
+			break;
+	}
+	axp_regmap_update(map, AXP2585_ADJUST_PARA, i, 0x7);
+	/*initial the ocv_cou_adjust_time*/
+	for (i = 0; i < ARRAY_SIZE(ocv_cou_adjust_time); i++) {
+		if (ocv_cou_adjust_time[i] == axp2585_config.pmu_ocv_cou_adjust_time)
+			break;
+	}
+	i <<= 6;
+	axp_regmap_update(map, AXP2585_ADJUST_PARA1, i, 0xC0);
+	printk("==%s==line:%d==file:%s==\n",__func__,__LINE__,__FILE__);
+
+	return 0;
+}
+
+static struct axp_interrupts axp2585_charger_irq[] = {
+	{"ac in",         axp_usb_in_isr},
+	{"ac out",        axp_usb_out_isr},
+	{"bat in",        axp_capchange_isr},
+	{"bat out",       axp_capchange_isr},
+	{"charging",      axp_change_isr},
+	{"charge over",   axp_change_isr},
+	{"low warning1",  axp_low_warning1_isr},
+	{"low warning2",  axp_low_warning2_isr},
+#ifdef TYPE_C
+	{"tc in",         axp_tc_in_isr},
+	{"tc out",        axp_tc_out_isr},
+#endif
+};
+static int tc_mode = 1;
+static int boost_mode = 1;
+static int power = 1;
+static ssize_t show_tc_mode(struct device *dev,
+			    struct device_attribute *attr, char *buf)
+{
+	char *s = buf;
+	char *end = (char *)((ptrdiff_t)buf + (ptrdiff_t)PAGE_SIZE);
+
+	s += scnprintf(s, end - s, "%s\n", "0: close 1: sink 2: source 3: drp");
+	s += scnprintf(s, end - s, "tc_mode=%d\n", tc_mode);
+	return s - buf;
+}
+
+static ssize_t store_tc_mode(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+	int val, err;
+	struct axp_charger_dev *chg_dev = dev_get_drvdata(dev);
+	struct axp_regmap *map = chg_dev->chip->regmap;
+
+	err = kstrtoint(buf, 16, &val);
+	if (err)
+		return err;
+	if (val > 3)
+		val = 1;
+	tc_mode = val;
+		axp_regmap_update(map, 0x33, tc_mode, 0x03);
+	return count;
+}
+
+static ssize_t show_boost_mode(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	char *s = buf;
+	char *end = (char *)((ptrdiff_t)buf + (ptrdiff_t)PAGE_SIZE);
+
+	s += scnprintf(s, end - s, "%s\n", "1: open  0: close");
+	s += scnprintf(s, end - s, "boost_mode=%d\n", boost_mode);
+	return s - buf;
+}
+
+static ssize_t store_boost_mode(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+	int val, err;
+	struct axp_charger_dev *chg_dev = dev_get_drvdata(dev);
+	struct axp_regmap *map = chg_dev->chip->regmap;
+
+	err = kstrtoint(buf, 16, &val);
+	if (err)
+		return err;
+	if (val != 1)
+		val = 0;
+	boost_mode = val;
+	if (boost_mode == 1)
+		axp_regmap_set_bits(map, 0x12, 0x80);
+	else
+		axp_regmap_clr_bits(map, 0x12, 0x80);
+	return count;
+}
+
+static ssize_t axp2585_power_show(struct device *dev,
+			    struct device_attribute *attr, char *buf)
+{
+	struct axp_charger_dev *chg_dev = dev_get_drvdata(dev);
+	char *s = buf;
+	char *end = (char *)((ptrdiff_t)buf + (ptrdiff_t)PAGE_SIZE);
+	int vbat, ibat;
+	vbat = axp2585_get_vbat(chg_dev);
+	ibat = axp2585_get_disibat(chg_dev);
+	power = vbat*ibat/1000;
+	s += scnprintf(s, end - s, "%dmV\n", power);
+	return s - buf;
+}
+static DEVICE_ATTR(tc_mode, 0644, show_tc_mode, store_tc_mode);
+static DEVICE_ATTR(boost_mode, 0644, show_boost_mode, store_boost_mode);
+static DEVICE_ATTR(power, 0644, axp2585_power_show, NULL);
+static struct attribute *bmu_control_attrs[] = {
+	&dev_attr_tc_mode.attr,
+	&dev_attr_boost_mode.attr,
+	&dev_attr_power.attr,
+	NULL,
+};
+
+static struct attribute_group bmu_control_attr_group = {
+	.name = "bmu_control",
+	.attrs = bmu_control_attrs,
+};
+
+static void axp2585_private_debug(struct axp_charger_dev *cdev)
+{
+	u8 tmp[2];
+	struct axp_regmap *map = cdev->chip->regmap;
+
+	axp_regmap_reads(map, 0x5a, 2, tmp);
+	AXP_DEBUG(AXP_SPLY, cdev->chip->pmu_num,
+			"acin_vol = %d\n", ((tmp[0] << 4) | (tmp[1] & 0xF))
+			* 8);
+	axp_regmap_reads(map, 0xbc, 2, tmp);
+	AXP_DEBUG(AXP_SPLY, cdev->chip->pmu_num,
+			"ocv_vol = %d\n", ((tmp[0] << 4) | (tmp[1] & 0xF))
+			* 1200 / 1000);
+
+}
+
+static int axp2585_charger_probe(struct platform_device *pdev)
+{
+    printk("[axp2585]Entering %s\n",__func__);
+	int ret, i, irq;
+	struct axp_charger_dev *chg_dev;
+	struct axp_dev *axp_dev = dev_get_drvdata(pdev->dev.parent);
+	/*strong~~~~~~~~
+    printk("[axp2585]pointer to axp_dev->irq_data->irqs:%p in line:%d %s\n",\
+           axp_dev->irq_data->irqs,__LINE__,__func__);
+	*/
+    	printk("[axp2585] pointer to of_node is %p in line:%d in %s\n",
+                       pdev->dev.of_node,__LINE__,__func__);
+	if (pdev->dev.of_node) {
+		/* get dt and sysconfig */
+		ret = axp_charger_dt_parse(pdev->dev.of_node, &axp2585_config);
+		if (ret) {
+			pr_err("%s parse device tree err\n", __func__);
+			return -EINVAL;
+		}
+	} else {
+		pr_err("axp2585 charger device tree err!\n");
+		return -EBUSY;
+	}
+
+	axp2585_ac_info.ac_vol = axp2585_config.pmu_ac_vol;
+	axp2585_ac_info.ac_cur = axp2585_config.pmu_ac_cur;
+	axp2585_usb_info.usb_pc_vol = axp2585_config.pmu_usbpc_vol;
+	axp2585_usb_info.usb_pc_cur = axp2585_config.pmu_usbpc_cur;
+	axp2585_usb_info.usb_ad_vol = axp2585_config.pmu_ac_vol;
+	axp2585_usb_info.usb_ad_cur = axp2585_config.pmu_ac_cur;
+	axp2585_batt_info.runtime_chgcur = axp2585_config.pmu_runtime_chgcur;
+	axp2585_batt_info.suspend_chgcur = axp2585_config.pmu_suspend_chgcur;
+	axp2585_batt_info.shutdown_chgcur = axp2585_config.pmu_shutdown_chgcur;
+	battery_data.voltage_max_design = axp2585_config.pmu_init_chgvol
+								* 1000;
+	battery_data.voltage_min_design = axp2585_config.pmu_pwroff_vol
+								* 1000;
+	battery_data.energy_full_design = axp2585_config.pmu_battery_cap;
+
+	axp2585_charger_init(axp_dev);
+    printk("==%s==line:%d==file:%s==\n",__func__,__LINE__,__FILE__);
+
+	chg_dev = axp_power_supply_register(&pdev->dev, axp_dev,
+					&battery_data, &axp2585_spy_info);
+	if (IS_ERR_OR_NULL(chg_dev))
+		goto fail;
+	chg_dev->private_debug = axp2585_private_debug;
+	chg_dev->pmic_temp_offset = 0x56;
+	chg_dev->spy_info->batt->bat_temp_offset = 0x58;
+
+/*strong~~~~~~~~~
+	for (i = 0; i < ARRAY_SIZE(axp2585_charger_irq); i++) {
+		irq = platform_get_irq_byname(pdev, axp2585_charger_irq[i].name);
+
+		if (irq < 0)
+			continue;
+       printk("[axp2585]i=%d ,irq=%d in line:%d of %s\n",i,irq,__LINE__,__func__);
+       printk("[axp2585]===name:%s==\n",axp2585_charger_irq[i].name);
+       axp2585_charger_irq[i].isr==NULL?\
+               printk("[axp2585]isr is NULL\n"):printk("[axp2585]isr is NOT NULL\n");
+
+      if(axp_dev->irq_data!=NULL)
+      {
+       printk("[axp2585]axp_dev->irq_data in line:%d of %s is NOT NULL\n",__LINE__,__func__ );
+         if(axp_dev->irq_data->irqs!=NULL)
+           {
+             printk("[axp2585]axp_dev->irq_data->irqs in line:%d of %s is NOT NULL\n",__LINE__,__func__ );
+           }
+             else{
+             printk("[axp2585]axp_dev->irq_data->irqs in line:%d of %s is  NULL\n",__LINE__,__func__ );
+            }
+      }
+      else
+          printk("[axp2585]axp_dev->irq_data in line:%d of %s is  NULL\n",__LINE__,__func__ );
+
+      if(axp_dev->irq!=NULL)
+           {
+            printk("[axp2585]axp_dev->int irq in line:%d of %d is %s NOT NULL\n",__LINE__,axp_dev->irq,__func__ );
+           }
+           else
+             {
+               printk("[axp2585]axp_dev->irq in line:%d of %s is  NULL\n",__LINE__,__func__ );
+             }
+      if(axp_dev->irq_data!=NULL){
+          printk("[axp2585]Pointer to axp2585_charger_irq[%d].isr is %p\n",\
+                 i,axp2585_charger_irq[i].isr);
+          printk("[axp2585]Pointer to axp2585_charger_irq[%d].name:%s is %p\n",\
+                          i,axp2585_charger_irq[i].name,&axp2585_charger_irq[i].name);
+          printk("[axp2585]pointer to axp_dev->irq_data:%p in line:%d %s\n",\
+                     axp_dev->irq_data,__LINE__,__func__);
+          printk("[axp2585]pointer to axp_dev->irq_data->irqs:%p in line:%d %s\n",\
+                     axp_dev->irq_data->irqs,__LINE__,__func__);
+
+        	ret = axp_request_irq(axp_dev, irq,
+				axp2585_charger_irq[i].isr, chg_dev);
+		if (ret != 0) {
+			dev_err(&pdev->dev, "failed to request %s IRQ %d: %d\n",
+					axp2585_charger_irq[i].name, irq, ret);
+			goto out_irq;
+		}
+
+		dev_dbg(&pdev->dev, "Requested %s IRQ %d: %d\n",
+			axp2585_charger_irq[i].name, irq, ret);
+
+	}
+	}
+*/
+	platform_set_drvdata(pdev, chg_dev);
+	ret = sysfs_create_group(&pdev->dev.kobj, &bmu_control_attr_group);
+	if (ret)
+		dev_warn(&pdev->dev, "failed to create attr group\n");
+
+	return 0;
+    printk("[axp2585]Quit %s\n",__func__);
+out_irq:
+	for (i = i - 1; i >= 0; i--) {
+		irq = platform_get_irq_byname(pdev, axp2585_charger_irq[i].name);
+		if (irq < 0)
+			continue;
+		axp_free_irq(axp_dev, irq);
+	}
+fail:
+	return -1;
+}
+
+static int axp2585_charger_remove(struct platform_device *pdev)
+{
+	int i, irq;
+	struct axp_charger_dev *chg_dev = platform_get_drvdata(pdev);
+	struct axp_dev *axp_dev = dev_get_drvdata(pdev->dev.parent);
+
+	for (i = 0; i < ARRAY_SIZE(axp2585_charger_irq); i++) {
+		irq = platform_get_irq_byname(pdev, axp2585_charger_irq[i].name);
+		if (irq < 0)
+			continue;
+		axp_free_irq(axp_dev, irq);
+	}
+
+	axp_power_supply_unregister(chg_dev);
+
+	return 0;
+}
+
+static int axp2585_charger_suspend(struct platform_device *dev,
+				pm_message_t state)
+{
+	struct axp_charger_dev *chg_dev = platform_get_drvdata(dev);
+
+	axp_suspend_flag = AXP_WAS_SUSPEND;
+	axp_charger_suspend(chg_dev);
+
+	return 0;
+}
+
+static int axp2585_charger_resume(struct platform_device *dev)
+{
+	struct axp_charger_dev *chg_dev = platform_get_drvdata(dev);
+	int pre_rest_vol;
+
+	if (axp_suspend_flag == AXP_SUSPEND_WITH_IRQ) {
+		axp_suspend_flag = AXP_NOT_SUSPEND;
+	//	sunxi_nmi_enable();
+	} else {
+		axp_suspend_flag = AXP_NOT_SUSPEND;
+	}
+	pre_rest_vol = chg_dev->rest_vol;
+	axp_charger_resume(chg_dev);
+
+	if (chg_dev->rest_vol - pre_rest_vol) {
+		pr_info("battery vol change: %d->%d\n",
+				pre_rest_vol, chg_dev->rest_vol);
+		/*axp_regmap_write(map, 0x05, chg_dev->rest_vol | 0x80);*/
+	}
+
+	return 0;
+}
+
+static void axp2585_charger_shutdown(struct platform_device *dev)
+{
+	struct axp_charger_dev *chg_dev = platform_get_drvdata(dev);
+
+	axp_charger_shutdown(chg_dev);
+}
+
+static const struct of_device_id axp2585_charger_dt_ids[] = {
+	{ .compatible = "axp2585-charger", },
+	{},
+};
+MODULE_DEVICE_TABLE(of, axp2585_charger_dt_ids);
+
+static struct platform_driver axp2585_charger_driver = {
+	.driver     = {
+		.name   = "axp2585-charger",
+		.of_match_table = axp2585_charger_dt_ids,
+	},
+	.probe    = axp2585_charger_probe,
+	.remove   = axp2585_charger_remove,
+	.suspend  = axp2585_charger_suspend,
+	.resume   = axp2585_charger_resume,
+	.shutdown = axp2585_charger_shutdown,
+};
+
+static int __init axp2585_charger_initcall(void)
+{
+	int ret;
+
+	ret = platform_driver_register(&axp2585_charger_driver);
+	if (IS_ERR_VALUE(ret)) {
+		pr_err("%s: failed, errno %d\n", __func__, ret);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+//fs_initcall_sync(axp2585_charger_initcall);
+late_initcall(axp2585_charger_initcall);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Roy <qiuzhigang@allwinnertech.com>");
+MODULE_DESCRIPTION("Charger Driver for axp2585 BMU");
+MODULE_ALIAS("platform:axp2585-charger");

--- a/drivers/power/supply/axp/axp2585/axp2585-charger.h	1969-12-31 19:00:00.000000000 -0500
+++ b/drivers/power/supply/axp/axp2585/axp2585-charger.h	2022-09-01 10:46:35.786464423 -0400
@@ -0,0 +1,52 @@
+/*
+ * drivers/power/supply/bmu/AXP2585-charger.h
+ * (C) Copyright 2010-2016
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * Pannan <pannan@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ */
+#ifndef AXP2585_CHARGER_H
+
+#define AXP2585_CHARGER_H
+#include "axp2585.h"
+
+/* AXP2585 */
+#define AXP2585_CHARGE_STATUS            AXP2585_STATUS
+#define AXP2585_CAP                      (0xB9)
+#define AXP2585_BATCAP0                  (0xe0)
+#define AXP2585_BATCAP1                  (0xe1)
+#define AXP2585_RDC0                     (0xba)
+#define AXP2585_RDC1                     (0xbb)
+#define AXP2585_VLTF_CHARGE              (0x84)
+#define AXP2585_VHTF_CHARGE              (0x85)
+#define AXP2585_VLTF_WORK                (0x86)
+#define AXP2585_VHTF_WORK		 (0x87)
+#define AXP2585_CHARGE_CONTROL2		 (0x8c)
+
+#define AXP2585_ADC_CONTROL              (0x80)
+#define AXP2585_ADC_BATVOL_ENABLE        (1 << 4)
+#define AXP2585_ADC_BATCUR_ENABLE        (1 << 6)
+//#define AXP2585_ADC_DCINVOL_ENABLE       (1 << 5)
+//#define AXP2585_ADC_DCINCUR_ENABLE       (1 << 4)
+#define AXP2585_ADC_DIETMP_ENABLE        (1 << 7)
+#define AXP2585_ADC_TSVOL_ENABLE         (1 << 5)
+
+#define AXP2585_VBATH_RES                (0x78)
+#define AXP2585_IBATH_REG                (0x7a)
+#define AXP2585_DISIBATH_REG             (0x7c)
+#define AXP2585_COULOMB_CTL              (0xB8)
+#define AXP2585_ADJUST_PARA              (0xE8)
+#define AXP2585_ADJUST_PARA1             (0xE9)
+#define AXP_CHG_ATTR(_name)                     \
+{                                               \
+	.attr = { .name = #_name, .mode = 0644 },    \
+	.show =  _name##_show,                      \
+	.store = _name##_store,                     \
+}
+
+#endif

--- a/drivers/power/supply/axp/axp2585/axp2585.h	1969-12-31 19:00:00.000000000 -0500
+++ b/drivers/power/supply/axp/axp2585/axp2585.h	2022-09-01 10:46:35.786464423 -0400
@@ -0,0 +1,83 @@
+/*
+ * drivers/power/axp/AXP2585/AXP2585.h
+ * (C) Copyright 2010-2016
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * Pannan <pannan@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ */
+#ifndef AXP2585_H_
+#define AXP2585_H_
+
+/* For AXP2585 */
+#define AXP2585_STATUS              (0x00)
+#define AXP2585_IC_TYPE             (0x03)
+#define AXP2585_GPIO1_CTL           (0x18)
+#define AXP2585_GPIO2_CTL           (0x19)
+#define AXP2585_GPIO1_SIGNAL        (0x1A)
+#define AXP2585_ADC_EN              (0x24)
+#define AXP2585_TS_PIN_CONTROL      (0x81)
+#define AXP2585_POK_SET             (0x15)
+#define AXP2585_OFF_CTL             (0x28)
+#define AXP2585_INTEN1              (0x40)
+#define AXP2585_INTEN2              (0x41)
+#define AXP2585_INTEN3              (0x42)
+#define AXP2585_INTEN4              (0x43)
+#define AXP2585_INTEN5              (0x44)
+#define AXP2585_INTEN6              (0x45)
+#define AXP2585_INTSTS1             (0x48)
+#define AXP2585_INTSTS2             (0x49)
+#define AXP2585_INTSTS3             (0x4A)
+#define AXP2585_INTSTS4             (0x4B)
+#define AXP2585_INTSTS5             (0x4C)
+#define AXP2585_INTSTS6             (0x4D)
+#define AXP2585_WARNING_LEVEL       (0xE6)
+#define AXP2585_ADDR_EXTENSION      (0xFF)
+
+
+/* bit definitions for AXP events ,irq event */
+/* AXP2585 */
+#define AXP2585_IRQ_ICTEMOV       (0)
+#define AXP2585_IRQ_PMOSEN        (1)
+#define AXP2585_IRQ_BUCKLO        (2)
+#define AXP2585_IRQ_BUCKHI        (3)
+#define AXP2585_IRQ_ACRE          (22)
+#define AXP2585_IRQ_ACIN          (23)
+#define AXP2585_IRQ_ACOV          (6)
+#define AXP2585_IRQ_VACIN         (7)
+#define AXP2585_IRQ_LOWN2         (7)//
+#define AXP2585_IRQ_LOWN1         (6)//
+#define AXP2585_IRQ_CHAOV         (38)
+#define AXP2585_IRQ_CHAST         (39)
+#define AXP2585_IRQ_BATSAFE_QUIT  (12)
+#define AXP2585_IRQ_BATSAFE_ENTER (13)
+#define AXP2585_IRQ_BATRE         (20)
+#define AXP2585_IRQ_BATIN         (21)
+#define AXP2585_IRQ_QBWUT         (16)
+#define AXP2585_IRQ_BWUT          (17)
+#define AXP2585_IRQ_QBWOT         (18)
+#define AXP2585_IRQ_BWOT          (19)
+#define AXP2585_IRQ_QBCUT         (20)
+#define AXP2585_IRQ_BCUT          (21)
+#define AXP2585_IRQ_QBCOT         (22)
+#define AXP2585_IRQ_BCOT          (23)
+#define AXP2585_IRQ_GPIO0         (24)
+#define AXP2585_IRQ_BATCHG        (5)//
+#define AXP2585_IRQ_POKOFF        (26)
+#define AXP2585_IRQ_POKLO         (27)
+#define AXP2585_IRQ_POKSH         (28)
+#define AXP2585_IRQ_PEKFE         (29)
+#define AXP2585_IRQ_PEKRE         (30)
+#define AXP2585_IRQ_BUCKOV_6V6    (32)
+
+#define AXP2585_IRQ_TCIN		  (46)
+#define AXP2585_IRQ_TCRE         (47)
+
+extern int axp_debug;
+extern struct axp_config_info axp2585_config;
+
+#endif /* AXP2585_H_ */

--- a/drivers/power/supply/axp/axp2585/axp2585-powerkey.c	1969-12-31 19:00:00.000000000 -0500
+++ b/drivers/power/supply/axp/axp2585/axp2585-powerkey.c	2022-09-01 10:46:35.786464423 -0400
@@ -0,0 +1,247 @@
+/*
+ * drivers/power/axp/axp2585/axp2585-powerkey.c
+ * (C) Copyright 2010-2017
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ *
+ * powerkey driver of axp2585
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/types.h>
+#include <linux/device.h>
+#include <linux/workqueue.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/power_supply.h>
+#include <linux/delay.h>
+#include <linux/kthread.h>
+#include <linux/slab.h>
+#include <linux/debugfs.h>
+#include <linux/seq_file.h>
+#include <linux/input.h>
+#include "../axp-core.h"
+#include "../axp-powerkey.h"
+#include "axp2585.h"
+
+static int axp2585_powerkey_probe(struct platform_device *pdev)
+{
+    printk("[axp2585]Entering %s\n",__func__);
+	struct axp_dev *axp_dev = dev_get_drvdata(pdev->dev.parent);
+	struct axp_powerkey_info *info;
+	struct input_dev *powerkey_dev;
+	int err = 0, i, irq, ret;
+	struct axp_regmap *map = axp_dev->regmap;
+	u8 val;
+    printk("==%s==line:%d==file:%s==\n",__func__,__LINE__,__FILE__);
+
+	if (axp_dev->is_slave)
+		return -EPERM;
+    printk("[axp2585] pointer to of_node is %p in line:%d in %s\n",
+                       pdev->dev.of_node,__LINE__,__func__);
+	if (pdev->dev.of_node) {
+		/* get dt and sysconfig */
+		ret = axp_powerkey_dt_parse(pdev->dev.of_node, &axp2585_config);
+		if (ret) {
+			pr_err("%s parse device tree err\n", __func__);
+			return -EINVAL;
+		}
+	} else {
+		pr_err("axp2585 powerkey device tree err!\n");
+		return -EBUSY;
+	}
+
+	info = kzalloc(sizeof(struct axp_powerkey_info), GFP_KERNEL);
+	if (!info)
+		return -ENOMEM;
+
+	info->chip = axp_dev;
+
+	/* register input device */
+	powerkey_dev = input_allocate_device();
+	if (!powerkey_dev) {
+		pr_err("alloc powerkey input device error\n");
+		goto out;
+	}
+    printk("==%s==line:%d==file:%s==\n",__func__,__LINE__,__FILE__);
+
+	powerkey_dev->name = pdev->name;
+	powerkey_dev->phys = "m1kbd/input2";
+	powerkey_dev->id.bustype = BUS_HOST;
+	powerkey_dev->id.vendor = 0x0001;
+	powerkey_dev->id.product = 0x0001;
+	powerkey_dev->id.version = 0x0100;
+	powerkey_dev->open = NULL;
+	powerkey_dev->close = NULL;
+	powerkey_dev->dev.parent = &pdev->dev;
+	set_bit(EV_KEY, powerkey_dev->evbit);
+	set_bit(EV_REL, powerkey_dev->evbit);
+	set_bit(KEY_POWER, powerkey_dev->keybit);
+
+	err = input_register_device(powerkey_dev);
+	if (err) {
+		pr_err("[axp2585]Unable to Register the axp_powerkey\n");
+		goto out_reg;
+	}
+
+	info->idev = powerkey_dev;
+    printk("==%s==line:%d==file:%s==\n",__func__,__LINE__,__FILE__);
+
+	for (i = 0; i < ARRAY_SIZE(axp_powerkey_irq); i++) {
+		irq = platform_get_irq_byname(pdev, axp_powerkey_irq[i].name);
+		if (irq < 0)
+			continue;
+	    printk("==%s==line:%d==file:%s==\n",__func__,__LINE__,__FILE__);
+
+		err = axp_request_irq(axp_dev, irq,
+				axp_powerkey_irq[i].isr, info);
+		if (err != 0) {
+			dev_err(&pdev->dev, "failed to request %s IRQ %d: %d\n"
+					, axp_powerkey_irq[i].name, irq, err);
+			goto out_irq;
+		}
+
+		dev_dbg(&pdev->dev, "Requested %s IRQ %d: %d\n",
+				axp_powerkey_irq[i].name, irq, err);
+	}
+
+	platform_set_drvdata(pdev, info);
+    printk("==%s==line:%d==file:%s==\n",__func__,__LINE__,__FILE__);
+
+	axp_regmap_read(map, AXP2585_POK_SET, &val);
+	if (axp2585_config.pmu_powkey_on_time < 628)
+		val &= 0xf3;
+	else if (axp2585_config.pmu_powkey_on_time < 1500) {
+		val &= 0xf3;
+		val |= 0x04;
+	} else if (axp2585_config.pmu_powkey_on_time < 2500) {
+		val &= 0xf3;
+		val |= 0x08;
+	} else {
+		val &= 0xf3;
+		val |= 0x0c;
+	}
+	axp_regmap_write(map, AXP2585_POK_SET, val);
+
+	/* pok long time set*/
+	if (axp2585_config.pmu_powkey_long_time < 1000)
+		axp2585_config.pmu_powkey_long_time = 1000;
+
+	if (axp2585_config.pmu_powkey_long_time > 2500)
+		axp2585_config.pmu_powkey_long_time = 2500;
+
+	axp_regmap_read(map, AXP2585_POK_SET, &val);
+	val &= 0x7f;
+	val |= (((axp2585_config.pmu_powkey_long_time - 1000) / 500) << 6);
+	axp_regmap_write(map, AXP2585_POK_SET, val);
+
+	/* pek offlevel poweroff time set*/
+	axp_regmap_read(map, AXP2585_POK_SET, &val);
+	if (axp2585_config.pmu_powkey_off_time < 4500)
+		val &= 0xfc;
+	else if (axp2585_config.pmu_powkey_off_time < 6500) {
+		val &= 0xfc;
+		val |= 0x01;
+	} else if (axp2585_config.pmu_powkey_off_time < 8500) {
+		val &= 0xfc;
+		val |= 0x02;
+	} else {
+		val &= 0xfc;
+		val |= 0x03;
+	}
+	axp_regmap_write(map, AXP2585_POK_SET, val);
+#if 0
+	/*Init offlevel restart or not */
+	if (axp2585_config.pmu_powkey_off_func)
+		axp_regmap_set_bits(map, AXP2585_POK_SET, 0x04); /* restart */
+	else
+		axp_regmap_clr_bits(map, AXP2585_POK_SET, 0x04); /* not restart*/
+
+	/* pek offlevel time set */
+	if (axp2585_config.pmu_powkey_off_time < 4000)
+		axp2585_config.pmu_powkey_off_time = 4000;
+
+	if (axp2585_config.pmu_powkey_off_time > 10000)
+		axp2585_config.pmu_powkey_off_time = 10000;
+
+	axp_regmap_read(map, AXP2585_POK_SET, &val);
+	val &= 0xfc;
+	val |= (axp2585_config.pmu_powkey_off_time - 4000) / 2000;
+	axp_regmap_write(map, AXP2585_POK_SET, val);
+#endif
+	return 0;
+	 printk("[axp2585]Quit %s\n",__func__);
+out_irq:
+	for (i = i - 1; i >= 0; i--) {
+		irq = platform_get_irq_byname(pdev, axp_powerkey_irq[i].name);
+		if (irq < 0)
+			continue;
+		axp_free_irq(axp_dev, irq);
+	}
+out_reg:
+	input_free_device(powerkey_dev);
+out:
+	kfree(info);
+	return err;
+}
+
+static int axp2585_powerkey_remove(struct platform_device *pdev)
+{
+	int i, irq;
+	struct axp_powerkey_info *info = platform_get_drvdata(pdev);
+	struct axp_dev *axp_dev = dev_get_drvdata(pdev->dev.parent);
+
+	for (i = 0; i < ARRAY_SIZE(axp_powerkey_irq); i++) {
+		irq = platform_get_irq_byname(pdev, axp_powerkey_irq[i].name);
+		if (irq < 0)
+			continue;
+		axp_free_irq(axp_dev, irq);
+	}
+
+	input_unregister_device(info->idev);
+	kfree(info);
+
+	return 0;
+}
+
+static const struct of_device_id axp2585_powerkey_dt_ids[] = {
+	{ .compatible = "axp2585-powerkey", },
+	{},
+};
+MODULE_DEVICE_TABLE(of, axp_powerkey_dt_ids);
+
+static struct platform_driver axp2585_powerkey_driver = {
+	.driver = {
+		.name = "axp2585-powerkey",
+		.of_match_table = axp2585_powerkey_dt_ids,
+	},
+	.probe  = axp2585_powerkey_probe,
+	.remove = axp2585_powerkey_remove,
+};
+
+//module_platform_driver(axp_powerkey_driver);
+//module_init(axp_powerkey_driver);
+static int __init axp2585_powerkey_initcall(void)
+{
+    int ret;
+
+    ret = platform_driver_register(&axp2585_powerkey_driver);
+    if (IS_ERR_VALUE(ret)) {
+        pr_err("%s: failed, errno %d\n", __func__, ret);
+        return -EINVAL;
+    }
+
+    return 0;
+}
+//fs_initcall_sync(axp2585_charger_initcall);
+late_initcall(axp2585_powerkey_initcall);
+
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("onkey Driver for axp2585 PMIC");
+MODULE_AUTHOR("Qin <qinyongshen@allwinnertech.com>");

--- a/drivers/power/supply/axp/axp-charger.c	1969-12-31 19:00:00.000000000 -0500
+++ b/drivers/power/supply/axp/axp-charger.c	2022-09-01 10:46:35.786464423 -0400
@@ -0,0 +1,1367 @@
+/*
+ * drivers/power/axp/axp-charger.c
+ * (C) Copyright 2010-2016
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * Pannan <pannan@allwinnertech.com>
+ *
+ * axp charger APIs
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/device.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/workqueue.h>
+#include <linux/types.h>
+#include <linux/slab.h>
+#include <linux/power_supply.h>
+#include <linux/of_device.h>
+#include <linux/interrupt.h>
+#include "axp-core.h"
+#include "axp-charger.h"
+
+static int axp_power_key;
+static enum AW_CHARGE_TYPE axp_usbcurflag = CHARGE_AC;
+static enum AW_CHARGE_TYPE axp_usbvolflag = CHARGE_AC;
+
+static struct axp_adc_res adc;
+static bool battery_initialized;
+static struct axp_config_info *axp_config_obj;
+static int plug_debounce;
+static DEFINE_SPINLOCK(axp_powerkey_lock);
+
+void axp_powerkey_set(int value)
+{
+	spin_lock(&axp_powerkey_lock);
+	axp_power_key = value;
+	spin_unlock(&axp_powerkey_lock);
+}
+EXPORT_SYMBOL_GPL(axp_powerkey_set);
+
+int axp_powerkey_get(void)
+{
+	int value;
+
+	spin_lock(&axp_powerkey_lock);
+	value = axp_power_key;
+	spin_unlock(&axp_powerkey_lock);
+
+	return value;
+}
+EXPORT_SYMBOL_GPL(axp_powerkey_get);
+
+int axp_usbvol(enum AW_CHARGE_TYPE type)
+{
+	axp_usbvolflag = type;
+	return 0;
+}
+EXPORT_SYMBOL_GPL(axp_usbvol);
+
+int axp_usbcur(enum AW_CHARGE_TYPE type)
+{
+	axp_usbcurflag = type;
+	return 0;
+}
+EXPORT_SYMBOL_GPL(axp_usbcur);
+
+static inline void axp_read_adc(struct axp_charger_dev *chg_dev,
+		struct axp_adc_res *adc)
+{
+	u8 tmp[2];
+	struct axp_regmap *map = chg_dev->chip->regmap;
+
+	axp_regmap_reads(map, chg_dev->spy_info->batt->bat_temp_offset,
+				2, tmp);
+	adc->ts_res = ((u16) tmp[0] << 8) | tmp[1];
+}
+
+static inline s32 axp_vts_to_temp(s32 data,
+		const struct axp_config_info *axp_config)
+{
+	s32 temp;
+
+	if (data < 80 || !axp_config->pmu_bat_temp_enable)
+		return 30;
+	else if (data < axp_config->pmu_bat_temp_para16)
+		return 80;
+	else if (data <= axp_config->pmu_bat_temp_para15) {
+		temp = 70 + (axp_config->pmu_bat_temp_para15-data)*10/
+		(axp_config->pmu_bat_temp_para15-axp_config->pmu_bat_temp_para16);
+	} else if (data <= axp_config->pmu_bat_temp_para14) {
+		temp = 60 + (axp_config->pmu_bat_temp_para14-data)*10/
+		(axp_config->pmu_bat_temp_para14-axp_config->pmu_bat_temp_para15);
+	} else if (data <= axp_config->pmu_bat_temp_para13) {
+		temp = 55 + (axp_config->pmu_bat_temp_para13-data)*5/
+		(axp_config->pmu_bat_temp_para13-axp_config->pmu_bat_temp_para14);
+	} else if (data <= axp_config->pmu_bat_temp_para12) {
+		temp = 50 + (axp_config->pmu_bat_temp_para12-data)*5/
+		(axp_config->pmu_bat_temp_para12-axp_config->pmu_bat_temp_para13);
+	} else if (data <= axp_config->pmu_bat_temp_para11) {
+		temp = 45 + (axp_config->pmu_bat_temp_para11-data)*5/
+		(axp_config->pmu_bat_temp_para11-axp_config->pmu_bat_temp_para12);
+	} else if (data <= axp_config->pmu_bat_temp_para10) {
+		temp = 40 + (axp_config->pmu_bat_temp_para10-data)*5/
+		(axp_config->pmu_bat_temp_para10-axp_config->pmu_bat_temp_para11);
+	} else if (data <= axp_config->pmu_bat_temp_para9) {
+		temp = 30 + (axp_config->pmu_bat_temp_para9-data)*10/
+		(axp_config->pmu_bat_temp_para9-axp_config->pmu_bat_temp_para10);
+	} else if (data <= axp_config->pmu_bat_temp_para8) {
+		temp = 20 + (axp_config->pmu_bat_temp_para8-data)*10/
+		(axp_config->pmu_bat_temp_para8-axp_config->pmu_bat_temp_para9);
+	} else if (data <= axp_config->pmu_bat_temp_para7) {
+		temp = 10 + (axp_config->pmu_bat_temp_para7-data)*10/
+		(axp_config->pmu_bat_temp_para7-axp_config->pmu_bat_temp_para8);
+	} else if (data <= axp_config->pmu_bat_temp_para6) {
+		temp = 5 + (axp_config->pmu_bat_temp_para6-data)*5/
+		(axp_config->pmu_bat_temp_para6-axp_config->pmu_bat_temp_para7);
+	} else if (data <= axp_config->pmu_bat_temp_para5) {
+		temp = 0 + (axp_config->pmu_bat_temp_para5-data)*5/
+		(axp_config->pmu_bat_temp_para5-axp_config->pmu_bat_temp_para6);
+	} else if (data <= axp_config->pmu_bat_temp_para4) {
+		temp = -5 + (axp_config->pmu_bat_temp_para4-data)*5/
+		(axp_config->pmu_bat_temp_para4-axp_config->pmu_bat_temp_para5);
+	} else if (data <= axp_config->pmu_bat_temp_para3) {
+		temp = -10 + (axp_config->pmu_bat_temp_para3-data)*5/
+		(axp_config->pmu_bat_temp_para3-axp_config->pmu_bat_temp_para4);
+	} else if (data <= axp_config->pmu_bat_temp_para2) {
+		temp = -15 + (axp_config->pmu_bat_temp_para2-data)*5/
+		(axp_config->pmu_bat_temp_para2-axp_config->pmu_bat_temp_para3);
+	} else if (data <= axp_config->pmu_bat_temp_para1) {
+		temp = -25 + (axp_config->pmu_bat_temp_para1-data)*10/
+		(axp_config->pmu_bat_temp_para1-axp_config->pmu_bat_temp_para2);
+	} else
+		temp = -25;
+	return temp;
+}
+
+static inline s32 axp_vts_to_mV(u16 reg)
+{
+	return ((s32)(((reg >> 8) << 4) | (reg & 0x000F))) * 800 / 1000;
+}
+
+static inline void axp_update_ictemp_status(struct axp_charger_dev *chg_dev)
+{
+	u16 tmp;
+	u8 temp_val[2];
+	struct axp_regmap *map = chg_dev->chip->regmap;
+
+	axp_regmap_reads(map, chg_dev->pmic_temp_offset, 2, temp_val);
+	tmp = (temp_val[0] << 4) + (temp_val[1] & 0x0F);
+	chg_dev->ic_temp = (s32) tmp * 1063 / 10000  - 2667 / 10;
+
+}
+
+static inline void axp_update_temp_status(struct axp_charger_dev *chg_dev)
+{
+	u16 tmp;
+	u8 temp_val[2];
+	s32 bat_temp_mv;
+	struct axp_regmap *map = chg_dev->chip->regmap;
+
+	chg_dev->adc = &adc;
+	axp_read_adc(chg_dev, &adc);
+
+	axp_regmap_reads(map, chg_dev->pmic_temp_offset, 2, temp_val);
+	tmp = (temp_val[0] << 4) + (temp_val[1] & 0x0F);
+	chg_dev->ic_temp = (s32) tmp * 1063 / 10000  - 2667 / 10;
+
+	tmp = chg_dev->adc->ts_res;
+	bat_temp_mv = axp_vts_to_mV(tmp);
+	chg_dev->bat_temp = axp_vts_to_temp(bat_temp_mv, axp_config_obj);
+
+}
+
+/*
+ * acin not presence + vbus no presence -> battery presence
+ */
+static int pwrsrc_parse_bat_det(struct axp_battery_info *batt, u8 val)
+{
+	if (!(val & ((1 << batt->acpresent_bit) | (1 << batt->vbuspresent_bit))))
+		return 1;
+	else
+		return 0;
+}
+
+static int det_parse_bat_det(struct axp_battery_info *batt, u8 val)
+{
+	if ((val & (1 << batt->det_bit)) && (val & (1 << batt->det_valid_bit)))
+		return 1;
+	else
+		return 0;
+}
+
+void axp_charger_update_state(struct axp_charger_dev *chg_dev)
+{
+	u8 val;
+	u8 pwrsrc;
+	struct axp_ac_info *ac = chg_dev->spy_info->ac;
+	struct axp_usb_info *usb = chg_dev->spy_info->usb;
+	struct axp_battery_info *batt = chg_dev->spy_info->batt;
+	struct axp_regmap *map = chg_dev->chip->regmap;
+#ifdef TYPE_C
+	struct axp_tc_info *tc = chg_dev->spy_info->tc;
+#endif
+	/*sleep 10ms for adapter stable*/
+	msleep(10);
+	axp_regmap_read(map, batt->det_offset, &val);
+	axp_regmap_read(map, batt->pwrsrc_offset, &pwrsrc);
+	mutex_lock(&chg_dev->charger_lock);
+	if (batt->det_unused == 0) {
+		if (batt->det_valid == 1) {
+			chg_dev->bat_det = pwrsrc_parse_bat_det(batt, pwrsrc);
+			if (chg_dev->bat_det == 0)
+				chg_dev->bat_det = det_parse_bat_det(batt, val);
+		} else if (batt->det_valid == 0) {
+			chg_dev->bat_det = (val & 1 << batt->det_bit) ? 1 : 0;
+		}
+	} else if (batt->det_unused == 1) {
+		chg_dev->bat_det = 0;
+	}
+	mutex_unlock(&chg_dev->charger_lock);
+
+	axp_regmap_read(map, ac->det_offset, &val);
+	mutex_lock(&chg_dev->charger_lock);
+	chg_dev->ac_det = (val & 1 << ac->det_bit) ? 1 : 0;
+	mutex_unlock(&chg_dev->charger_lock);
+
+	if (usb->det_unused == 0) {
+		axp_regmap_read(map, usb->det_offset, &val);
+		mutex_lock(&chg_dev->charger_lock);
+		chg_dev->usb_det = (val & 1 << usb->det_bit) ? 1 : 0;
+		mutex_unlock(&chg_dev->charger_lock);
+	} else if (usb->det_unused == 1) {
+		chg_dev->usb_det = 0;
+	}
+
+	axp_regmap_read(map, ac->valid_offset, &val);
+	mutex_lock(&chg_dev->charger_lock);
+	chg_dev->ac_valid = (val & 1 << ac->valid_bit) ? 1 : 0;
+	mutex_unlock(&chg_dev->charger_lock);
+
+	if (usb->det_unused == 0) {
+		axp_regmap_read(map, usb->valid_offset, &val);
+		mutex_lock(&chg_dev->charger_lock);
+		chg_dev->usb_valid = (val & 1 << usb->valid_bit) ? 1 : 0;
+		mutex_unlock(&chg_dev->charger_lock);
+	} else if (usb->det_unused == 1) {
+		chg_dev->usb_valid = 0;
+	}
+#ifdef TYPE_C
+	if (tc->det_unused == 0) {
+		axp_regmap_read(map, tc->det_offset, &val);
+		mutex_lock(&chg_dev->charger_lock);
+		chg_dev->tc_det = (val & 1 << tc->det_bit) ? 1 : 0;
+		mutex_unlock(&chg_dev->charger_lock);
+	} else if (tc->det_unused == 1) {
+		chg_dev->tc_det = 0;
+	}
+	if (tc->det_unused == 0) {
+		axp_regmap_read(map, tc->valid_offset, &val);
+		mutex_lock(&chg_dev->charger_lock);
+		chg_dev->tc_valid = (val & 1 << tc->valid_bit) ? 1 : 0;
+		mutex_unlock(&chg_dev->charger_lock);
+	} else if (tc->det_unused == 1) {
+		chg_dev->tc_valid = 0;
+	}
+	chg_dev->ext_valid = (chg_dev->ac_det ||
+				chg_dev->usb_det || chg_dev->tc_det);
+#else
+	chg_dev->ext_valid = (chg_dev->ac_det || chg_dev->usb_det);
+#endif
+
+	axp_regmap_read(map, ac->in_short_offset, &val);
+	mutex_lock(&chg_dev->charger_lock);
+#ifdef AXP2585
+	chg_dev->in_short = (val & 1 << ac->in_short_bit) ? 1 : 0;
+#else
+	chg_dev->in_short = 1;
+#endif
+	if (!chg_dev->in_short)
+		chg_dev->ac_charging = chg_dev->ac_valid;
+	mutex_unlock(&chg_dev->charger_lock);
+
+	axp_regmap_read(map, batt->cur_direction_offset, &val);
+	mutex_lock(&chg_dev->charger_lock);
+	if (val & 1 << batt->cur_direction_bit)
+		chg_dev->bat_current_direction = 1;
+	else
+		chg_dev->bat_current_direction = 0;
+	mutex_unlock(&chg_dev->charger_lock);
+
+	axp_regmap_read(map, batt->chgstat_offset, &val);
+	mutex_lock(&chg_dev->charger_lock);
+#ifdef AXP2585
+	chg_dev->charging = (((val & (7 << batt->chgstat_bit)) > 0) &&
+			     ((val & (7 << batt->chgstat_bit)) < 0x14)) ? 1 : 0;
+#else
+	chg_dev->charging = (val & 1 << batt->chgstat_bit) ? 1 : 0;
+#endif
+	mutex_unlock(&chg_dev->charger_lock);
+}
+
+
+void axp_charger_update_value(struct axp_charger_dev *chg_dev)
+{
+	struct axp_ac_info *ac = chg_dev->spy_info->ac;
+	struct axp_usb_info *usb = chg_dev->spy_info->usb;
+	struct axp_battery_info *batt = chg_dev->spy_info->batt;
+	int bat_vol, bat_cur, bat_discur, ac_vol, ac_cur, usb_vol, usb_cur;
+#ifdef TYPE_C
+/*	struct axp_tc_info *tc = chg_dev->spy_info->tc;
+	int tc_vol, tc_cur;
+*/
+#endif
+
+	bat_vol = batt->get_vbat(chg_dev);
+	bat_cur = batt->get_ibat(chg_dev);
+	bat_discur = batt->get_disibat(chg_dev);
+	ac_vol  = ac->get_ac_voltage(chg_dev);
+	ac_cur  = ac->get_ac_current(chg_dev);
+	usb_vol = usb->get_usb_voltage(chg_dev);
+	usb_cur = usb->get_usb_current(chg_dev);
+#ifdef TYPE_C
+/*tc_vol  = tc->get_tc_voltage(chg_dev);
+tc_cur  = tc->get_tc_current(chg_dev);*/
+#endif
+
+	mutex_lock(&chg_dev->charger_lock);
+	chg_dev->bat_vol = bat_vol;
+	chg_dev->bat_cur = bat_cur;
+	chg_dev->bat_discur = bat_discur;
+	chg_dev->ac_vol  = ac_vol;
+	chg_dev->ac_cur  = ac_cur;
+	chg_dev->usb_vol = usb_vol;
+	chg_dev->usb_cur = usb_cur;
+#ifdef TYPE_C
+/*	chg_dev->tc_vol  = tc_vol;
+	chg_dev->tc_cur  = tc_cur;
+*/
+#endif
+	mutex_unlock(&chg_dev->charger_lock);
+}
+
+static void axp_usb_ac_check_status(struct axp_charger_dev *chg_dev)
+{
+	chg_dev->usb_pc_charging = (((CHARGE_USB_20 == axp_usbcurflag)
+					|| (CHARGE_USB_30 == axp_usbcurflag))
+					&& (chg_dev->ext_valid));
+	chg_dev->usb_adapter_charging = ((0 == chg_dev->ac_valid)
+					&& (CHARGE_USB_20 != axp_usbcurflag)
+					&& (CHARGE_USB_30 != axp_usbcurflag)
+					&& (chg_dev->ext_valid));
+	if (chg_dev->in_short)
+		chg_dev->ac_charging = ((chg_dev->usb_adapter_charging == 0)
+					&& (chg_dev->usb_pc_charging == 0)
+					&& (chg_dev->ext_valid));
+	else
+		chg_dev->ac_charging = chg_dev->ac_valid;
+
+	power_supply_changed(chg_dev->ac);
+	power_supply_changed(chg_dev->usb);
+
+	AXP_DEBUG(AXP_CHG, chg_dev->chip->pmu_num,
+			"ac_charging=%d\n", chg_dev->ac_charging);
+	AXP_DEBUG(AXP_CHG, chg_dev->chip->pmu_num,
+			"usb_pc_charging=%d\n", chg_dev->usb_pc_charging);
+	AXP_DEBUG(AXP_CHG, chg_dev->chip->pmu_num,
+			"usb_adapter_charging=%d\n",
+			chg_dev->usb_adapter_charging);
+	AXP_DEBUG(AXP_CHG, chg_dev->chip->pmu_num,
+			"usb_det=%d ac_det=%d\n",
+			chg_dev->usb_det, chg_dev->ac_det);
+}
+
+static void axp_charger_update_usb_state(unsigned long data)
+{
+	struct axp_charger_dev *chg_dev = (struct axp_charger_dev *)data;
+
+	axp_usb_ac_check_status(chg_dev);
+
+	if (chg_dev->bat_det)
+		schedule_delayed_work(&(chg_dev->usbwork), 0);
+}
+
+static void axp_usb(struct work_struct *work)
+{
+	struct axp_charger_dev *chg_dev = container_of(work,
+					struct axp_charger_dev, usbwork.work);
+	struct axp_usb_info *usb = chg_dev->spy_info->usb;
+	struct axp_ac_info *ac = chg_dev->spy_info->ac;
+
+	AXP_DEBUG(AXP_CHG, chg_dev->chip->pmu_num,
+				"[axp_usb] axp_usbcurflag = %d\n",
+				axp_usbcurflag);
+	axp_charger_update_state(chg_dev);
+
+	if (chg_dev->in_short) {
+		/* usb and ac in short*/
+		if (!chg_dev->usb_valid) {
+			/*usb or usb adapter can not be used*/
+			AXP_DEBUG(AXP_CHG, chg_dev->chip->pmu_num,
+				"USB not insert!\n");
+			usb->set_usb_ihold(chg_dev, 500);
+		} else if (CHARGE_USB_20 == axp_usbcurflag) {
+			if (usb->usb_pc_cur) {
+				AXP_DEBUG(AXP_CHG, chg_dev->chip->pmu_num,
+						"set usb_pc_cur %d mA\n",
+						usb->usb_pc_cur);
+				usb->set_usb_ihold(chg_dev, usb->usb_pc_cur);
+			} else {
+				AXP_DEBUG(AXP_CHG, chg_dev->chip->pmu_num,
+						"set usb_pc_cur 500 mA\n");
+				usb->set_usb_ihold(chg_dev, 500);
+			}
+		} else if (CHARGE_USB_30 == axp_usbcurflag) {
+			AXP_DEBUG(AXP_CHG, chg_dev->chip->pmu_num,
+						"set usb_pc_cur 900 mA\n");
+			usb->set_usb_ihold(chg_dev, 900);
+		} else {
+			/* usb adapter */
+			if (usb->usb_ad_cur) {
+				AXP_DEBUG(AXP_CHG, chg_dev->chip->pmu_num,
+						"set usb_ad_cur %d mA\n",
+							usb->usb_ad_cur);
+			} else {
+				AXP_DEBUG(AXP_CHG, chg_dev->chip->pmu_num,
+						"set usb_ad_cur no limit\n");
+			}
+			usb->set_usb_ihold(chg_dev, usb->usb_ad_cur);
+		}
+
+		if (CHARGE_USB_20 == axp_usbvolflag) {
+			if (usb->usb_pc_vol) {
+				AXP_DEBUG(AXP_CHG, chg_dev->chip->pmu_num,
+						"set usb_pc_vol %d mV\n",
+							usb->usb_pc_vol);
+				usb->set_usb_vhold(chg_dev, usb->usb_pc_vol);
+			}
+		} else if (CHARGE_USB_30 == axp_usbvolflag) {
+			AXP_DEBUG(AXP_CHG, chg_dev->chip->pmu_num,
+						"set usb_pc_vol 4700 mV\n");
+			usb->set_usb_vhold(chg_dev, 4700);
+		} else {
+			if (usb->usb_ad_vol) {
+				AXP_DEBUG(AXP_CHG, chg_dev->chip->pmu_num,
+						"set usb_ad_vol %d mV\n",
+							usb->usb_ad_vol);
+				usb->set_usb_vhold(chg_dev, usb->usb_ad_vol);
+			}
+		}
+	} else {
+		if (!chg_dev->ac_valid && !chg_dev->usb_valid) {
+			/*usb and ac can not be used*/
+			AXP_DEBUG(AXP_CHG, chg_dev->chip->pmu_num,
+						"AC and USB not insert!\n");
+			usb->set_usb_ihold(chg_dev, 500);
+		} else if (CHARGE_USB_20 == axp_usbcurflag) {
+			if (usb->usb_pc_cur) {
+				AXP_DEBUG(AXP_CHG, chg_dev->chip->pmu_num,
+						"set usb_pc_cur %d mA\n",
+							usb->usb_pc_cur);
+				usb->set_usb_ihold(chg_dev, usb->usb_pc_cur);
+			} else {
+				AXP_DEBUG(AXP_CHG, chg_dev->chip->pmu_num,
+						"set usb_pc_cur 500 mA\n");
+				usb->set_usb_ihold(chg_dev, 500);
+			}
+		} else if (CHARGE_USB_30 == axp_usbcurflag) {
+			AXP_DEBUG(AXP_CHG, chg_dev->chip->pmu_num,
+						"set usb_pc_cur 900 mA\n");
+			usb->set_usb_ihold(chg_dev, 900);
+		} else {
+			if ((usb->usb_ad_cur)) {
+				AXP_DEBUG(AXP_CHG,
+						chg_dev->chip->pmu_num,
+						"set adapter cur %d mA\n",
+						usb->usb_ad_cur);
+			} else {
+				AXP_DEBUG(AXP_CHG,
+						chg_dev->chip->pmu_num,
+						"set adapter cur no limit\n");
+			}
+			usb->set_usb_ihold(chg_dev, usb->usb_ad_cur);
+		}
+
+		if (CHARGE_USB_20 == axp_usbvolflag) {
+			if (usb->usb_pc_vol) {
+				AXP_DEBUG(AXP_CHG, chg_dev->chip->pmu_num,
+						"set usb_pc_vol %d mV\n",
+							usb->usb_pc_vol);
+				usb->set_usb_vhold(chg_dev, usb->usb_pc_vol);
+			}
+		} else if (CHARGE_USB_30 == axp_usbvolflag) {
+			AXP_DEBUG(AXP_CHG, chg_dev->chip->pmu_num,
+						"set usb_pc_vol 4700 mV\n");
+			usb->set_usb_vhold(chg_dev, 4700);
+		} else {
+			if (ac->ac_vol) {
+				AXP_DEBUG(AXP_CHG, chg_dev->chip->pmu_num,
+						"set ac_vol %d mV\n",
+							ac->ac_vol);
+				ac->set_ac_vhold(chg_dev, ac->ac_vol);
+			}
+		}
+	}
+}
+
+void axp_battery_update_vol(struct axp_charger_dev *chg_dev)
+{
+	s32 rest_vol = 0;
+	struct axp_battery_info *batt = chg_dev->spy_info->batt;
+
+	rest_vol = batt->get_rest_cap(chg_dev);
+
+	mutex_lock(&chg_dev->charger_lock);
+	if (rest_vol > 100) {
+		AXP_DEBUG(AXP_SPLY, chg_dev->chip->pmu_num,
+			"AXP rest_vol = %d\n", rest_vol);
+		chg_dev->rest_vol = 100;
+	} else {
+		chg_dev->rest_vol = rest_vol;
+	}
+	mutex_unlock(&chg_dev->charger_lock);
+
+	AXP_DEBUG(AXP_SPLY, chg_dev->chip->pmu_num,
+			"charger->rest_vol = %d\n", chg_dev->rest_vol);
+}
+
+static enum power_supply_property axp_battery_props[] = {
+	POWER_SUPPLY_PROP_MODEL_NAME,
+	POWER_SUPPLY_PROP_STATUS,
+	POWER_SUPPLY_PROP_PRESENT,
+	POWER_SUPPLY_PROP_ONLINE,
+	POWER_SUPPLY_PROP_HEALTH,
+	POWER_SUPPLY_PROP_TECHNOLOGY,
+	POWER_SUPPLY_PROP_CHARGE_COUNTER,
+	POWER_SUPPLY_PROP_VOLTAGE_MAX_DESIGN,
+	POWER_SUPPLY_PROP_VOLTAGE_MIN_DESIGN,
+	POWER_SUPPLY_PROP_VOLTAGE_NOW,
+	POWER_SUPPLY_PROP_CURRENT_NOW,
+	POWER_SUPPLY_PROP_ENERGY_FULL_DESIGN,
+	POWER_SUPPLY_PROP_CAPACITY,
+	POWER_SUPPLY_PROP_TEMP,
+};
+
+static enum power_supply_property axp_ac_props[] = {
+	POWER_SUPPLY_PROP_MODEL_NAME,
+	POWER_SUPPLY_PROP_PRESENT,
+	POWER_SUPPLY_PROP_ONLINE,
+	POWER_SUPPLY_PROP_VOLTAGE_NOW,
+	POWER_SUPPLY_PROP_CURRENT_NOW,
+};
+
+static enum power_supply_property axp_usb_props[] = {
+	POWER_SUPPLY_PROP_MODEL_NAME,
+	POWER_SUPPLY_PROP_PRESENT,
+	POWER_SUPPLY_PROP_ONLINE,
+	POWER_SUPPLY_PROP_VOLTAGE_NOW,
+	POWER_SUPPLY_PROP_CURRENT_NOW,
+};
+
+#ifdef TYPE_C
+static enum power_supply_property axp_tc_props[] = {
+	POWER_SUPPLY_PROP_MODEL_NAME,
+	POWER_SUPPLY_PROP_PRESENT,
+	POWER_SUPPLY_PROP_ONLINE,
+	POWER_SUPPLY_PROP_VOLTAGE_NOW,
+	POWER_SUPPLY_PROP_CURRENT_NOW,
+};
+#endif
+
+static void axp_battery_check_status(struct axp_charger_dev *chg_dev,
+					union power_supply_propval *val)
+{
+	if (chg_dev->bat_det) {
+		if (chg_dev->ext_valid) {
+#ifdef TYPE_C
+			if (chg_dev->rest_vol == 96)
+#else
+			if (chg_dev->rest_vol == 100)
+#endif
+			val->intval = POWER_SUPPLY_STATUS_FULL;
+			else if (chg_dev->charging)
+				val->intval = POWER_SUPPLY_STATUS_CHARGING;
+			else
+				val->intval = POWER_SUPPLY_STATUS_NOT_CHARGING;
+		} else {
+			val->intval = POWER_SUPPLY_STATUS_DISCHARGING;
+		}
+	} else {
+		val->intval = POWER_SUPPLY_STATUS_FULL;
+	}
+}
+
+static void axp_battery_check_health(struct axp_charger_dev *chg_dev,
+					union power_supply_propval *val)
+{
+	struct axp_battery_info *batt = chg_dev->spy_info->batt;
+	val->intval = batt->get_bat_health(chg_dev);
+}
+
+static s32 axp_battery_get_property(struct power_supply *psy,
+					enum power_supply_property psp,
+					union power_supply_propval *val)
+{
+	struct axp_charger_dev *chg_dev = power_supply_get_drvdata(psy);
+	s32 ret = 0;
+
+	switch (psp) {
+	case POWER_SUPPLY_PROP_STATUS:
+		axp_battery_check_status(chg_dev, val);
+		break;
+	case POWER_SUPPLY_PROP_HEALTH:
+		axp_battery_check_health(chg_dev, val);
+		break;
+	case POWER_SUPPLY_PROP_TECHNOLOGY:
+		val->intval = chg_dev->battery_info->technology;
+		break;
+	case POWER_SUPPLY_PROP_CHARGE_COUNTER:
+		val->intval = chg_dev->coulumb_counter * 1000;
+		break;
+	case POWER_SUPPLY_PROP_VOLTAGE_MAX_DESIGN:
+		val->intval = chg_dev->battery_info->voltage_max_design;
+		break;
+	case POWER_SUPPLY_PROP_VOLTAGE_MIN_DESIGN:
+		val->intval = chg_dev->battery_info->voltage_min_design;
+		break;
+	case POWER_SUPPLY_PROP_VOLTAGE_NOW:
+		val->intval = chg_dev->bat_vol * 1000;
+		break;
+	case POWER_SUPPLY_PROP_CURRENT_NOW:
+		val->intval = (chg_dev->bat_cur - chg_dev->bat_discur) * 1000;
+		break;
+	case POWER_SUPPLY_PROP_MODEL_NAME:
+		val->strval = psy->desc->name;
+		break;
+	case POWER_SUPPLY_PROP_ENERGY_FULL_DESIGN:
+		val->intval = chg_dev->battery_info->energy_full_design;
+		break;
+	case POWER_SUPPLY_PROP_CAPACITY:
+		val->intval = chg_dev->rest_vol;
+		break;
+	case POWER_SUPPLY_PROP_ONLINE: {
+		/* in order to get hardware state,
+		 * we must update charger state now.
+		 * by sunny at 2012-12-23 11:06:15.
+		 */
+		axp_charger_update_state(chg_dev);
+		val->intval = !chg_dev->bat_current_direction;
+		break;
+	}
+	case POWER_SUPPLY_PROP_PRESENT:
+		val->intval = chg_dev->bat_det;
+		break;
+	case POWER_SUPPLY_PROP_TEMP:
+		val->intval = chg_dev->bat_temp * 10;
+		break;
+	default:
+		ret = -EINVAL;
+		break;
+	}
+
+	return ret;
+}
+
+static s32 axp_ac_get_property(struct power_supply *psy,
+					enum power_supply_property psp,
+					union power_supply_propval *val)
+{
+	struct axp_charger_dev *chg_dev = power_supply_get_drvdata(psy);
+	s32 ret = 0;
+
+	switch (psp) {
+	case POWER_SUPPLY_PROP_MODEL_NAME:
+		val->strval = psy->desc->name;
+		break;
+	case POWER_SUPPLY_PROP_PRESENT:
+	case POWER_SUPPLY_PROP_ONLINE:
+		val->intval = (chg_dev->ac_charging
+					|| chg_dev->usb_adapter_charging);
+		break;
+	case POWER_SUPPLY_PROP_VOLTAGE_NOW:
+		val->intval = chg_dev->ac_vol * 1000;
+		break;
+	case POWER_SUPPLY_PROP_CURRENT_NOW:
+		val->intval = chg_dev->ac_cur * 1000;
+		break;
+	default:
+		ret = -EINVAL;
+		break;
+	}
+
+	return ret;
+}
+
+static s32 axp_usb_get_property(struct power_supply *psy,
+					enum power_supply_property psp,
+					union power_supply_propval *val)
+{
+	struct axp_charger_dev *chg_dev = power_supply_get_drvdata(psy);
+	s32 ret = 0;
+
+	switch (psp) {
+	case POWER_SUPPLY_PROP_MODEL_NAME:
+		val->strval = psy->desc->name;
+		break;
+	case POWER_SUPPLY_PROP_PRESENT:
+	case POWER_SUPPLY_PROP_ONLINE:
+		val->intval = chg_dev->usb_pc_charging;
+		break;
+	case POWER_SUPPLY_PROP_VOLTAGE_NOW:
+		val->intval = chg_dev->usb_vol * 1000;
+		break;
+	case POWER_SUPPLY_PROP_CURRENT_NOW:
+		val->intval = chg_dev->usb_cur * 1000;
+		break;
+	default:
+		ret = -EINVAL;
+		break;
+	}
+
+	return ret;
+}
+
+#ifdef TYPE_C
+static s32 axp_tc_get_property(struct power_supply *psy,
+					enum power_supply_property psp,
+					union power_supply_propval *val)
+{
+	struct axp_charger_dev *chg_dev = power_supply_get_drvdata(psy);
+	s32 ret = 0;
+
+	switch (psp) {
+	case POWER_SUPPLY_PROP_MODEL_NAME:
+		val->strval = psy->desc->name;
+		break;
+	case POWER_SUPPLY_PROP_PRESENT:
+	case POWER_SUPPLY_PROP_ONLINE:
+		val->intval = chg_dev->tc_valid;
+		break;
+	case POWER_SUPPLY_PROP_VOLTAGE_NOW:
+		val->intval = chg_dev->tc_vol * 1000;
+		break;
+	case POWER_SUPPLY_PROP_CURRENT_NOW:
+		val->intval = chg_dev->tc_cur * 1000;
+		break;
+	default:
+		ret = -EINVAL;
+		break;
+	}
+
+	return ret;
+}
+#endif
+
+static char *supply_list[] = {
+	"battery",
+};
+static const struct power_supply_desc batt_desc = {
+	.name = "battery",
+	.type = POWER_SUPPLY_TYPE_BATTERY,
+	.get_property = axp_battery_get_property,
+	.properties = axp_battery_props,
+	.num_properties = ARRAY_SIZE(axp_battery_props),
+	.use_for_apm = 1,
+};
+
+static const struct power_supply_desc ac_desc = {
+	.name = "ac",
+	.type = POWER_SUPPLY_TYPE_MAINS,
+	.get_property = axp_ac_get_property,
+	.properties = axp_ac_props,
+	.num_properties = ARRAY_SIZE(axp_ac_props),
+};
+
+static const struct power_supply_desc usb_desc = {
+	.name = "usb",
+	.type = POWER_SUPPLY_TYPE_USB,
+	.get_property = axp_usb_get_property,
+	.properties = axp_usb_props,
+	.num_properties = ARRAY_SIZE(axp_usb_props),
+};
+
+#ifdef TYPE_C
+static const struct power_supply_desc tc_desc = {
+	.name = "tc",
+	.type = POWER_SUPPLY_TYPE_USB_TYPE_C,
+	.get_property = axp_tc_get_property,
+	.properties = axp_tc_props,
+	.num_properties = ARRAY_SIZE(axp_tc_props),
+};
+#endif
+static struct power_supply_config psy_cfg = {
+	.supplied_to = supply_list,
+	.num_supplicants = ARRAY_SIZE(supply_list),
+};
+
+static void axp_charging_monitor(struct work_struct *work)
+{
+	struct axp_charger_dev *chg_dev = container_of(work,
+					struct axp_charger_dev, work.work);
+	struct power_supply_config psy_cfg = {};
+	static s32 pre_rest_vol;
+	static bool pre_bat_curr_dir;
+
+	axp_charger_update_state(chg_dev);
+
+	/* if no battery exist, then return */
+	if (!chg_dev->bat_det) {
+
+		axp_update_ictemp_status(chg_dev);
+
+		AXP_DEBUG(AXP_MISC, chg_dev->chip->pmu_num,
+				"charger->ic_temp = %d\n", chg_dev->ic_temp);
+		schedule_delayed_work(&chg_dev->work, chg_dev->interval);
+		return;
+	}
+	/* if battery hadn't been detectd before, register it as power supply
+	 * now */
+	if (!battery_initialized) {
+			psy_cfg.drv_data = chg_dev;
+			chg_dev->batt = power_supply_register(chg_dev->dev,
+					&batt_desc, &psy_cfg);
+			battery_initialized = true;
+	}
+
+	axp_charger_update_value(chg_dev);
+	axp_update_temp_status(chg_dev);
+
+	AXP_DEBUG(AXP_SPLY, chg_dev->chip->pmu_num,
+			"[axp]charger->ic_temp = %d\n", chg_dev->ic_temp);
+	AXP_DEBUG(AXP_SPLY, chg_dev->chip->pmu_num,
+			"[axp]charger->bat_temp = %d\n", chg_dev->bat_temp);
+	AXP_DEBUG(AXP_SPLY, chg_dev->chip->pmu_num,
+			"[axp]charger->bat_vol = %d\n", chg_dev->bat_vol);
+	AXP_DEBUG(AXP_SPLY, chg_dev->chip->pmu_num,
+			"[axp]charger->bat_cur = %d\n", chg_dev->bat_cur);
+	AXP_DEBUG(AXP_SPLY, chg_dev->chip->pmu_num,
+			"[axp]charger->bat_discur = %d\n", chg_dev->bat_discur);
+	AXP_DEBUG(AXP_SPLY, chg_dev->chip->pmu_num,
+			"[axp]charger->is_charging = %d\n", chg_dev->charging);
+	AXP_DEBUG(AXP_SPLY, chg_dev->chip->pmu_num,
+			"[axp]charger->bat_current_direction = %d\n",
+			chg_dev->bat_current_direction);
+	AXP_DEBUG(AXP_SPLY, chg_dev->chip->pmu_num,
+			"[axp]charger->ext_valid = %d\n", chg_dev->ext_valid);
+	chg_dev->private_debug(chg_dev);
+	if (!plug_debounce) {
+		if (chg_dev->private_debug)
+			axp_battery_update_vol(chg_dev);
+	} else {
+		plug_debounce = 0;
+	}
+
+
+	/* if battery volume changed, inform uevent */
+	if ((chg_dev->rest_vol - pre_rest_vol)
+			|| (chg_dev->bat_current_direction != pre_bat_curr_dir)
+		) {
+		AXP_DEBUG(AXP_SPLY, chg_dev->chip->pmu_num,
+				"battery vol change: %d->%d\n",
+				pre_rest_vol, chg_dev->rest_vol);
+		pre_rest_vol = chg_dev->rest_vol;
+		pre_bat_curr_dir = chg_dev->bat_current_direction;
+		power_supply_changed(chg_dev->batt);
+	}
+
+	/* reschedule for the next time */
+	schedule_delayed_work(&chg_dev->work, chg_dev->interval);
+}
+
+void axp_change(struct axp_charger_dev *chg_dev)
+{
+	AXP_DEBUG(AXP_INT, chg_dev->chip->pmu_num, "[axp]battery state change\n");
+	axp_charger_update_state(chg_dev);
+	axp_charger_update_value(chg_dev);
+	if (chg_dev->bat_det && battery_initialized)
+		power_supply_changed(chg_dev->batt);
+}
+EXPORT_SYMBOL_GPL(axp_change);
+
+void axp_usbac_in(struct axp_charger_dev *chg_dev)
+{
+	struct axp_usb_info *usb = chg_dev->spy_info->usb;
+
+	axp_usbcur(CHARGE_AC);
+	axp_usbvol(CHARGE_AC);
+
+	AXP_DEBUG(AXP_CHG, chg_dev->chip->pmu_num, "axp ac/usb in!\n");
+
+	if (timer_pending(&chg_dev->usb_status_timer))
+		del_timer_sync(&chg_dev->usb_status_timer);
+
+	/* must limit the current now,
+	 * and will again fix it while usb/ac detect finished!
+	*/
+	if (usb->usb_pc_cur)
+		usb->set_usb_ihold(chg_dev, usb->usb_pc_cur);
+	else
+		usb->set_usb_ihold(chg_dev, 500);
+	plug_debounce = 1;
+	/* this is about 3.5s,
+	* while the flag set in usb drivers after usb plugged
+	*/
+	axp_charger_update_state(chg_dev);
+	mod_timer(&chg_dev->usb_status_timer,
+				jiffies + msecs_to_jiffies(5000));
+	axp_usb_ac_check_status(chg_dev);
+}
+EXPORT_SYMBOL_GPL(axp_usbac_in);
+
+void axp_usbac_out(struct axp_charger_dev *chg_dev)
+{
+	AXP_DEBUG(AXP_CHG, chg_dev->chip->pmu_num, "axp ac/usb out!\n");
+
+	if (timer_pending(&chg_dev->usb_status_timer))
+		del_timer_sync(&chg_dev->usb_status_timer);
+
+	/* if we plugged usb & ac at the same time,
+	 * then unpluged ac quickly while the usb driver
+	 * do not finished detecting,
+	 * the charger type is error!So delay the charger type report 2s
+	*/
+	mod_timer(&chg_dev->usb_status_timer,
+					jiffies + msecs_to_jiffies(2000));
+	axp_usb_ac_check_status(chg_dev);
+}
+EXPORT_SYMBOL_GPL(axp_usbac_out);
+
+void axp_capchange(struct axp_charger_dev *chg_dev)
+{
+	struct power_supply_config psy_cfg = {};
+
+	AXP_DEBUG(AXP_INT, chg_dev->chip->pmu_num, "battery change\n");
+
+	axp_charger_update_state(chg_dev);
+	axp_charger_update_value(chg_dev);
+	axp_battery_update_vol(chg_dev);
+
+	if (chg_dev->bat_det) {
+		AXP_DEBUG(AXP_INT, chg_dev->chip->pmu_num, "rest_vol = %d\n",
+				chg_dev->rest_vol);
+		if (!battery_initialized) {
+			psy_cfg.drv_data = chg_dev;
+			chg_dev->batt = power_supply_register(chg_dev->dev,
+					&batt_desc, &psy_cfg);
+			schedule_delayed_work(&chg_dev->usbwork, 0);
+			schedule_delayed_work(&chg_dev->work, 0);
+			power_supply_changed(chg_dev->batt);
+			battery_initialized = true;
+		}
+	} else {
+		if (battery_initialized) {
+			cancel_delayed_work_sync(&chg_dev->work);
+			cancel_delayed_work_sync(&chg_dev->usbwork);
+			power_supply_unregister(chg_dev->batt);
+			chg_dev->batt = NULL;
+			battery_initialized = false;
+		}
+	}
+}
+EXPORT_SYMBOL_GPL(axp_capchange);
+
+irqreturn_t axp_usb_in_isr(int irq, void *data)
+{
+	struct axp_charger_dev *chg_dev = data;
+    printk("[axp]Entering isr :%s\n",__func__);
+	axp_usb_connect = 1;
+	axp_change(chg_dev);
+	axp_usbac_in(chg_dev);
+
+	return IRQ_HANDLED;
+    printk("[axp]Quit isr :%s\n",__func__);
+
+}
+
+irqreturn_t axp_usb_out_isr(int irq, void *data)
+{
+	struct axp_charger_dev *chg_dev = data;
+    printk("[axp]Entering isr :%s\n",__func__);
+
+	axp_usb_connect = 0;
+	axp_change(chg_dev);
+	axp_usbac_out(chg_dev);
+
+	return IRQ_HANDLED;
+    printk("[axp]Quit isr :%s\n",__func__);
+
+}
+
+irqreturn_t axp_ac_in_isr(int irq, void *data)
+{
+	struct axp_charger_dev *chg_dev = data;
+    printk("[axp]Entering isr :%s\n",__func__);
+
+	axp_change(chg_dev);
+	axp_usbac_in(chg_dev);
+
+	return IRQ_HANDLED;
+    printk("[axp]Quit isr :%s\n",__func__);
+
+}
+
+irqreturn_t axp_ac_out_isr(int irq, void *data)
+{
+	struct axp_charger_dev *chg_dev = data;
+    printk("[axp]Entering isr :%s\n",__func__);
+
+	axp_change(chg_dev);
+	axp_usbac_out(chg_dev);
+
+	return IRQ_HANDLED;
+    printk("[axp]Quit isr :%s\n",__func__);
+
+}
+
+irqreturn_t axp_capchange_isr(int irq, void *data)
+{
+	struct axp_charger_dev *chg_dev = data;
+    printk("[axp]Entering isr :%s\n",__func__);
+
+	axp_capchange(chg_dev);
+
+	return IRQ_HANDLED;
+    printk("[axp]Quit isr :%s\n",__func__);
+
+}
+
+irqreturn_t axp_change_isr(int irq, void *data)
+{
+	struct axp_charger_dev *chg_dev = data;
+    printk("[axp]Entering isr :%s\n",__func__);
+
+	axp_change(chg_dev);
+
+	return IRQ_HANDLED;
+    printk("[axp]Quit isr :%s\n",__func__);
+
+}
+
+irqreturn_t axp_low_warning1_isr(int irq, void *data)
+{
+	struct axp_charger_dev *chg_dev = data;
+    printk("[axp]Entering isr :%s\n",__func__);
+
+	axp_change(chg_dev);
+
+	return IRQ_HANDLED;
+    printk("[axp]Quit isr :%s\n",__func__);
+
+}
+
+irqreturn_t axp_low_warning2_isr(int irq, void *data)
+{
+	struct axp_charger_dev *chg_dev = data;
+    printk("[axp]Entering isr :%s\n",__func__);
+
+	axp_change(chg_dev);
+
+	return IRQ_HANDLED;
+    printk("[axp]Quit isr :%s\n",__func__);
+
+
+}
+
+#ifdef TYPE_C
+irqreturn_t axp_tc_in_isr(int irq, void *data)
+{
+	struct axp_charger_dev *chg_dev = data;
+
+	axp_change(chg_dev);
+	/*axp_usbac_in(chg_dev);*/
+
+	return IRQ_HANDLED;
+}
+
+irqreturn_t axp_tc_out_isr(int irq, void *data)
+{
+	struct axp_charger_dev *chg_dev = data;
+
+	axp_change(chg_dev);
+	/*axp_usbac_out(chg_dev);*/
+
+	return IRQ_HANDLED;
+}
+#endif
+void axp_charger_suspend(struct axp_charger_dev *chg_dev)
+{
+	struct axp_battery_info *batt = chg_dev->spy_info->batt;
+
+	axp_charger_update_state(chg_dev);
+
+	if (chg_dev->bat_det) {
+		schedule_delayed_work(&chg_dev->usbwork, 0);
+		flush_delayed_work(&chg_dev->usbwork);
+		cancel_delayed_work_sync(&chg_dev->work);
+		cancel_delayed_work_sync(&chg_dev->usbwork);
+
+		batt->set_chg_cur(chg_dev, batt->suspend_chgcur);
+	}
+}
+EXPORT_SYMBOL_GPL(axp_charger_suspend);
+
+void axp_charger_resume(struct axp_charger_dev *chg_dev)
+{
+	struct axp_battery_info *batt = chg_dev->spy_info->batt;
+
+	axp_charger_update_state(chg_dev);
+	axp_charger_update_value(chg_dev);
+	axp_battery_update_vol(chg_dev);
+
+	batt->set_chg_cur(chg_dev, batt->runtime_chgcur);
+
+	power_supply_changed(chg_dev->ac);
+	power_supply_changed(chg_dev->usb);
+
+	if (chg_dev->bat_det) {
+		power_supply_changed(chg_dev->batt);
+		schedule_delayed_work(&chg_dev->work, chg_dev->interval);
+		schedule_delayed_work(&chg_dev->usbwork,
+					msecs_to_jiffies(7 * 1000));
+	}
+}
+EXPORT_SYMBOL_GPL(axp_charger_resume);
+
+void axp_charger_shutdown(struct axp_charger_dev *chg_dev)
+{
+	struct axp_battery_info *batt = chg_dev->spy_info->batt;
+	axp_charger_update_state(chg_dev);
+
+	if (chg_dev->bat_det) {
+		schedule_delayed_work(&chg_dev->usbwork, 0);
+		flush_delayed_work(&chg_dev->usbwork);
+		cancel_delayed_work_sync(&chg_dev->work);
+		cancel_delayed_work_sync(&chg_dev->usbwork);
+		batt->set_chg_cur(chg_dev, batt->shutdown_chgcur);
+
+	}
+}
+EXPORT_SYMBOL_GPL(axp_charger_shutdown);
+
+struct axp_charger_dev *axp_power_supply_register(struct device *dev,
+					struct axp_dev *axp_dev,
+					struct power_supply_info *battery_info,
+					struct axp_supply_info *info)
+{
+	struct axp_charger_dev *chg_dev;
+
+	chg_dev = devm_kzalloc(dev, sizeof(*chg_dev), GFP_KERNEL);
+	if (chg_dev == NULL)
+		return NULL;
+
+	chg_dev->dev = dev;
+	chg_dev->spy_info = info;
+	chg_dev->chip = axp_dev;
+	chg_dev->battery_info = battery_info;
+	psy_cfg.drv_data = chg_dev;
+
+	mutex_init(&chg_dev->charger_lock);
+
+	axp_charger_update_state(chg_dev);
+	if (chg_dev->bat_det) {
+		chg_dev->batt = power_supply_register(dev,
+				&batt_desc, &psy_cfg);
+		if (IS_ERR(chg_dev->batt))
+			goto err_ps_register;
+		battery_initialized = true;
+	}
+
+	chg_dev->ac = power_supply_register(dev, &ac_desc, &psy_cfg);
+	if (IS_ERR(chg_dev->ac)) {
+		if (chg_dev->bat_det) {
+			power_supply_unregister(chg_dev->batt);
+			chg_dev->batt = NULL;
+			goto err_ps_register;
+		}
+	}
+
+	chg_dev->usb = power_supply_register(dev, &usb_desc, &psy_cfg);
+	if (IS_ERR(chg_dev->usb)) {
+		power_supply_unregister(chg_dev->ac);
+		chg_dev->ac = NULL;
+		if (chg_dev->bat_det) {
+			power_supply_unregister(chg_dev->batt);
+			chg_dev->batt = NULL;
+			goto err_ps_register;
+		}
+	}
+#ifdef TYPE_C
+	chg_dev->tc = power_supply_register(dev, &tc_desc, &psy_cfg);
+	if (IS_ERR(chg_dev->tc)) {
+		power_supply_unregister(chg_dev->ac);
+		power_supply_unregister(chg_dev->usb);
+		chg_dev->ac = NULL;
+		chg_dev->usb = NULL;
+		if (chg_dev->bat_det) {
+			power_supply_unregister(chg_dev->batt);
+			chg_dev->batt = NULL;
+			goto err_ps_register;
+		}
+	}
+	if (info->tc->tc_vol && info->tc->set_tc_vhold)
+		info->tc->set_tc_vhold(chg_dev, info->tc->tc_vol);
+#endif
+
+	if (info->ac->ac_vol && info->ac->set_ac_vhold)
+		info->ac->set_ac_vhold(chg_dev, info->ac->ac_vol);
+
+	if (info->usb->usb_pc_vol && info->usb->set_usb_vhold)
+		info->usb->set_usb_vhold(chg_dev, info->usb->usb_pc_vol);
+
+	if (info->batt->runtime_chgcur && info->batt->set_chg_cur)
+		info->batt->set_chg_cur(chg_dev, info->batt->runtime_chgcur);
+
+	setup_timer(&chg_dev->usb_status_timer,
+			axp_charger_update_usb_state, (unsigned long)chg_dev);
+	INIT_DELAYED_WORK(&(chg_dev->usbwork), axp_usb);
+
+	axp_usb_ac_check_status(chg_dev);
+	axp_battery_update_vol(chg_dev);
+
+	chg_dev->interval = msecs_to_jiffies(10 * 1000);
+	INIT_DELAYED_WORK(&chg_dev->work, axp_charging_monitor);
+
+	schedule_delayed_work(&chg_dev->work, chg_dev->interval);
+	if (timer_pending(&chg_dev->usb_status_timer))
+		del_timer_sync(&chg_dev->usb_status_timer);
+	mod_timer(&chg_dev->usb_status_timer,
+		jiffies + msecs_to_jiffies(20 * 1000));
+
+	return chg_dev;
+
+err_ps_register:
+	return NULL;
+}
+EXPORT_SYMBOL_GPL(axp_power_supply_register);
+
+void axp_power_supply_unregister(struct axp_charger_dev *chg_dev)
+{
+	del_timer_sync(&chg_dev->usb_status_timer);
+	power_supply_unregister(chg_dev->usb);
+	chg_dev->batt = NULL;
+	power_supply_unregister(chg_dev->ac);
+	chg_dev->ac = NULL;
+
+	if (chg_dev->bat_det && battery_initialized) {
+		cancel_delayed_work_sync(&chg_dev->work);
+		cancel_delayed_work_sync(&chg_dev->usbwork);
+		power_supply_unregister(chg_dev->batt);
+		chg_dev->batt = NULL;
+		battery_initialized = false;
+	}
+}
+EXPORT_SYMBOL_GPL(axp_power_supply_unregister);
+
+int axp_charger_dt_parse(struct device_node *node,
+			struct axp_config_info *axp_config)
+{
+	if (!of_device_is_available(node)) {
+		pr_err("%s: failed\n", __func__);
+		return -1;
+	}
+
+	AXP_OF_PROP_READ(pmu_battery_rdc,              BATRDC);
+	AXP_OF_PROP_READ(pmu_battery_cap,                4000);
+	AXP_OF_PROP_READ(pmu_batdeten,                      1);
+	AXP_OF_PROP_READ(pmu_chg_ic_temp,                   0);
+	AXP_OF_PROP_READ(pmu_runtime_chgcur, INTCHGCUR / 1000);
+	AXP_OF_PROP_READ(pmu_suspend_chgcur,             1200);
+	AXP_OF_PROP_READ(pmu_shutdown_chgcur,            1200);
+	AXP_OF_PROP_READ(pmu_init_chgvol,    INTCHGVOL / 1000);
+	AXP_OF_PROP_READ(pmu_init_chgend_rate,  INTCHGENDRATE);
+	AXP_OF_PROP_READ(pmu_init_chg_enabled,              1);
+	AXP_OF_PROP_READ(pmu_init_bc_en,                    0);
+	AXP_OF_PROP_READ(pmu_init_adc_freq,        INTADCFREQ);
+	AXP_OF_PROP_READ(pmu_init_adcts_freq,     INTADCFREQC);
+	AXP_OF_PROP_READ(pmu_init_chg_pretime,  INTCHGPRETIME);
+	AXP_OF_PROP_READ(pmu_init_chg_csttime,  INTCHGCSTTIME);
+	AXP_OF_PROP_READ(pmu_batt_cap_correct,              1);
+	AXP_OF_PROP_READ(pmu_chg_end_on_en,                 0);
+	AXP_OF_PROP_READ(ocv_coulumb_100,                   0);
+	AXP_OF_PROP_READ(pmu_bat_para1,               OCVREG0);
+	AXP_OF_PROP_READ(pmu_bat_para2,               OCVREG1);
+	AXP_OF_PROP_READ(pmu_bat_para3,               OCVREG2);
+	AXP_OF_PROP_READ(pmu_bat_para4,               OCVREG3);
+	AXP_OF_PROP_READ(pmu_bat_para5,               OCVREG4);
+	AXP_OF_PROP_READ(pmu_bat_para6,               OCVREG5);
+	AXP_OF_PROP_READ(pmu_bat_para7,               OCVREG6);
+	AXP_OF_PROP_READ(pmu_bat_para8,               OCVREG7);
+	AXP_OF_PROP_READ(pmu_bat_para9,               OCVREG8);
+	AXP_OF_PROP_READ(pmu_bat_para10,              OCVREG9);
+	AXP_OF_PROP_READ(pmu_bat_para11,              OCVREGA);
+	AXP_OF_PROP_READ(pmu_bat_para12,              OCVREGB);
+	AXP_OF_PROP_READ(pmu_bat_para13,              OCVREGC);
+	AXP_OF_PROP_READ(pmu_bat_para14,              OCVREGD);
+	AXP_OF_PROP_READ(pmu_bat_para15,              OCVREGE);
+	AXP_OF_PROP_READ(pmu_bat_para16,              OCVREGF);
+	AXP_OF_PROP_READ(pmu_bat_para17,             OCVREG10);
+	AXP_OF_PROP_READ(pmu_bat_para18,             OCVREG11);
+	AXP_OF_PROP_READ(pmu_bat_para19,             OCVREG12);
+	AXP_OF_PROP_READ(pmu_bat_para20,             OCVREG13);
+	AXP_OF_PROP_READ(pmu_bat_para21,             OCVREG14);
+	AXP_OF_PROP_READ(pmu_bat_para22,             OCVREG15);
+	AXP_OF_PROP_READ(pmu_bat_para23,             OCVREG16);
+	AXP_OF_PROP_READ(pmu_bat_para24,             OCVREG17);
+	AXP_OF_PROP_READ(pmu_bat_para25,             OCVREG18);
+	AXP_OF_PROP_READ(pmu_bat_para26,             OCVREG19);
+	AXP_OF_PROP_READ(pmu_bat_para27,             OCVREG1A);
+	AXP_OF_PROP_READ(pmu_bat_para28,             OCVREG1B);
+	AXP_OF_PROP_READ(pmu_bat_para29,             OCVREG1C);
+	AXP_OF_PROP_READ(pmu_bat_para30,             OCVREG1D);
+	AXP_OF_PROP_READ(pmu_bat_para31,             OCVREG1E);
+	AXP_OF_PROP_READ(pmu_bat_para32,             OCVREG1F);
+	AXP_OF_PROP_READ(pmu_ac_vol,                     4400);
+	AXP_OF_PROP_READ(pmu_usbpc_vol,                  4400);
+	AXP_OF_PROP_READ(pmu_ac_cur,                        0);
+	AXP_OF_PROP_READ(pmu_usbpc_cur,                     0);
+	AXP_OF_PROP_READ(pmu_pwroff_vol,                 3300);
+	AXP_OF_PROP_READ(pmu_pwron_vol,                  2900);
+	AXP_OF_PROP_READ(pmu_battery_warning_level1,       15);
+	AXP_OF_PROP_READ(pmu_battery_warning_level2,        0);
+	AXP_OF_PROP_READ(pmu_restvol_adjust_time,          30);
+	AXP_OF_PROP_READ(pmu_ocv_cou_adjust_time,          60);
+	AXP_OF_PROP_READ(pmu_chgled_func,                   0);
+	AXP_OF_PROP_READ(pmu_chgled_type,                   0);
+	AXP_OF_PROP_READ(pmu_bat_temp_enable,               0);
+	AXP_OF_PROP_READ(pmu_bat_charge_ltf,             0xA5);
+	AXP_OF_PROP_READ(pmu_bat_charge_htf,             0x1F);
+	AXP_OF_PROP_READ(pmu_bat_shutdown_ltf,           0xFC);
+	AXP_OF_PROP_READ(pmu_bat_shutdown_htf,           0x16);
+	AXP_OF_PROP_READ(pmu_bat_temp_para1,                0);
+	AXP_OF_PROP_READ(pmu_bat_temp_para2,                0);
+	AXP_OF_PROP_READ(pmu_bat_temp_para3,                0);
+	AXP_OF_PROP_READ(pmu_bat_temp_para4,                0);
+	AXP_OF_PROP_READ(pmu_bat_temp_para5,                0);
+	AXP_OF_PROP_READ(pmu_bat_temp_para6,                0);
+	AXP_OF_PROP_READ(pmu_bat_temp_para7,                0);
+	AXP_OF_PROP_READ(pmu_bat_temp_para8,                0);
+	AXP_OF_PROP_READ(pmu_bat_temp_para9,                0);
+	AXP_OF_PROP_READ(pmu_bat_temp_para10,               0);
+	AXP_OF_PROP_READ(pmu_bat_temp_para11,               0);
+	AXP_OF_PROP_READ(pmu_bat_temp_para12,               0);
+	AXP_OF_PROP_READ(pmu_bat_temp_para13,               0);
+	AXP_OF_PROP_READ(pmu_bat_temp_para14,               0);
+	AXP_OF_PROP_READ(pmu_bat_temp_para15,               0);
+	AXP_OF_PROP_READ(pmu_bat_temp_para16,               0);
+	AXP_OF_PROP_READ(pmu_bat_unused,                    0);
+	AXP_OF_PROP_READ(power_start,                       0);
+	AXP_OF_PROP_READ(pmu_ocv_en,                        1);
+	AXP_OF_PROP_READ(pmu_cou_en,                        1);
+	AXP_OF_PROP_READ(pmu_update_min_time,   UPDATEMINTIME);
+
+	axp_config_obj = axp_config;
+	return 0;
+}
+EXPORT_SYMBOL_GPL(axp_charger_dt_parse);
+
+MODULE_DESCRIPTION("ALLWINNERTECH axp charger");
+MODULE_AUTHOR("pannan");
+MODULE_LICENSE("GPL");

--- a/drivers/power/supply/axp/axp-charger.h	1969-12-31 19:00:00.000000000 -0500
+++ b/drivers/power/supply/axp/axp-charger.h	2022-09-01 10:46:35.786464423 -0400
@@ -0,0 +1,382 @@
+/*
+ * drivers/power/axp/axp-charger.h
+ * (C) Copyright 2010-2016
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * Pannan <pannan@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ */
+
+#ifndef AXP_CHARGER_H
+#define AXP_CHARGER_H
+
+#include <linux/power_supply.h>
+
+#ifdef CONFIG_ARCH_SUN8IW15P1
+/*#define TYPE_C*/
+#define AXP2585
+#endif
+
+#define BATRDC          100
+#define INTCHGCUR       300000      /* set initial charging current limite */
+#define SUSCHGCUR       1000000     /* set suspend charging current limite */
+#define RESCHGCUR       INTCHGCUR   /* set resume charging current limite */
+#define CLSCHGCUR       SUSCHGCUR   /* set shutdown charging current limite */
+#define INTCHGVOL       4200000     /* set initial charing target voltage */
+#define INTCHGENDRATE   10          /* set initial charing end current rate */
+#define INTCHGENABLED   1           /* set initial charing enabled */
+#define INTADCFREQ      25          /* set initial adc frequency */
+#define INTADCFREQC     100         /* set initial coulomb adc coufrequency */
+#define INTCHGPRETIME   50          /* set initial pre-charging time */
+#define INTCHGCSTTIME   480         /* set initial pre-charging time */
+#define BATMAXVOL       4200000     /* set battery max design volatge */
+#define BATMINVOL       3500000     /* set battery min design volatge */
+#define UPDATEMINTIME   30          /* set bat percent update min time */
+
+#define OCVREG0         0x00        /* 2.99V */
+#define OCVREG1         0x00        /* 3.13V */
+#define OCVREG2         0x00        /* 3.27V */
+#define OCVREG3         0x00        /* 3.34V */
+#define OCVREG4         0x00        /* 3.41V */
+#define OCVREG5         0x00        /* 3.48V */
+#define OCVREG6         0x00        /* 3.52V */
+#define OCVREG7         0x00        /* 3.55V */
+#define OCVREG8         0x04        /* 3.57V */
+#define OCVREG9         0x05        /* 3.59V */
+#define OCVREGA         0x06        /* 3.61V */
+#define OCVREGB         0x07        /* 3.63V */
+#define OCVREGC         0x0a        /* 3.64V */
+#define OCVREGD         0x0d        /* 3.66V */
+#define OCVREGE         0x1a        /* 3.70V */
+#define OCVREGF         0x24        /* 3.73V */
+#define OCVREG10        0x29        /* 3.77V */
+#define OCVREG11        0x2e        /* 3.78V */
+#define OCVREG12        0x32        /* 3.80V */
+#define OCVREG13        0x35        /* 3.84V */
+#define OCVREG14        0x39        /* 3.85V */
+#define OCVREG15        0x3d        /* 3.87V */
+#define OCVREG16        0x43        /* 3.91V */
+#define OCVREG17        0x49        /* 3.94V */
+#define OCVREG18        0x4f        /* 3.98V */
+#define OCVREG19        0x54        /* 4.01V */
+#define OCVREG1A        0x58        /* 4.05V */
+#define OCVREG1B        0x5c        /* 4.08V */
+#define OCVREG1C        0x5e        /* 4.10V */
+#define OCVREG1D        0x60        /* 4.12V */
+#define OCVREG1E        0x62        /* 4.14V */
+#define OCVREG1F        0x64        /* 4.15V */
+
+#define AXP_OF_PROP_READ(name, def_value)\
+do {\
+	if (of_property_read_u32(node, #name, &axp_config->name))\
+		axp_config->name = def_value;\
+} while (0)
+
+struct axp_charger_dev;
+
+struct axp_config_info {
+	u32 pmu_used;
+	u32 pmu_id;
+	u32 pmu_battery_rdc;
+	u32 pmu_battery_cap;
+	u32 pmu_batdeten;
+	u32 pmu_chg_ic_temp;
+	u32 pmu_runtime_chgcur;
+	u32 pmu_suspend_chgcur;
+	u32 pmu_shutdown_chgcur;
+	u32 pmu_init_chgvol;
+	u32 pmu_init_chgend_rate;
+	u32 pmu_init_chg_enabled;
+	u32 pmu_init_bc_en;
+	u32 pmu_init_adc_freq;
+	u32 pmu_init_adcts_freq;
+	u32 pmu_init_chg_pretime;
+	u32 pmu_init_chg_csttime;
+	u32 pmu_batt_cap_correct;
+	u32 pmu_chg_end_on_en;
+	u32 ocv_coulumb_100;
+
+	u32 pmu_bat_para1;
+	u32 pmu_bat_para2;
+	u32 pmu_bat_para3;
+	u32 pmu_bat_para4;
+	u32 pmu_bat_para5;
+	u32 pmu_bat_para6;
+	u32 pmu_bat_para7;
+	u32 pmu_bat_para8;
+	u32 pmu_bat_para9;
+	u32 pmu_bat_para10;
+	u32 pmu_bat_para11;
+	u32 pmu_bat_para12;
+	u32 pmu_bat_para13;
+	u32 pmu_bat_para14;
+	u32 pmu_bat_para15;
+	u32 pmu_bat_para16;
+	u32 pmu_bat_para17;
+	u32 pmu_bat_para18;
+	u32 pmu_bat_para19;
+	u32 pmu_bat_para20;
+	u32 pmu_bat_para21;
+	u32 pmu_bat_para22;
+	u32 pmu_bat_para23;
+	u32 pmu_bat_para24;
+	u32 pmu_bat_para25;
+	u32 pmu_bat_para26;
+	u32 pmu_bat_para27;
+	u32 pmu_bat_para28;
+	u32 pmu_bat_para29;
+	u32 pmu_bat_para30;
+	u32 pmu_bat_para31;
+	u32 pmu_bat_para32;
+
+	u32 pmu_ac_vol;
+	u32 pmu_ac_cur;
+	u32 pmu_usbpc_vol;
+	u32 pmu_usbpc_cur;
+	u32 pmu_pwroff_vol;
+	u32 pmu_pwron_vol;
+	u32 pmu_powkey_off_time;
+	u32 pmu_powkey_off_en;
+	u32 pmu_powkey_off_delay_time;
+	u32 pmu_powkey_off_func;
+	u32 pmu_powkey_long_time;
+	u32 pmu_powkey_on_time;
+	u32 pmu_pwrok_time;
+	u32 pmu_pwrnoe_time;
+	u32 pmu_reset_shutdown_en;
+	u32 pmu_battery_warning_level1;
+	u32 pmu_battery_warning_level2;
+	u32 pmu_restvol_adjust_time;
+	u32 pmu_ocv_cou_adjust_time;
+	u32 pmu_chgled_func;
+	u32 pmu_chgled_type;
+	u32 pmu_vbusen_func;
+	u32 pmu_reset;
+	u32 pmu_irq_wakeup;
+	u32 pmu_hot_shutdown;
+	u32 pmu_inshort;
+	u32 power_start;
+	u32 pmu_as_slave;
+	u32 pmu_bat_unused;
+	u32 pmu_ocv_en;
+	u32 pmu_cou_en;
+	u32 pmu_update_min_time;
+
+	u32 pmu_bat_temp_enable;
+	u32 pmu_bat_charge_ltf;
+	u32 pmu_bat_charge_htf;
+	u32 pmu_bat_shutdown_ltf;
+	u32 pmu_bat_shutdown_htf;
+	u32 pmu_bat_temp_para1;
+	u32 pmu_bat_temp_para2;
+	u32 pmu_bat_temp_para3;
+	u32 pmu_bat_temp_para4;
+	u32 pmu_bat_temp_para5;
+	u32 pmu_bat_temp_para6;
+	u32 pmu_bat_temp_para7;
+	u32 pmu_bat_temp_para8;
+	u32 pmu_bat_temp_para9;
+	u32 pmu_bat_temp_para10;
+	u32 pmu_bat_temp_para11;
+	u32 pmu_bat_temp_para12;
+	u32 pmu_bat_temp_para13;
+	u32 pmu_bat_temp_para14;
+	u32 pmu_bat_temp_para15;
+	u32 pmu_bat_temp_para16;
+};
+
+struct axp_ac_info {
+	int det_bit;    /* ac detect */
+	int det_offset;
+	int valid_bit;  /* ac vali */
+	int valid_offset;
+	int in_short_bit;
+	int in_short_offset;
+	int ac_vol;
+	int ac_cur;
+	int (*get_ac_voltage)(struct axp_charger_dev *cdev);
+	int (*get_ac_current)(struct axp_charger_dev *cdev);
+	int (*set_ac_vhold)(struct axp_charger_dev *cdev, int vol);
+	int (*get_ac_vhold)(struct axp_charger_dev *cdev);
+	int (*set_ac_ihold)(struct axp_charger_dev *cdev, int cur);
+	int (*get_ac_ihold)(struct axp_charger_dev *cdev);
+};
+
+struct axp_usb_info {
+	int det_bit;
+	int det_offset;
+	int valid_bit;
+	int valid_offset;
+	int det_unused;
+	int usb_pc_vol;
+	int usb_pc_cur;
+	int usb_ad_vol;
+	int usb_ad_cur;
+	int (*get_usb_voltage)(struct axp_charger_dev *cdev);
+	int (*get_usb_current)(struct axp_charger_dev *cdev);
+	int (*set_usb_vhold)(struct axp_charger_dev *cdev, int vol);
+	int (*get_usb_vhold)(struct axp_charger_dev *cdev);
+	int (*set_usb_ihold)(struct axp_charger_dev *cdev, int cur);
+	int (*get_usb_ihold)(struct axp_charger_dev *cdev);
+};
+
+struct axp_battery_info {
+	int acpresent_bit;
+	int vbuspresent_bit;
+	int pwrsrc_offset;
+	int chgstat_bit;
+	int chgstat_offset;
+	int bat_temp_offset;
+	int det_bit;
+	int det_offset;
+	int det_valid_bit;
+	int det_valid;
+	int det_unused;
+	int cur_direction_bit;
+	int cur_direction_offset;
+	int polling_delay;
+	int runtime_chgcur;
+	int suspend_chgcur;
+	int shutdown_chgcur;
+	int (*get_rest_cap)(struct axp_charger_dev *cdev);
+	int (*get_bat_health)(struct axp_charger_dev *cdev);
+	int (*get_vbat)(struct axp_charger_dev *cdev);
+	int (*get_ibat)(struct axp_charger_dev *cdev);
+	int (*get_disibat)(struct axp_charger_dev *cdev);
+	int (*set_chg_cur)(struct axp_charger_dev *cdev, int cur);
+	int (*set_chg_vol)(struct axp_charger_dev *cdev, int vol);
+	int (*pre_time_set)(struct axp_charger_dev *cdev, int min);
+	int (*pos_time_set)(struct axp_charger_dev *cdev, int min);
+};
+
+#ifdef TYPE_C
+struct axp_tc_info {
+int det_bit;
+int det_offset;
+int valid_bit;
+int valid_offset;
+int det_unused;
+int tc_vol;
+int tc_cur;
+int (*get_tc_vol)(struct axp_charger_dev *cdev);
+int (*get_tc_cur)(struct axp_charger_dev *cdev);
+int (*set_tc_vhold)(struct axp_charger_dev *cdev, int vol);
+int (*get_tc_vhold)(struct axp_charger_dev *cdev);
+int (*set_tc_ihold)(struct axp_charger_dev *cdev, int cur);
+int (*get_tc_ihold)(struct axp_charger_dev *cdev);
+
+};
+#endif
+struct axp_supply_info {
+	struct axp_ac_info *ac;
+	struct axp_usb_info *usb;
+	struct axp_battery_info *batt;
+#ifdef TYPE_C
+	struct axp_tc_info *tc;
+#endif
+};
+
+struct axp_charger_dev {
+	struct power_supply *batt;
+	struct power_supply *ac;
+	struct power_supply *usb;
+#ifdef TYPE_C
+	struct power_supply *tc;
+#endif
+	struct power_supply_info *battery_info;
+	struct axp_supply_info *spy_info;
+	struct device *dev;
+	struct axp_dev *chip;
+	struct timer_list usb_status_timer;
+	struct delayed_work work;
+	struct delayed_work usbwork;
+	unsigned int interval;
+	struct mutex charger_lock;
+
+	int rest_vol;
+	int usb_vol;
+	int usb_cur;
+	int ac_vol;
+	int ac_cur;
+#ifdef TYPE_C
+	int tc_vol;
+	int tc_cur;
+#endif
+	int bat_vol;
+	int bat_cur;
+	int bat_discur;
+	int coulumb_counter;
+	bool bat_det;
+	bool ac_det;
+	bool usb_det;
+	bool ac_valid;
+	bool usb_valid;
+#ifdef TYPE_C
+	bool tc_det;
+	bool tc_valid;
+#endif
+	bool ext_valid;
+	bool in_short;
+	bool charging;
+	bool ac_charging;
+	bool usb_pc_charging;
+	bool usb_adapter_charging;
+	bool bat_current_direction;
+
+	int pmic_temp_offset;
+
+	/*ic temperature*/
+	s32 ic_temp;
+	s32 bat_temp;
+
+	struct axp_adc_res *adc;
+
+	void (*private_debug)(struct axp_charger_dev *cdev);
+};
+
+struct axp_adc_res {
+	uint16_t vbat_res;
+	uint16_t ocvbat_res;
+	uint16_t ibat_res;
+	uint16_t ichar_res;
+	uint16_t idischar_res;
+	uint16_t vac_res;
+	uint16_t iac_res;
+	uint16_t vusb_res;
+	uint16_t iusb_res;
+	uint16_t ts_res;
+};
+
+struct axp_charger_dev *axp_power_supply_register(struct device *dev,
+					struct axp_dev *axp_dev,
+					struct power_supply_info *battery_info,
+					struct axp_supply_info *info);
+void axp_power_supply_unregister(struct axp_charger_dev *chg_dev);
+void axp_change(struct axp_charger_dev *chg_dev);
+void axp_usbac_in(struct axp_charger_dev *chg_dev);
+void axp_usbac_out(struct axp_charger_dev *chg_dev);
+void axp_capchange(struct axp_charger_dev *chg_dev);
+void axp_charger_suspend(struct axp_charger_dev *chg_dev);
+void axp_charger_resume(struct axp_charger_dev *chg_dev);
+void axp_charger_shutdown(struct axp_charger_dev *chg_dev);
+int axp_charger_dt_parse(struct device_node *node,
+					struct axp_config_info *axp_config);
+extern irqreturn_t axp_usb_in_isr(int irq, void *data);
+extern irqreturn_t axp_usb_out_isr(int irq, void *data);
+extern irqreturn_t axp_ac_in_isr(int irq, void *data);
+extern irqreturn_t axp_ac_out_isr(int irq, void *data);
+extern irqreturn_t axp_capchange_isr(int irq, void *data);
+extern irqreturn_t axp_change_isr(int irq, void *data);
+extern irqreturn_t axp_low_warning1_isr(int irq, void *data);
+extern irqreturn_t axp_low_warning2_isr(int irq, void *data);
+#ifdef TYPE_C
+extern irqreturn_t axp_tc_in_isr(int irq, void *data);
+extern irqreturn_t axp_tc_out_isr(int irq, void *data);
+#endif
+
+
+#endif /* AXP_ChARGER_H */

--- a/drivers/power/supply/axp/axp-core.c	1969-12-31 19:00:00.000000000 -0500
+++ b/drivers/power/supply/axp/axp-core.c	2022-09-01 10:46:35.786464423 -0400
@@ -0,0 +1,1217 @@
+/*
+ * drivers/power/axp/axp-core.c
+ * (C) Copyright 2010-2016
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * Pannan <pannan@allwinnertech.com>
+ *
+ * axp common APIs
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/mutex.h>
+#include <linux/init.h>
+#include <linux/device.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+#include <linux/mfd/core.h>
+#include <linux/delay.h>
+#include <linux/slab.h>
+#include <linux/i2c.h>
+
+#include "axp-core.h"
+
+int axp_suspend_flag = AXP_NOT_SUSPEND;
+struct axp_platform_ops ap_ops[AXP_ONLINE_SUM];
+const char *axp_name[AXP_ONLINE_SUM];
+static LIST_HEAD(axp_dev_list);
+static DEFINE_SPINLOCK(axp_list_lock);
+int axp_dev_register_count;
+struct work_struct axp_irq_work;
+/* used for mark whether a pwr_dm belongs to sys_pwr_dm or not. */
+//static u32 axp_sys_pwr_dm_mask;
+//static u32 axp_power_tree[VCC_MAX_INDEX] = {0};
+//static DEFINE_SPINLOCK(axp_pwr_data_lock);
+int axp_usb_connect;
+
+void axp_platform_ops_set(int pmu_num, struct axp_platform_ops *ops)
+{
+	ap_ops[pmu_num].usb_det = ops->usb_det;
+	ap_ops[pmu_num].usb_vbus_output = ops->usb_vbus_output;
+	//ap_ops[pmu_num].cfg_pmux_para = ops->cfg_pmux_para;
+	ap_ops[pmu_num].get_pmu_name = ops->get_pmu_name;
+	ap_ops[pmu_num].get_pmu_dev  = ops->get_pmu_dev;
+	ap_ops[pmu_num].pmu_regulator_save = ops->pmu_regulator_save;
+	ap_ops[pmu_num].pmu_regulator_restore = ops->pmu_regulator_restore;
+}
+
+s32 axp_usb_det(void)
+{
+	u8 id = 0;
+
+#ifdef CONFIG_DUAL_AXP_USED
+	id = 1;
+#endif
+	if (!ap_ops[id].usb_det)
+		return 0;
+
+	return ap_ops[id].usb_det();
+}
+EXPORT_SYMBOL_GPL(axp_usb_det);
+
+s32 axp_usb_vbus_output(int high)
+{
+	u8 id = 0;
+
+#ifdef CONFIG_DUAL_AXP_USED
+	id = 1;
+#endif
+	if (!ap_ops[id].usb_vbus_output)
+		return 0;
+
+	return ap_ops[id].usb_vbus_output(high);
+}
+EXPORT_SYMBOL_GPL(axp_usb_vbus_output);
+
+int axp_usb_is_connected(void)
+{
+	return axp_usb_connect;
+}
+EXPORT_SYMBOL_GPL(axp_usb_is_connected);
+/*
+int config_pmux_para(int num, struct aw_pm_info *api, int *pmu_id)
+{
+	if (num >= AXP_ONLINE_SUM)
+		return -EINVAL;
+
+	if (ap_ops[num].cfg_pmux_para)
+		return ap_ops[num].cfg_pmux_para(num, api, pmu_id);
+	else
+		return -EINVAL;
+}
+EXPORT_SYMBOL_GPL(config_pmux_para);
+*/
+const char *get_pmu_cur_name(int pmu_num)
+{
+	if (ap_ops[pmu_num].get_pmu_name)
+		return ap_ops[pmu_num].get_pmu_name();
+	else
+		return NULL;
+}
+EXPORT_SYMBOL_GPL(get_pmu_cur_name);
+
+struct axp_dev *get_pmu_cur_dev(int pmu_num)
+{
+	printk("get_pmu_cur_dev~~~~~~~~~~~strong\n");
+	if (ap_ops[pmu_num].get_pmu_dev)
+		return ap_ops[pmu_num].get_pmu_dev();
+	else
+		return NULL;
+}
+EXPORT_SYMBOL_GPL(get_pmu_cur_dev);
+
+int axp_mem_save(void)
+{
+	if (ap_ops[0].pmu_regulator_save)
+		return ap_ops[0].pmu_regulator_save();
+	return 0;
+}
+EXPORT_SYMBOL_GPL(axp_mem_save);
+
+void axp_mem_restore(void)
+{
+	if (ap_ops[0].pmu_regulator_restore)
+		return ap_ops[0].pmu_regulator_restore();
+}
+EXPORT_SYMBOL_GPL(axp_mem_restore);
+
+int axp_get_pmu_num(const struct axp_compatible_name_mapping *mapping, int size)
+{
+	struct device_node *np;
+	int i, j, pmu_num = -EINVAL;
+	char node_name[8];
+	const char *prop_name = NULL;
+
+	for (i = 0; i < AXP_ONLINE_SUM; i++) {
+		sprintf(node_name, "pmu%d", i);
+
+		np = of_find_node_by_type(NULL, node_name);
+		if (NULL == np) {
+			BUG_ON(i == 0);
+			break;
+		}
+
+		if (of_property_read_string(np, "compatible",
+					&prop_name)) {
+			pr_err("%s get failed\n", prop_name);
+			break;
+		}
+
+		for (j = 0; j < size; j++) {
+			if (!strcmp(prop_name, mapping[j].device_name)) {
+				pmu_num = i;
+				break;
+			}
+		}
+	}
+
+	return pmu_num;
+}
+
+int axp_mfd_cell_name_init(const struct axp_compatible_name_mapping *mapping,
+				int count, int pmu_num,
+				int size, struct mfd_cell *cells)
+{
+	int i, j, find = 0;
+
+	for (j = 0; j < count; j++) {
+		if ((mapping[j].mfd_name.powerkey_name != NULL)
+				&& (strstr(mapping[j].mfd_name.powerkey_name,
+				axp_name[pmu_num]) != NULL)) {
+			find = 1;
+			break;
+		}
+
+		if ((mapping[j].mfd_name.regulator_name != NULL)
+				&& (strstr(mapping[j].mfd_name.regulator_name,
+				axp_name[pmu_num]) != NULL)) {
+			find = 1;
+			break;
+		}
+
+		if ((mapping[j].mfd_name.charger_name != NULL)
+				&& (strstr(mapping[j].mfd_name.charger_name,
+				axp_name[pmu_num]) != NULL)) {
+			find = 1;
+			break;
+		}
+
+		if ((mapping[j].mfd_name.gpio_name != NULL)
+				&& (strstr(mapping[j].mfd_name.gpio_name,
+				axp_name[pmu_num]) != NULL)) {
+			find = 1;
+			break;
+		}
+	}
+
+	if (find == 0) {
+		pr_err("%s no axp mfd cell find\n", __func__);
+		return -EINVAL;
+	}
+
+	for (i = 0; i < size; i++) {
+		if (strstr(cells[i].name, "powerkey") != NULL)
+			cells[i].of_compatible =
+					mapping[j].mfd_name.powerkey_name;
+		else if (strstr(cells[i].name, "regulator") != NULL)
+			cells[i].of_compatible =
+					mapping[j].mfd_name.regulator_name;
+		else if (strstr(cells[i].name, "charger") != NULL)
+			cells[i].of_compatible =
+					mapping[j].mfd_name.charger_name;
+		else if (strstr(cells[i].name, "gpio") != NULL)
+			cells[i].of_compatible =
+					mapping[j].mfd_name.gpio_name;
+	}
+
+	return 0;
+}
+
+static s32 __axp_read_i2c(struct i2c_client *client, u32 reg, u8 *val)
+{
+	s32 ret;
+
+	ret = i2c_smbus_read_byte_data(client, reg);
+	if (ret < 0) {
+		dev_err(&client->dev, "failed reading at 0x%02x\n", reg);
+		return ret;
+	}
+
+	*val = (u8)ret;
+
+	return 0;
+}
+
+static s32 __axp_reads_i2c(struct i2c_client *client,
+				int reg, int len, u8 *val)
+{
+	s32 ret;
+
+	ret = i2c_smbus_read_i2c_block_data(client, reg, len, val);
+	if (ret < 0) {
+		dev_err(&client->dev, "failed reading from 0x%02x\n", reg);
+		return ret;
+	}
+
+	return 0;
+}
+
+static s32 __axp_write_i2c(struct i2c_client *client, int reg, u8 val)
+{
+	s32 ret;
+
+	/* axp_reg_debug(reg, 1, &val); */
+	ret = i2c_smbus_write_byte_data(client, reg, val);
+	if (ret < 0) {
+		dev_err(&client->dev, "failed writing 0x%02x to 0x%02x\n",
+				val, reg);
+		return ret;
+	}
+
+	return 0;
+}
+
+static s32 __axp_writes_i2c(struct i2c_client *client,
+				int reg, int len, u8 *val)
+{
+	s32 ret;
+
+	/* axp_reg_debug(reg, len, val); */
+	ret = i2c_smbus_write_i2c_block_data(client, reg, len, val);
+	if (ret < 0) {
+		dev_err(&client->dev, "failed writings to 0x%02x\n", reg);
+		return ret;
+	}
+
+	return 0;
+}
+
+
+
+
+static s32 _axp_write(struct axp_regmap *map, s32 reg, u8 val, bool sync)
+{
+	s32 ret = 0;
+
+	pr_debug("%s: map->type = 0x%x, reg = 0x%x, val = %u, sync= %d.\n",
+		__func__, map->type, reg, val, sync);
+
+	if (map->type == AXP_REGMAP_I2C)
+		ret = __axp_write_i2c(map->client, reg, val);
+	return ret;
+}
+
+static s32 _axp_writes(struct axp_regmap *map, s32 reg,
+				s32 len, u8 *val, bool sync)
+{
+	s32 ret = 0, i;
+	s32 wr_len, rw_reg;
+	u8 wr_val[32];
+
+	pr_debug("%s: map->type = 0x%x, reg = 0x%x, val addr = 0x%p, sync= %d.\n",
+		__func__, map->type, reg, val, sync);
+
+	while (len) {
+		wr_len = min(len, 15);
+		rw_reg = reg++;
+		wr_val[0] = *val++;
+
+		for (i = 1; i < wr_len; i++) {
+			wr_val[i*2-1] = reg++;
+			wr_val[i*2] = *val++;
+		}
+
+		if (map->type == AXP_REGMAP_I2C)
+			ret = __axp_writes_i2c(map->client,
+					rw_reg, 2*wr_len-1, wr_val);
+		if (ret)
+			return ret;
+
+		len -= wr_len;
+	}
+
+	return 0;
+}
+
+static s32 _axp_read(struct axp_regmap *map, s32 reg, u8 *val, bool sync)
+{
+	s32 ret = 0;
+
+	if (map->type == AXP_REGMAP_I2C)
+		ret = __axp_read_i2c(map->client, reg, val);
+		pr_debug("%s: map->type = 0x%x, reg = 0x%x, val = 0x%hhx, sync= %d.\n",
+		__func__, map->type, reg, *val, sync);
+	return ret;
+}
+
+static s32 _axp_reads(struct axp_regmap *map, s32 reg,
+				s32 len, u8 *val, bool sync)
+{
+	s32 ret = 0;
+
+	pr_debug("%s: map->type = 0x%x, reg = 0x%x, val addr = 0x%p, sync= %d.\n",
+		__func__, map->type, reg, val, sync);
+
+	if (map->type == AXP_REGMAP_I2C)
+		ret = __axp_reads_i2c(map->client, reg, len, val);
+
+	return ret;
+}
+
+s32 axp_regmap_write(struct axp_regmap *map, s32 reg, u8 val)
+{
+	s32 ret = 0;
+
+	mutex_lock(&map->lock);
+	ret = _axp_write(map, reg, val, false);
+	mutex_unlock(&map->lock);
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(axp_regmap_write);
+
+s32 axp_regmap_writes(struct axp_regmap *map, s32 reg, s32 len, u8 *val)
+{
+	s32 ret = 0;
+
+	mutex_lock(&map->lock);
+	ret = _axp_writes(map, reg, len, val, false);
+	mutex_unlock(&map->lock);
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(axp_regmap_writes);
+
+s32 axp_regmap_read(struct axp_regmap *map, s32 reg, u8 *val)
+{
+	return _axp_read(map, reg, val, false);
+}
+EXPORT_SYMBOL_GPL(axp_regmap_read);
+
+s32 axp_regmap_reads(struct axp_regmap *map, s32 reg, s32 len, u8 *val)
+{
+	return _axp_reads(map, reg, len, val, false);
+}
+EXPORT_SYMBOL_GPL(axp_regmap_reads);
+
+s32 axp_regmap_set_bits(struct axp_regmap *map, s32 reg, u8 bit_mask)
+{
+	u8 reg_val;
+	s32 ret = 0;
+
+	mutex_lock(&map->lock);
+	ret = _axp_read(map, reg, &reg_val, false);
+
+	if (ret)
+		goto out;
+
+	if ((reg_val & bit_mask) != bit_mask) {
+		reg_val |= bit_mask;
+		ret = _axp_write(map, reg, reg_val, false);
+	}
+
+out:
+	mutex_unlock(&map->lock);
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(axp_regmap_set_bits);
+
+s32 axp_regmap_clr_bits(struct axp_regmap *map, s32 reg, u8 bit_mask)
+{
+	u8 reg_val;
+	s32 ret = 0;
+
+	mutex_lock(&map->lock);
+	ret = _axp_read(map, reg, &reg_val, false);
+
+	if (ret)
+		goto out;
+
+	if (reg_val & bit_mask) {
+		reg_val &= ~bit_mask;
+		ret = _axp_write(map, reg, reg_val, false);
+	}
+
+out:
+	mutex_unlock(&map->lock);
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(axp_regmap_clr_bits);
+
+s32 axp_regmap_update(struct axp_regmap *map, s32 reg, u8 val, u8 mask)
+{
+	u8 reg_val;
+	s32 ret = 0;
+
+	mutex_lock(&map->lock);
+	ret = _axp_read(map, reg, &reg_val, false);
+	if (ret)
+		goto out;
+
+	if ((reg_val & mask) != val) {
+		reg_val = (reg_val & ~mask) | val;
+		ret = _axp_write(map, reg, reg_val, false);
+	}
+
+out:
+	mutex_unlock(&map->lock);
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(axp_regmap_update);
+
+
+s32 axp_regmap_set_bits_sync(struct axp_regmap *map, s32 reg, u8 bit_mask)
+{
+	u8 reg_val;
+	s32 ret = 0;
+#ifndef CONFIG_AXP_TWI_USED
+	unsigned long irqflags;
+
+	spin_lock_irqsave(&map->spinlock, irqflags);
+#else
+	mutex_lock(&map->lock);
+#endif
+
+	ret = _axp_read(map, reg, &reg_val, true);
+	if (ret)
+		goto out;
+
+	if ((reg_val & bit_mask) != bit_mask) {
+		reg_val |= bit_mask;
+		ret = _axp_write(map, reg, reg_val, true);
+	}
+
+out:
+#ifndef CONFIG_AXP_TWI_USED
+	spin_unlock_irqrestore(&map->spinlock, irqflags);
+#else
+	mutex_unlock(&map->lock);
+#endif
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(axp_regmap_set_bits_sync);
+
+s32 axp_regmap_clr_bits_sync(struct axp_regmap *map, s32 reg, u8 bit_mask)
+{
+	u8 reg_val;
+	s32 ret = 0;
+#ifndef CONFIG_AXP_TWI_USED
+	unsigned long irqflags;
+
+	spin_lock_irqsave(&map->spinlock, irqflags);
+#else
+	mutex_lock(&map->lock);
+#endif
+
+	ret = _axp_read(map, reg, &reg_val, true);
+	if (ret)
+		goto out;
+
+	if (reg_val & bit_mask) {
+		reg_val &= ~bit_mask;
+		ret = _axp_write(map, reg, reg_val, true);
+	}
+
+out:
+#ifndef CONFIG_AXP_TWI_USED
+	spin_unlock_irqrestore(&map->spinlock, irqflags);
+#else
+	mutex_unlock(&map->lock);
+#endif
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(axp_regmap_clr_bits_sync);
+
+s32 axp_regmap_update_sync(struct axp_regmap *map, s32 reg, u8 val, u8 mask)
+{
+	u8 reg_val;
+	s32 ret = 0;
+#ifndef CONFIG_AXP_TWI_USED
+	unsigned long irqflags;
+
+	spin_lock_irqsave(&map->spinlock, irqflags);
+#else
+	mutex_lock(&map->lock);
+#endif
+
+	ret = _axp_read(map, reg, &reg_val, true);
+	if (ret)
+		goto out;
+
+	if ((reg_val & mask) != val) {
+		reg_val = (reg_val & ~mask) | val;
+		ret = _axp_write(map, reg, reg_val, true);
+	}
+
+out:
+#ifndef CONFIG_AXP_TWI_USED
+	spin_unlock_irqrestore(&map->spinlock, irqflags);
+#else
+	mutex_unlock(&map->lock);
+#endif
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(axp_regmap_update_sync);
+
+struct axp_regmap *axp_regmap_init_i2c(struct device *dev)
+{
+	struct axp_regmap *map = NULL;
+
+	map = devm_kzalloc(dev, sizeof(*map), GFP_KERNEL);
+	if (IS_ERR_OR_NULL(map)) {
+		pr_err("%s: not enough memory!\n", __func__);
+		return NULL;
+	}
+
+	map->type = AXP_REGMAP_I2C;
+	map->client = to_i2c_client(dev);
+	mutex_init(&map->lock);
+
+	return map;
+}
+EXPORT_SYMBOL_GPL(axp_regmap_init_i2c);
+
+static void __do_irq(int pmu_num, struct axp_irq_chip_data *irq_data)
+{
+	u64 irqs = 0;
+	u8 reg_val[8];
+	u32 i, j;
+	void *idata;
+
+	if (irq_data == NULL)
+		return;
+
+	axp_regmap_reads(irq_data->map, irq_data->chip->status_base,
+			irq_data->chip->num_regs, reg_val);
+
+	for (i = 0; i < irq_data->chip->num_regs; i++)
+		irqs |= (u64)reg_val[i] << (i * AXP_REG_WIDTH);
+
+	irqs &= irq_data->irqs_enabled;
+	if (irqs == 0)
+		return;
+
+	AXP_DEBUG(AXP_INT, pmu_num, "irqs enabled = 0x%llx\n",
+				irq_data->irqs_enabled);
+	AXP_DEBUG(AXP_INT, pmu_num, "irqs = 0x%llx\n", irqs);
+
+	for_each_set_bit(j, (unsigned long *)&irqs, irq_data->num_irqs) {
+		if (irq_data->irqs[j].handler) {
+			idata = irq_data->irqs[j].data;
+			irq_data->irqs[j].handler(j, idata);
+		}
+	}
+
+	for (i = 0; i < irq_data->chip->num_regs; i++) {
+		if (reg_val[i] != 0) {
+			axp_regmap_write(irq_data->map,
+				irq_data->chip->status_base + i, reg_val[i]);
+			udelay(30);
+		}
+	}
+}
+
+static void axp_irq_work_func(struct work_struct *work)
+{
+	struct axp_dev *adev;
+
+	list_for_each_entry(adev, &axp_dev_list, list) {
+		__do_irq(adev->pmu_num, adev->irq_data);
+	}
+
+
+	//sunxi_nmi_clear_status();
+	//sunxi_nmi_enable();
+}
+
+static irqreturn_t axp_irq(int irq, void *data)
+{
+	struct axp_dev *adev;
+
+	//sunxi_nmi_disable();
+	if (axp_suspend_flag == AXP_NOT_SUSPEND) {
+		schedule_work(&axp_irq_work);
+	} else if (axp_suspend_flag == AXP_WAS_SUSPEND) {
+		list_for_each_entry(adev, &axp_dev_list, list) {
+			if (adev->irq_data->wakeup_event) {
+				adev->irq_data->wakeup_event();
+				axp_suspend_flag = AXP_SUSPEND_WITH_IRQ;
+			}
+		}
+	}
+
+	return IRQ_HANDLED;
+}
+
+struct axp_irq_chip_data *axp_irq_chip_register(struct axp_regmap *map,
+			int irq_no, int irq_flags,
+			struct axp_regmap_irq_chip *irq_chip,
+			void (*wakeup_event)(void))
+{
+	struct axp_irq_chip_data *irq_data = NULL;
+	struct axp_regmap_irq *irqs = NULL;
+	int i, err = 0;
+	printk("==%s==line:%d==file:%s==\n",__func__,__LINE__,__FILE__);
+	irq_data = kzalloc(sizeof(*irq_data), GFP_KERNEL);
+	if (IS_ERR_OR_NULL(irq_data)) {
+		pr_err("axp irq data: not enough memory for irq data\n");
+		return NULL;
+	}
+	printk("[axp]pointer to irq_data=%p in line:%d of %s\n",irq_data,__LINE__,__func__);
+	irq_data->map = map;
+	irq_data->chip = irq_chip;
+	irq_data->num_irqs = AXP_REG_WIDTH * irq_chip->num_regs;
+	printk("[axp]irq_data->map->client->name is %s\n",irq_data->map->client->name);
+    printk("[axp]irq_data->chip->name is %s\n",irq_data->chip->name);
+    printk("[axp]irq_data->num_irqs is %d\n",irq_data->num_irqs);
+
+
+	//irqs = kzalloc(irq_chip->num_regs * AXP_REG_WIDTH * sizeof(*irqs),
+	//			GFP_KERNEL);
+    irqs = kzalloc(irq_chip->num_regs * AXP_REG_WIDTH * sizeof(*irqs),
+                GFP_KERNEL);
+	printk("[axp]pointer to irqs=%p in line:%d of %s\n",irqs,__LINE__,__func__);
+	if (IS_ERR_OR_NULL(irqs)) {
+		pr_err("axp irq data: not enough memory for irq disc\n");
+		goto free_irq_data;
+	}
+    printk("==%s==line:%d==file:%s==\n",__func__,__LINE__,__FILE__);
+
+	mutex_init(&irq_data->lock);
+	irq_data->irqs = irqs;
+	irq_data->irqs_enabled = 0;
+	irq_data->wakeup_event = wakeup_event;
+
+	/* disable all irq and clear all irq pending */
+	for (i = 0; i < irq_chip->num_regs; i++) {
+		axp_regmap_clr_bits(map, irq_chip->enable_base + i, 0xff);
+		axp_regmap_set_bits(map, irq_chip->status_base + i, 0xff);
+	}
+	printk("==%s==line:%d==file:%s==\n",__func__,__LINE__,__FILE__);
+#ifdef CONFIG_DUAL_AXP_USED
+	if (axp_dev_register_count == 1) {
+		err = request_irq(irq_no, axp_irq, irq_flags, "axp", irq_data);
+		goto irq_out;
+	} else if (axp_dev_register_count == 2) {
+		return irq_data;
+	}
+#else
+	err = request_irq(irq_no, axp_irq, irq_flags, irq_chip->name, irq_data);
+#endif
+
+#ifdef CONFIG_DUAL_AXP_USED
+irq_out:
+#endif
+	if (err)
+		goto free_irqs;
+
+	INIT_WORK(&axp_irq_work, axp_irq_work_func);
+#if 0
+	sunxi_nmi_set_trigger(IRQF_TRIGGER_LOW);
+	sunxi_nmi_clear_status();
+	sunxi_nmi_enable();
+#endif
+	return irq_data;
+
+free_irqs:
+pr_err("request_irq for axp2585 fail\n");
+
+	kfree(irqs);
+free_irq_data:
+	kfree(irq_data);
+
+	return NULL;
+}
+EXPORT_SYMBOL_GPL(axp_irq_chip_register);
+
+void axp_irq_chip_unregister(int irq, struct axp_irq_chip_data *irq_data)
+{
+	int i;
+	struct axp_regmap *map = irq_data->map;
+
+	free_irq(irq, irq_data);
+
+	/* disable all irq and clear all irq pending */
+	for (i = 0; i < irq_data->chip->num_regs; i++) {
+		axp_regmap_clr_bits(map,
+				irq_data->chip->enable_base + i, 0xff);
+		axp_regmap_write(map,
+				irq_data->chip->status_base + i, 0xff);
+	}
+
+	kfree(irq_data->irqs);
+	kfree(irq_data);
+
+	//sunxi_nmi_disable();
+}
+EXPORT_SYMBOL_GPL(axp_irq_chip_unregister);
+
+int axp_request_irq(struct axp_dev *adev, int irq_no,
+				irq_handler_t handler, void *data)
+{
+
+    struct axp_irq_chip_data *irq_data = adev->irq_data;
+	struct axp_regmap_irq *irqs = irq_data->irqs;
+
+	int reg, ret;
+	u8 mask;
+    	if (!irq_data || irq_no < 0 || irq_no >= irq_data->num_irqs || !handler)
+		return -1;
+	mutex_lock(&irq_data->lock);
+
+    irqs[irq_no].handler = handler;
+    irqs[irq_no].data = data;
+
+  	irq_data->irqs_enabled |= ((u64)0x1 << irq_no);
+    printk("==%s==line:%d==%s\n",__func__,__LINE__,__FILE__);
+	reg = irq_no / AXP_REG_WIDTH;
+	reg += irq_data->chip->enable_base;
+	mask = 1 << (irq_no % AXP_REG_WIDTH);
+	ret = axp_regmap_set_bits(adev->regmap, reg, mask);
+	mutex_unlock(&irq_data->lock);
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(axp_request_irq);
+
+int axp_enable_irq(struct axp_dev *adev, int irq_no)
+{
+	struct axp_irq_chip_data *irq_data = adev->irq_data;
+	int reg, ret = 0;
+	u8 mask;
+
+	if (!irq_data || irq_no < 0 || irq_no >= irq_data->num_irqs)
+		return -1;
+
+	if (irq_data->irqs[irq_no].handler) {
+		mutex_lock(&irq_data->lock);
+		reg = irq_no / AXP_REG_WIDTH;
+		reg += irq_data->chip->enable_base;
+		mask = 1 << (irq_no % AXP_REG_WIDTH);
+		ret = axp_regmap_set_bits(adev->regmap, reg, mask);
+		mutex_unlock(&irq_data->lock);
+	}
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(axp_enable_irq);
+
+int axp_disable_irq(struct axp_dev *adev, int irq_no)
+{
+	struct axp_irq_chip_data *irq_data = adev->irq_data;
+	int reg, ret = 0;
+	u8 mask;
+
+	if (!irq_data || irq_no < 0 || irq_no >= irq_data->num_irqs)
+		return -1;
+
+	mutex_lock(&irq_data->lock);
+	reg = irq_no / AXP_REG_WIDTH;
+	reg += irq_data->chip->enable_base;
+	mask = 1 << (irq_no % AXP_REG_WIDTH);
+	ret = axp_regmap_clr_bits(adev->regmap, reg, mask);
+	mutex_unlock(&irq_data->lock);
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(axp_disable_irq);
+
+int axp_free_irq(struct axp_dev *adev, int irq_no)
+{
+	struct axp_irq_chip_data *irq_data = adev->irq_data;
+	int reg;
+	u8 mask;
+
+	if (!irq_data || irq_no < 0 || irq_no >= irq_data->num_irqs)
+		return -1;
+
+	mutex_lock(&irq_data->lock);
+	if (irq_data->irqs[irq_no].handler) {
+		reg = irq_no / AXP_REG_WIDTH;
+		reg += irq_data->chip->enable_base;
+		mask = 1 << (irq_no % AXP_REG_WIDTH);
+		axp_regmap_clr_bits(adev->regmap, reg, mask);
+		irq_data->irqs[irq_no].data = NULL;
+		irq_data->irqs[irq_no].handler = NULL;
+	}
+	mutex_unlock(&irq_data->lock);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(axp_free_irq);
+
+int axp_gpio_irq_register(struct axp_dev *adev, int irq_no,
+				irq_handler_t handler, void *data)
+{
+	struct axp_irq_chip_data *irq_data = adev->irq_data;
+	struct axp_regmap_irq *irqs = irq_data->irqs;
+
+	if (!irq_data || irq_no < 0 || irq_no >= irq_data->num_irqs || !handler)
+		return -1;
+
+	mutex_lock(&irq_data->lock);
+	irq_data->irqs_enabled |= ((u64)0x1 << irq_no);
+	irqs[irq_no].handler = handler;
+	irqs[irq_no].data = data;
+	mutex_unlock(&irq_data->lock);
+
+	return 0;
+}
+
+int axp_mfd_add_devices(struct axp_dev *axp_dev)
+{
+	int ret;
+	unsigned long irqflags;
+	  printk("==%s==line:%d==file:%s==\n",__func__,__LINE__,__FILE__);
+
+	ret = mfd_add_devices(axp_dev->dev, -1,
+		axp_dev->cells, axp_dev->nr_cells, NULL, 0, NULL);
+	if (ret)
+		goto fail;
+    printk("==%s==line:%d==file:%s==\n",__func__,__LINE__,__FILE__);
+
+	dev_set_drvdata(axp_dev->dev, axp_dev);
+    printk("==%s==line:%d==file:%s==\n",__func__,__LINE__,__FILE__);
+
+	spin_lock_irqsave(&axp_list_lock, irqflags);
+	list_add(&axp_dev->list, &axp_dev_list);
+	axp_dev_register_count++;
+	spin_unlock_irqrestore(&axp_list_lock, irqflags);
+	  printk("==%s==line:%d==file:%s==\n",__func__,__LINE__,__FILE__);
+
+	return 0;
+
+fail:
+	return ret;
+}
+EXPORT_SYMBOL_GPL(axp_mfd_add_devices);
+
+int axp_mfd_remove_devices(struct axp_dev *axp_dev)
+{
+	mfd_remove_devices(axp_dev->dev);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(axp_mfd_remove_devices);
+
+int axp_dt_parse(struct device_node *node, int pmu_num,
+			struct axp_config_info *axp_config)
+{
+	if (!of_device_is_available(node)) {
+		pr_err("%s: failed\n", __func__);
+		return -1;
+	}
+
+	if (of_property_read_u32(node, "pmu_id", &axp_config->pmu_id)) {
+		pr_err("%s: get pmu_id failed\n", __func__);
+		return -1;
+	}
+
+	if (of_property_read_string(node, "compatible", &axp_name[pmu_num])) {
+		pr_err("%s: get pmu name failed\n", __func__);
+		return -1;
+	}
+
+	if (of_property_read_u32(node, "pmu_vbusen_func",
+		&axp_config->pmu_vbusen_func))
+		axp_config->pmu_vbusen_func = 1;
+
+	if (of_property_read_u32(node, "pmu_reset",
+		&axp_config->pmu_reset))
+		axp_config->pmu_reset = 0;
+
+	if (of_property_read_u32(node, "pmu_irq_wakeup",
+			&axp_config->pmu_irq_wakeup))
+		axp_config->pmu_irq_wakeup = 0;
+
+	if (of_property_read_u32(node, "pmu_hot_shutdown",
+		&axp_config->pmu_hot_shutdown))
+		axp_config->pmu_hot_shutdown = 1;
+
+	if (of_property_read_u32(node, "pmu_inshort",
+		&axp_config->pmu_inshort))
+		axp_config->pmu_inshort = 0;
+
+	if (of_property_read_u32(node, "pmu_reset_shutdown_en",
+		&axp_config->pmu_reset_shutdown_en))
+		axp_config->pmu_reset_shutdown_en = 0;
+
+	if (of_property_read_u32(node, "pmu_as_slave",
+		&axp_config->pmu_as_slave))
+		axp_config->pmu_as_slave = 0;
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(axp_dt_parse);
+#if 0
+unsigned int axp_get_sys_pwr_dm_mask(void)
+{
+	unsigned long irqflags;
+	u32 ret = 0;
+
+	spin_lock_irqsave(&axp_pwr_data_lock, irqflags);
+	ret = axp_sys_pwr_dm_mask;
+	spin_unlock_irqrestore(&axp_pwr_data_lock, irqflags);
+
+	return ret;
+}
+
+void axp_set_sys_pwr_dm_mask(u32 bitmap, u32 enable)
+{
+	unsigned long irqflags;
+
+	spin_lock_irqsave(&axp_pwr_data_lock, irqflags);
+	if (enable)
+		axp_sys_pwr_dm_mask |= (0x1 << bitmap);
+	else
+		axp_sys_pwr_dm_mask &= ~(0x1 << bitmap);
+	spin_unlock_irqrestore(&axp_pwr_data_lock, irqflags);
+
+	pr_debug("%s: sys_pwr_dm_mask = 0x%x\n", __func__, axp_sys_pwr_dm_mask);
+}
+
+void axp_set_pwr_regu_tree(u32 value, u32 bitmap)
+{
+	unsigned long irqflags;
+
+	spin_lock_irqsave(&axp_pwr_data_lock, irqflags);
+	axp_power_tree[bitmap] = value;
+	spin_unlock_irqrestore(&axp_pwr_data_lock, irqflags);
+
+	pr_debug("%s: axp_power_tree[%d] = 0x%x\n", __func__, bitmap, value);
+}
+
+void axp_get_pwr_regu_tree(unsigned int *p)
+{
+	memcpy((void *)p, (void *)axp_power_tree, sizeof(axp_power_tree));
+}
+EXPORT_SYMBOL_GPL(axp_get_pwr_regu_tree);
+
+s32 axp_check_sys_id(const char *supply_id)
+{
+	s32 i = 0;
+
+	for (i = 0; i < VCC_MAX_INDEX; i++) {
+		if (strcmp(pwr_dm_bitmap_name_mapping[i].id_name, supply_id)
+				== 0)
+			return i;
+	}
+
+	return -1;
+}
+
+char *axp_get_sys_id(u32 bitmap)
+{
+	if ((bitmap < 0) || (bitmap >= VCC_MAX_INDEX))
+		return NULL;
+
+	return (char *)&(pwr_dm_bitmap_name_mapping[bitmap].id_name);
+}
+
+s32 axp_get_ldo_dependence(const char *ldo_name, s32 index,
+				s32 (*get_dep_cb)(const char *))
+{
+	s32 ret;
+
+	ret = (*get_dep_cb)(ldo_name);
+	if (ret < 0) {
+		pr_err("%s: get regu dependence failed\n", __func__);
+		return -1;
+	} else {
+		axp_set_pwr_regu_tree(ret, index);
+	}
+
+	return 0;
+}
+
+/*
+ * function:  get sys_pwr_dm_id name.
+ * input: sys_pwr_domain bitmap.
+ * return:
+ * failed:  NULL.
+ * success: sys_pwr_dm_id.
+ */
+char *axp_get_sys_pwr_dm_id(u32 bitmap)
+{
+	return axp_get_sys_id(bitmap);
+}
+
+/*
+ * function: judge whether pwr_dm is part of sys_pwr_domain.
+ * input: pwr_dm name, such as: "vdd_sys".
+ * return:
+ * nonnegative number: the sys_pwr_domain bitmap.
+ * -1: the input pwr_dm is not belong to sys_pwr_domain.
+ */
+int axp_is_sys_pwr_dm_id(const char *id)
+{
+	s32 sys_id_conut = 0;
+
+	sys_id_conut = axp_check_sys_id(id);
+	if (sys_id_conut >= 0)
+		return sys_id_conut;
+	else
+		return -1;
+}
+
+/*
+ * function: judge whether sys_pwr_domain is active.
+ * input: sys_pwr_domain bitmap.
+ * return:
+ * 1: the input sys_pwr_domain is active.
+ * 0: the input sys_pwr_domain is not active.
+ */
+int axp_is_sys_pwr_dm_active(u32 bitmap)
+{
+	u32 sys_pwr_mask = 0;
+
+	sys_pwr_mask = axp_get_sys_pwr_dm_mask();
+	if (sys_pwr_mask & (0x1 << bitmap))
+		return 1;
+	else
+		return 0;
+}
+
+/*
+ * function: add the pwr_dm specified by input id to sys_pwr_dm;
+ */
+int axp_add_sys_pwr_dm(const char *id)
+{
+	s32 ret = 0, sys_id_conut = 0;
+	char ldo_name[20] = {0};
+	u32 sys_pwr_mask = 0;
+
+	sys_id_conut = axp_check_sys_id(id);
+	if (sys_id_conut < 0) {
+		pr_err("%s: %s not sys id.\n", __func__, id);
+		return -1;
+	} else {
+		sys_pwr_mask = axp_get_sys_pwr_dm_mask();
+		if (sys_pwr_mask & (0x1 << sys_id_conut)) {
+			pr_info("%s: sys_pwr_mask=0x%x, sys_mask already set\n",
+				__func__, sys_pwr_mask);
+			return 1;
+		}
+	}
+
+	ret = axp_get_ldo_name(id, (char *)&ldo_name);
+	if (ret < 0) {
+		pr_err("%s: get ldo name for id: %s failed\n", __func__, id);
+		return -1;
+	}
+
+	ret = axp_check_ldo_alwayson((const char *)&ldo_name);
+	if (ret == 0) {
+		if (axp_set_ldo_alwayson((const char *)&ldo_name, 1)) {
+			pr_err("%s: %s axp_set_ldo_alwayson failed\n",
+				__func__, ldo_name);
+			return -1;
+		}
+	} else if (ret == 1) {
+		pr_err("%s: %s ldo already alwayson\n", __func__, ldo_name);
+	} else {
+		pr_err("%s: %s set err.\n", __func__, ldo_name);
+		return -1;
+	}
+
+	axp_set_sys_pwr_dm_mask(sys_id_conut, 1);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(axp_add_sys_pwr_dm);
+
+int axp_del_sys_pwr_dm(const char *id)
+{
+	s32 ret = 0, sys_id_conut = 0, i = 0;
+	char ldo_name[20] = {0};
+	char sys_ldo_name[20] = {0};
+	u32 sys_pwr_mask = 0;
+	char *sys_id;
+
+	sys_id_conut = axp_check_sys_id(id);
+	if (sys_id_conut < 0) {
+		pr_err("%s: %s not sys id\n", __func__, id);
+		return -1;
+	} else {
+		sys_pwr_mask = axp_get_sys_pwr_dm_mask();
+		if (!(sys_pwr_mask & (0x1 << sys_id_conut)))
+			return 1;
+	}
+
+	ret = axp_get_ldo_name(id, (char *)&ldo_name);
+	if (ret < 0) {
+		pr_err("%s: get ldo name for id: %s failed\n", __func__, id);
+		return -1;
+	}
+
+	ret = axp_check_ldo_alwayson((const char *)&ldo_name);
+	if (ret == 0) {
+		pr_err("%s: %s ldo is already not alwayson\n",
+				__func__, ldo_name);
+	} else if (ret == 1) {
+		for (i = 0; i < VCC_MAX_INDEX; i++) {
+			if (sys_id_conut == i)
+				continue;
+			if (axp_is_sys_pwr_dm_active(i)) {
+				sys_id = axp_get_sys_pwr_dm_id(i);
+				ret = axp_get_ldo_name(sys_id,
+						(char *)&sys_ldo_name);
+				if (ret < 0) {
+					pr_err("%s: get sys_ldo_name failed\n",
+							__func__);
+					return -1;
+				}
+
+				if (strcmp(sys_ldo_name, ldo_name) == 0) {
+					axp_set_sys_pwr_dm_mask(sys_id_conut,
+							0);
+					return 0;
+				}
+			}
+		}
+
+		if (axp_set_ldo_alwayson((const char *)&ldo_name, 0)) {
+			pr_err("%s: %s axp_set_ldo_alwayson failed\n",
+				__func__, ldo_name);
+			return -1;
+		}
+	} else {
+		pr_err("%s: %s set err\n", __func__, ldo_name);
+		return -1;
+	}
+
+	axp_set_sys_pwr_dm_mask(sys_id_conut, 0);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(axp_del_sys_pwr_dm);
+
+int init_sys_pwr_dm(void)
+{
+	axp_add_sys_pwr_dm("vdd-cpua");
+	/*axp_add_sys_pwr_dm("vdd-cpub"); */
+	axp_add_sys_pwr_dm("vcc-dram");
+	/*axp_add_sys_pwr_dm("vdd-gpu"); */
+	axp_add_sys_pwr_dm("vdd-sys");
+	/*axp_add_sys_pwr_dm("vdd-vpu"); */
+	axp_add_sys_pwr_dm("vdd-cpus");
+	/*axp_add_sys_pwr_dm("vdd-drampll"); */
+	axp_add_sys_pwr_dm("vcc-lpddr");
+	/*axp_add_sys_pwr_dm("vcc-adc"); */
+	axp_add_sys_pwr_dm("vcc-pl");
+	/*axp_add_sys_pwr_dm("vcc-pm"); */
+	axp_add_sys_pwr_dm("vcc-io");
+	/*axp_add_sys_pwr_dm("vcc-cpvdd"); */
+	/*axp_add_sys_pwr_dm("vcc-ldoin"); */
+	axp_add_sys_pwr_dm("vcc-pll");
+	axp_add_sys_pwr_dm("vcc-pc");
+
+	return 0;
+}
+
+EXPORT_SYMBOL_GPL(init_sys_pwr_dm);
+#endif
+MODULE_DESCRIPTION("ALLWINNERTECH axp core");
+MODULE_AUTHOR("pannan");
+MODULE_LICENSE("GPL");

--- a/drivers/power/supply/axp/axp-core.h	1969-12-31 19:00:00.000000000 -0500
+++ b/drivers/power/supply/axp/axp-core.h	2022-09-01 10:46:35.786464423 -0400
@@ -0,0 +1,180 @@
+/*
+ * drivers/power/axp/axp-core.h
+ * (C) Copyright 2010-2016
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * Pannan <pannan@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ */
+
+#ifndef AXP_CORE_H_
+#define AXP_CORE_H_
+#include <linux/interrupt.h>
+//#include "aw_pm.h"
+
+#include <linux/regulator/consumer.h>
+#include <linux/module.h>
+#include <linux/ctype.h>
+#include "axp-charger.h"
+#include "axp_depend.h"
+
+#define AXP_REG_WIDTH     (8)
+#define AXP_ADD_WIDTH     (8)
+#define ABS(x)		((x) > 0 ? (x) : -(x))
+#ifdef CONFIG_DUAL_AXP_USED
+#define AXP_ONLINE_SUM    (2)
+#else
+#define AXP_ONLINE_SUM    (1)
+#endif
+
+enum AXP_REGMAP_TYPE {
+	AXP_REGMAP_I2C,
+	AXP_REGMAP_ARISC_RSB,
+	AXP_REGMAP_ARISC_TWI,
+};
+
+struct axp_regmap {
+	enum AXP_REGMAP_TYPE type;
+	struct i2c_client    *client;
+	struct mutex         lock;
+#ifndef CONFIG_AXP_TWI_USED
+	spinlock_t           spinlock;
+#endif
+	u8                   rsbaddr;
+};
+
+struct axp_regmap_irq {
+	irq_handler_t handler;
+	void *data;
+};
+
+struct axp_regmap_irq_chip {
+	const char *name;
+	unsigned int status_base;
+	unsigned int enable_base;
+	int num_regs;
+};
+
+struct axp_irq_chip_data {
+	struct mutex lock;
+	struct axp_regmap *map;
+	struct axp_regmap_irq_chip *chip;
+	struct axp_regmap_irq *irqs;
+	int num_irqs;
+    u64 irqs_enabled;
+	void (*wakeup_event)(void);
+};
+
+struct axp_dev {
+	struct device            *dev;
+	struct axp_regmap        *regmap;
+	int                      nr_cells;
+	struct mfd_cell          *cells;
+	struct axp_irq_chip_data *irq_data;
+	int                      irq;
+	bool                     is_dummy;
+	bool                     is_slave;
+	struct list_head         list;
+	int                      pmu_num;
+};
+
+struct axp_platform_ops {
+	s32 (*usb_det)(void);
+	s32 (*usb_vbus_output)(int);
+	//int (*cfg_pmux_para)(int, struct aw_pm_info *, int *);
+	const char * (*get_pmu_name)(void);
+	struct axp_dev * (*get_pmu_dev)(void);
+	int (*pmu_regulator_save)(void);
+	void (*pmu_regulator_restore)(void);
+};
+
+struct axp_interrupts {
+	char *name;
+	irq_handler_t isr;
+};
+
+struct axp_mfd_name_set {
+	char powerkey_name[32];
+	char charger_name[32];
+	char regulator_name[32];
+	char gpio_name[32];
+};
+
+struct axp_compatible_name_mapping {
+	char device_name[32];
+	struct axp_mfd_name_set mfd_name;
+};
+
+#define AXP_DUMP_ATTR(_name)				\
+{							\
+	.attr = { .name = #_name, .mode = 0644 },	\
+	.show =  _name##_show,				\
+	.store = _name##_store,				\
+}
+
+enum {
+	AXP_SPLY = 1U << 0,
+	AXP_REGU = 1U << 1,
+	AXP_INT  = 1U << 2,
+	AXP_CHG  = 1U << 3,
+	AXP_MISC = 1U << 4,
+};
+
+enum {
+	AXP_NOT_SUSPEND = 1U << 0,
+	AXP_WAS_SUSPEND = 1U << 1,
+	AXP_SUSPEND_WITH_IRQ = 1U << 2,
+};
+
+#define AXP_DEBUG(level_mask, pmu_num, fmt, arg...)   \
+	{ if (unlikely(axp_debug_mask & level_mask)) {     \
+		printk("[%s] ", get_pmu_cur_name(pmu_num));  \
+		printk(fmt, ##arg);                   \
+	 }                                            \
+	}
+
+struct axp_regmap *axp_regmap_init_i2c(struct device *dev);
+struct axp_irq_chip_data *axp_irq_chip_register(struct axp_regmap *map,
+	int irq, int irq_flags, struct axp_regmap_irq_chip *irq_chip,
+	void (*wakeup_event)(void));
+void axp_irq_chip_unregister(int irq, struct axp_irq_chip_data *irq_data);
+
+int axp_regmap_write(struct axp_regmap *map, s32 reg, u8 val);
+int axp_regmap_writes(struct axp_regmap *map, s32 reg, s32 len, u8 *val);
+int axp_regmap_read(struct axp_regmap *map, s32 reg, u8 *val);
+int axp_regmap_reads(struct axp_regmap *map, s32 reg, s32 len, u8 *val);
+int axp_regmap_update(struct axp_regmap *map, s32 reg, u8 val, u8 mask);
+int axp_regmap_set_bits(struct axp_regmap *map, s32 reg, u8 bit_mask);
+int axp_regmap_clr_bits(struct axp_regmap *map, s32 reg, u8 bit_mask);
+int axp_regmap_update_sync(struct axp_regmap *map, s32 reg, u8 val, u8 mask);
+int axp_regmap_set_bits_sync(struct axp_regmap *map, s32 reg, u8 bit_mask);
+int axp_regmap_clr_bits_sync(struct axp_regmap *map, s32 reg, u8 bit_mask);
+int axp_mfd_add_devices(struct axp_dev *axp_dev);
+int axp_mfd_remove_devices(struct axp_dev *axp_dev);
+int axp_request_irq(struct axp_dev *adev, int irq_no,
+				irq_handler_t handler, void *data);
+int axp_free_irq(struct axp_dev *adev, int irq_no);
+int axp_dt_parse(struct device_node *node, int pmu_num,
+				struct axp_config_info *axp_config);
+void axp_platform_ops_set(int pmu_num, struct axp_platform_ops *ops);
+void axp_dev_set(struct axp_dev *axpdev);
+int axp_gpio_irq_register(struct axp_dev *adev, int irq_no,
+				irq_handler_t handler, void *data);
+struct axp_dev *get_pmu_cur_dev(int pmu_num);
+int axp_mfd_cell_name_init(const struct axp_compatible_name_mapping *mapping,
+				int count,  int pmu_num,
+				int size, struct mfd_cell *cells);
+int axp_get_pmu_num(const struct axp_compatible_name_mapping *mapping,
+				int size);
+
+extern int axp_suspend_flag;
+extern int axp_debug_mask;
+extern int axp_usb_connect;
+extern const char *axp_name[AXP_ONLINE_SUM];
+extern const char *get_pmu_cur_name(int pmu_num);
+
+#endif /* AXP_CORE_H_ */

--- a/drivers/power/supply/axp/axp_depend.h	1969-12-31 19:00:00.000000000 -0500
+++ b/drivers/power/supply/axp/axp_depend.h	2022-09-01 10:46:35.786464423 -0400
@@ -0,0 +1,304 @@
+/*
+ * include/linux/power/axp_depend.h
+ * (C) Copyright 2010-2016
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * Liming <liming@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ */
+
+#ifndef __AXP_DEPEND_H__
+#define __AXP_DEPEND_H__
+
+#include <linux/types.h>
+
+enum AW_POWER_ID {
+	AXP_19X_ID = 0,
+	AXP_209_ID,
+	AXP_22X_ID,
+	AXP_806_ID,
+	AXP_808_ID,
+	AXP_809_ID,
+	AXP_803_ID,
+	AXP_813_ID,
+	AXP_152_ID,
+	AXP_259_ID,
+	AXP_DUMMY0_ID = 0x1 << 7,
+};
+
+enum AXP19X_POWER_LDO {
+	AXP19X_DCDC1_BIT = 1U << 0,
+	AXP19X_DCDC2_BIT = 1U << 1,
+	AXP19X_DCDC3_BIT = 1U << 2,
+	AXP19X_LDO1_BIT  = 1U << 3,
+	AXP19X_LDO2_BIT  = 1U << 4,
+	AXP19X_LDO3_BIT  = 1U << 5,
+	AXP19X_LDO4_BIT  = 1U << 6,
+};
+
+enum AXP15X_POWER_LDO {
+	AXP15X_DCDC1_BIT  = 1U << 0,
+	AXP15X_DCDC2_BIT  = 1U << 1,
+	AXP15X_DCDC3_BIT  = 1U << 2,
+	AXP15X_DCDC4_BIT  = 1U << 3,
+	AXP15X_LDO0_BIT   = 1U << 4,
+	AXP15X_RTC_BIT    = 1U << 5,
+	AXP15X_ALDO1_BIT  = 1U << 6,
+	AXP15X_ALDO2_BIT  = 1U << 7,
+	AXP15X_DLDO1_BIT  = 1U << 8,
+	AXP15X_DLDO2_BIT  = 1U << 9,
+	AXP15X_LDOIO0_BIT = 1U << 10,
+};
+
+enum AXP22X_POWER_LDO {
+	AXP22X_DCDC1_BIT  = 1U << 0,
+	AXP22X_DCDC2_BIT  = 1U << 1,
+	AXP22X_DCDC3_BIT  = 1U << 2,
+	AXP22X_DCDC4_BIT  = 1U << 3,
+	AXP22X_DCDC5_BIT  = 1U << 4,
+	AXP22X_ALDO1_BIT  = 1U << 5,
+	AXP22X_ALDO2_BIT  = 1U << 6,
+	AXP22X_ALDO3_BIT  = 1U << 7,
+	AXP22X_DLDO1_BIT  = 1U << 8,
+	AXP22X_DLDO2_BIT  = 1U << 9,
+	AXP22X_DLDO3_BIT  = 1U << 10,
+	AXP22X_DLDO4_BIT  = 1U << 11,
+	AXP22X_ELDO1_BIT  = 1U << 12,
+	AXP22X_ELDO2_BIT  = 1U << 13,
+	AXP22X_ELDO3_BIT  = 1U << 14,
+	AXP22X_DC5LDO_BIT = 1U << 15,
+	AXP22X_LDOIO0_BIT = 1U << 16,
+	AXP22X_LDOIO1_BIT = 1U << 17,
+	AXP22X_DC1SW_BIT  = 1U << 18,
+	AXP22X_RTC_BIT    = 1U << 19,
+	AXP22X_SW0_BIT    = 1U << 20,
+};
+
+enum AXP806_808_POWER_LDO {
+	AXP806_808_DCDC1_BIT = 1U << 0,
+	AXP806_808_DCDC2_BIT = 1U << 1,
+	AXP806_808_DCDC3_BIT = 1U << 2,
+	AXP806_808_DCDC4_BIT = 1U << 3,
+	AXP806_808_DCDC5_BIT = 1U << 4,
+	AXP806_808_ALDO1_BIT = 1U << 5,
+	AXP806_808_ALDO2_BIT = 1U << 6,
+	AXP806_808_ALDO3_BIT = 1U << 7,
+	AXP806_808_BLDO1_BIT = 1U << 8,
+	AXP806_808_BLDO2_BIT = 1U << 9,
+	AXP806_808_BLDO3_BIT = 1U << 10,
+	AXP806_808_BLDO4_BIT = 1U << 11,
+	AXP806_808_CLDO1_BIT = 1U << 12,
+	AXP806_808_CLDO2_BIT = 1U << 13,
+	AXP806_808_CLDO3_BIT = 1U << 14,
+	AXP806_808_SW0_BIT   = 1U << 15,
+};
+
+typedef enum AXP858_1506_POWER_LDO {
+	AXP858_1506_DCDC1 = 1U << 0,
+	AXP858_1506_DCDC2 = 1U << 1,
+	AXP858_1506_DCDC3 = 1U << 2,
+	AXP858_1506_DCDC4 = 1U << 3,
+	AXP858_1506_DCDC5 = 1U << 4,
+	AXP858_1506_DCDC6 = 1U << 5,
+	AXP858_1506_RTC	  = 1U << 6,
+	AXP858_1506_ALDO1 = 1U << 7,
+	AXP858_1506_ALDO2 = 1U << 8,
+	AXP858_1506_ALDO3 = 1U << 9,
+	AXP858_1506_ALDO4 = 1U << 10,
+	AXP858_1506_ALDO5 = 1U << 11,
+	AXP858_1506_BLDO1 = 1U << 12,
+	AXP858_1506_BLDO2 = 1U << 13,
+	AXP858_1506_BLDO3 = 1U << 14,
+	AXP858_1506_BLDO4 = 1U << 15,
+	AXP858_1506_BLDO5 = 1U << 16,
+	AXP858_1506_CLDO1 = 1U << 17,
+	AXP858_1506_CLDO2 = 1U << 18,
+	AXP858_1506_CLDO3 = 1U << 19,
+	AXP858_1506_CLDO4 = 1U << 20,
+	AXP858_1506_CPUS  = 1U << 21,
+	AXP858_1506_DC1SW  = 1U << 22,
+	AXP858_1506_LDOIO1 = 1U << 23,
+	AXP858_1506_LDOIO2 = 1U << 24,
+} axp858_1506_ldo_e;
+
+enum AXP809_POWER_LDO {
+	AXP809_DCDC1_BIT  = 1U << 0,
+	AXP809_DCDC2_BIT  = 1U << 1,
+	AXP809_DCDC3_BIT  = 1U << 2,
+	AXP809_DCDC4_BIT  = 1U << 3,
+	AXP809_DCDC5_BIT  = 1U << 4,
+	AXP809_ALDO1_BIT  = 1U << 5,
+	AXP809_ALDO2_BIT  = 1U << 6,
+	AXP809_ALDO3_BIT  = 1U << 7,
+	AXP809_DLDO1_BIT  = 1U << 8,
+	AXP809_DLDO2_BIT  = 1U << 9,
+	AXP809_ELDO1_BIT  = 1U << 10,
+	AXP809_ELDO2_BIT  = 1U << 11,
+	AXP809_ELDO3_BIT  = 1U << 12,
+	AXP809_DC5LDO_BIT = 1U << 13,
+	AXP809_LDOIO0_BIT = 1U << 14,
+	AXP809_LDOIO1_BIT = 1U << 15,
+	AXP809_SW0_BIT    = 1U << 16,
+	AXP809_DC1SW_BIT  = 1U << 17,
+	AXP809_RTC_BIT    = 1U << 18,
+};
+
+enum AXP803_813_POWER_LDO {
+	AXP803_813_DCDC1_BIT  = 1U << 0,
+	AXP803_813_DCDC2_BIT  = 1U << 1,
+	AXP803_813_DCDC3_BIT  = 1U << 2,
+	AXP803_813_DCDC4_BIT  = 1U << 3,
+	AXP803_813_DCDC5_BIT  = 1U << 4,
+	AXP803_813_DCDC6_BIT  = 1U << 5,
+	AXP803_813_DCDC7_BIT  = 1U << 6,
+	AXP803_813_ALDO1_BIT  = 1U << 7,
+	AXP803_813_ALDO2_BIT  = 1U << 8,
+	AXP803_813_ALDO3_BIT  = 1U << 9,
+	AXP803_813_DLDO1_BIT  = 1U << 10,
+	AXP803_813_DLDO2_BIT  = 1U << 11,
+	AXP803_813_DLDO3_BIT  = 1U << 12,
+	AXP803_813_DLDO4_BIT  = 1U << 13,
+	AXP803_813_ELDO1_BIT  = 1U << 14,
+	AXP803_813_ELDO2_BIT  = 1U << 15,
+	AXP803_813_ELDO3_BIT  = 1U << 16,
+	AXP803_813_FLDO1_BIT  = 1U << 17,
+	AXP803_813_FLDO2_BIT  = 1U << 18,
+	AXP803_813_LDOIO0_BIT = 1U << 19,
+	AXP803_813_LDOIO1_BIT = 1U << 20,
+	AXP803_813_DC1SW_BIT  = 1U << 21,
+	AXP803_813_RTC_BIT    = 1U << 22,
+};
+
+enum AXP20X_POWER_LDO {
+	AXP20X_DCDC2_BIT  = 1U << 0,
+	AXP20X_DCDC3_BIT  = 1U << 1,
+	AXP20X_LDO2_BIT   = 1U << 2,
+	AXP20X_LDO3_BIT   = 1U << 3,
+	AXP20X_LDO4_BIT   = 1U << 4,
+	AXP20X_LDOIO0_BIT = 1U << 5,
+	AXP20X_RTC_BIT    = 1U << 6,
+};
+
+enum AXPDUMMY_POWER_LDO {
+	AXPDUMMY_LDO1_BIT  = 1U << 0,
+	AXPDUMMY_LDO2_BIT  = 1U << 1,
+	AXPDUMMY_LDO3_BIT  = 1U << 2,
+	AXPDUMMY_LDO4_BIT  = 1U << 3,
+	AXPDUMMY_LDO5_BIT  = 1U << 4,
+	AXPDUMMY_LDO6_BIT  = 1U << 5,
+	AXPDUMMY_LDO7_BIT  = 1U << 6,
+	AXPDUMMY_LDO8_BIT  = 1U << 7,
+	AXPDUMMY_LDO9_BIT  = 1U << 8,
+	AXPDUMMY_LDO10_BIT = 1U << 9,
+	AXPDUMMY_LDO11_BIT = 1U << 10,
+	AXPDUMMY_LDO12_BIT = 1U << 11,
+	AXPDUMMY_LDO13_BIT = 1U << 12,
+	AXPDUMMY_LDO14_BIT = 1U << 13,
+	AXPDUMMY_LDO15_BIT = 1U << 14,
+	AXPDUMMY_LDO16_BIT = 1U << 15,
+	AXPDUMMY_LDO17_BIT = 1U << 16,
+	AXPDUMMY_LDO18_BIT = 1U << 17,
+	AXPDUMMY_LDO19_BIT = 1U << 18,
+	AXPDUMMY_LDO20_BIT = 1U << 19,
+};
+
+/* FIXME: if you modify this struct, you should
+ * sync this change with cpus source,
+ * by superm at 2015-05-15.
+ */
+enum VDD_BIT {
+	VDD_CPUA_BIT = 0,
+	VDD_CPUB_BIT,
+	VCC_DRAM_BIT,
+	VDD_GPU_BIT,
+	VDD_SYS_BIT,
+	VDD_VPU_BIT,
+	VDD_CPUS_BIT,
+	VDD_DRAMPLL_BIT,
+	VCC_ADC_BIT,
+	VCC_PL_BIT,
+	VCC_PM_BIT,
+	VCC_IO_BIT,
+	VCC_CPVDD_BIT,
+	VCC_LDOIN_BIT,
+	VCC_PLL_BIT,
+	VCC_LPDDR_BIT,
+	VDD_TEST_BIT,
+	VDD_RES1_BIT,
+	VDD_RES2_BIT,
+#if (defined(CONFIG_ARCH_SUN8IW10) || defined(CONFIG_ARCH_SUN8IW11))
+	VCC_PC_BIT,
+#else
+	VDD_RES3_BIT,
+#endif
+	VCC_MAX_INDEX,
+};
+
+struct bitmap_name_mapping {
+	unsigned int mask_bit;
+	char id_name[20];
+};
+
+enum AW_CHARGE_TYPE {
+	CHARGE_AC,
+	CHARGE_USB_20,
+	CHARGE_USB_30,
+	CHARGE_MAX
+};
+
+#define AXP_GPIO_IRQF_TRIGGER_RISING	0x00000001
+#define AXP_GPIO_IRQF_TRIGGER_FALLING	0x00000002
+
+/*
+* AXP status:
+* */
+typedef enum AW_AXP_STATUS {
+	AXP_NOTREADY = 0,
+	AXP_READY,
+} aw_axp_status_e;
+
+extern struct raw_notifier_head axp_regu_notifier;
+extern int axp_gpio_irq_request(int pmu_num, int gpio_no,
+				u32 (*handler)(int, void *), void *data);
+extern int axp_gpio_irq_enable(int pmu_num, int gpio_no);
+extern int axp_gpio_irq_disable(int pmu_num, int gpio_no);
+extern int axp_gpio_irq_set_type(int pmu_num, int gpio_no, unsigned long type);
+extern int axp_gpio_irq_free(int pmu_num, int gpio_no);
+
+extern struct bitmap_name_mapping pwr_dm_bitmap_name_mapping[VCC_MAX_INDEX];
+extern int pwr_dm_bitmap_name_mapping_cnt;
+extern int axp_dev_register_count;
+
+/* internal interface*/
+#if 0
+void axp_set_pwr_regu_tree(unsigned int value, unsigned int bitmap);
+signed int axp_check_sys_id(const char *supply_id);
+char *axp_get_sys_id(unsigned int bitmap);
+s32 axp_get_ldo_dependence(const char *ldo_name, signed int count,
+				s32 (*get_dep_cb)(const char *));
+void axp_set_sys_pwr_dm_mask(unsigned int bitmap, unsigned int enable);
+
+/* external interface*/
+extern unsigned int axp_get_sys_pwr_dm_mask(void);
+extern int axp_add_sys_pwr_dm(const char *id);
+extern int axp_del_sys_pwr_dm(const char *id);
+extern int axp_is_sys_pwr_dm_id(const char *id);
+extern int axp_is_sys_pwr_dm_active(unsigned int bitmap);
+extern char *axp_get_sys_pwr_dm_id(unsigned int bitmap);
+extern void axp_get_pwr_regu_tree(unsigned int *p);
+extern ssize_t parse_pwr_dm_map(char *s, size_t size, unsigned int bitmap);
+extern int init_sys_pwr_dm(void);
+#endif
+extern int axp_usbcur(enum AW_CHARGE_TYPE type);
+extern int axp_usbvol(enum AW_CHARGE_TYPE type);
+extern s32 axp_usb_det(void);
+extern s32 axp_usb_vbus_output(int high);
+extern int axp_powerkey_get(void);
+extern void axp_powerkey_set(int value);
+extern int axp_usb_is_connected(void);
+
+#endif /* __AXP_DEPEND_H__ */
+

--- a/drivers/power/supply/axp/axp-gpio.c	1969-12-31 19:00:00.000000000 -0500
+++ b/drivers/power/supply/axp/axp-gpio.c	2022-09-01 10:46:35.786464423 -0400
@@ -0,0 +1,759 @@
+/*
+ * drivers/power/axp/axp-gpio.c
+ * (C) Copyright 2010-2016
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * Pannan <pannan@allwinnertech.com>
+ *
+ * axp gpio APIs
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ */
+
+#include <linux/io.h>
+#include <linux/clk.h>
+#include <linux/gpio.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/of_address.h>
+#include <linux/of_device.h>
+#include <linux/pinctrl/consumer.h>
+#include <linux/pinctrl/machine.h>
+#include <linux/pinctrl/pinctrl.h>
+#include <linux/pinctrl/pinconf-generic.h>
+#include <linux/pinctrl/pinmux.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+#include <linux/mfd/core.h>
+#include <linux/seq_file.h>
+#include <linux/i2c.h>
+#include "../../include/generated/uapi/linux/version.h"
+#include "sunxi-gpio.h"
+#include "../../pinctrl/core.h"
+#include "axp-core.h"
+#include "axp-gpio.h"
+
+#define MODULE_NAME "axp-pinctrl"
+
+static struct axp_pinctrl_group *axp_pinctrl_find_group_by_name(
+		struct axp_pinctrl *pctl, const char *group)
+{
+	int i;
+
+	for (i = 0; i < pctl->ngroups; i++) {
+		struct axp_pinctrl_group *grp = pctl->groups + i;
+
+		if (!strcmp(grp->name, group))
+			return grp;
+	}
+
+	return NULL;
+}
+
+static struct axp_desc_function *axp_pinctrl_desc_find_function_by_name(
+				struct axp_pinctrl *pctl,
+				const char *pin_name,
+				const char *func_name)
+{
+	int i;
+for (i = 0; i < pctl->desc->npins; i++) {
+		const struct axp_desc_pin *pin = pctl->desc->pins + i;
+		if (!strcmp(pin->pin.name, pin_name)) {
+			struct axp_desc_function *func = pin->functions;
+			while (func->name) {
+				if (!strcmp(func->name, func_name))
+					return func;
+				func++;
+			}
+		}
+	}
+
+	return NULL;
+}
+
+static int axp_pinctrl_get_groups_count(struct pinctrl_dev *pctldev)
+{
+	struct axp_pinctrl *pctl = pinctrl_dev_get_drvdata(pctldev);
+
+	return pctl->ngroups;
+}
+
+static const char *axp_pinctrl_get_group_name(struct pinctrl_dev *pctldev,
+					unsigned selector)
+{
+	struct axp_pinctrl *pctl = pinctrl_dev_get_drvdata(pctldev);
+
+	return pctl->groups[selector].name;
+}
+
+static int axp_pinctrl_get_group_pins(struct pinctrl_dev *pctldev,
+					unsigned selector,
+					const unsigned **pins,
+					unsigned *num_pins)
+{
+	struct axp_pinctrl *pctl = pinctrl_dev_get_drvdata(pctldev);
+
+	*pins = (unsigned *)&pctl->groups[selector].pin;
+	*num_pins = 1;
+
+	return 0;
+}
+
+static int axp_pctrl_dt_node_to_map(struct pinctrl_dev *pctldev,
+					struct device_node *node,
+					struct pinctrl_map **map,
+					unsigned *num_maps)
+{
+	struct axp_pinctrl *pctl = pinctrl_dev_get_drvdata(pctldev);
+	unsigned long *pinconfig;
+	struct property *prop;
+	const char *function;
+	const char *group;
+	int ret, nmaps, i = 0;
+	u32 val;
+
+	pr_debug("%s enter...\n", __func__);
+
+	*map = NULL;
+	*num_maps = 0;
+
+	ret = of_property_read_string(node, "allwinner,function", &function);
+	if (ret) {
+		dev_err(pctl->dev,
+		"missing allwinner, function property in node %s\n",
+		node->name);
+		return -EINVAL;
+	}
+
+	nmaps = of_property_count_strings(node, "allwinner,pins") * 2;
+	if (nmaps < 0) {
+		dev_err(pctl->dev,
+		"missing allwinner,pins property in node %s\n",
+		node->name);
+		return -EINVAL;
+	}
+
+	*map = kmalloc(nmaps * sizeof(struct pinctrl_map), GFP_KERNEL);
+	if (!map)
+		return -ENOMEM;
+
+	of_property_for_each_string(node, "allwinner,pins", prop, group) {
+		struct axp_pinctrl_group *grp =
+			axp_pinctrl_find_group_by_name(pctl, group);
+		int configlen = 0;
+
+		if (!grp) {
+			dev_err(pctl->dev, "unknown pin %s", group);
+			continue;
+		}
+
+		if (!axp_pinctrl_desc_find_function_by_name(pctl,
+			grp->name, function)) {
+			dev_err(pctl->dev,
+			"unsupported function %s on pin %s",
+			function, group);
+			continue;
+		}
+
+		(*map)[i].type = PIN_MAP_TYPE_MUX_GROUP;
+		(*map)[i].data.mux.group = group;
+		(*map)[i].data.mux.function = function;
+
+		i++;
+
+		(*map)[i].type = PIN_MAP_TYPE_CONFIGS_GROUP;
+		(*map)[i].data.configs.group_or_pin = group;
+
+		if (of_find_property(node, "allwinner,drive", NULL))
+			configlen++;
+		if (of_find_property(node, "allwinner,pull", NULL))
+			configlen++;
+
+		pinconfig = kzalloc(configlen * sizeof(*pinconfig), GFP_KERNEL);
+
+		if (!of_property_read_u32(node, "allwinner,drive", &val))
+			;
+
+		if (!of_property_read_u32(node, "allwinner,pull", &val))
+			;
+
+		(*map)[i].data.configs.configs = pinconfig;
+		(*map)[i].data.configs.num_configs = configlen;
+
+		i++;
+	}
+
+	*num_maps = nmaps;
+
+	return 0;
+}
+
+static void axp_pctrl_dt_free_map(struct pinctrl_dev *pctldev,
+					struct pinctrl_map *map,
+					unsigned num_maps)
+{
+	int i;
+
+	for (i = 0; i < num_maps; i++) {
+		if (map[i].type == PIN_MAP_TYPE_CONFIGS_GROUP)
+			kfree(map[i].data.configs.configs);
+	}
+
+	kfree(map);
+}
+
+static struct pinctrl_ops axp_pinctrl_ops = {
+	.dt_node_to_map   = axp_pctrl_dt_node_to_map,
+	.dt_free_map      = axp_pctrl_dt_free_map,
+	.get_groups_count = axp_pinctrl_get_groups_count,
+	.get_group_name   = axp_pinctrl_get_group_name,
+	.get_group_pins   = axp_pinctrl_get_group_pins,
+};
+
+static int axp_pmx_get_functions_count(struct pinctrl_dev *pctldev)
+{
+	struct axp_pinctrl *pctl = pinctrl_dev_get_drvdata(pctldev);
+
+	return pctl->nfunctions;
+}
+
+static const char *axp_pmx_get_function_name(struct pinctrl_dev *pctldev,
+				unsigned selector)
+{
+	struct axp_pinctrl *pctl = pinctrl_dev_get_drvdata(pctldev);
+
+	return pctl->functions[selector].name;
+}
+
+static int axp_pmx_get_function_groups(struct pinctrl_dev *pctldev,
+					unsigned function,
+					const char * const **groups,
+					unsigned * const num_groups)
+{
+	struct axp_pinctrl *pctl = pinctrl_dev_get_drvdata(pctldev);
+
+	*groups     = pctl->functions[function].groups;
+	*num_groups = pctl->functions[function].ngroups;
+
+	return 0;
+}
+
+static int axp_pmx_set(struct pinctrl_dev *pctldev,
+					unsigned function,
+					unsigned group)
+{
+	struct axp_pinctrl *pctl = pinctrl_dev_get_drvdata(pctldev);
+	struct axp_pinctrl_group *g = pctl->groups + group;
+	struct axp_pinctrl_function *func = pctl->functions + function;
+	struct axp_desc_function *desc =
+	axp_pinctrl_desc_find_function_by_name(pctl, g->name, func->name);
+
+	if (!desc)
+		return -EINVAL;
+
+	pr_debug("%s enter...\n", __func__);
+
+	pctl->ops->pmx_set(pctl->axp_dev, g->pin, desc->muxval);
+
+	return 0;
+}
+
+static int axp_pmx_gpio_set_direction(struct pinctrl_dev *pctldev,
+					struct pinctrl_gpio_range *range,
+					unsigned offset,
+					bool input)
+{
+	struct axp_pinctrl *pctl = pinctrl_dev_get_drvdata(pctldev);
+	struct axp_desc_function *desc;
+	char        pin_name[AXP_PIN_NAME_MAX_LEN];
+	const char *func;
+	int         ret;
+
+	pr_debug("%s enter...\n", __func__);
+
+	ret = sprintf(pin_name, "GPIO%d", offset);
+	if (!ret)
+		goto error;
+
+	if (input)
+		func = "gpio_in";
+	else
+		func = "gpio_out";
+
+	desc = axp_pinctrl_desc_find_function_by_name(pctl, pin_name, func);
+	if (!desc) {
+		ret = -EINVAL;
+		goto error;
+	}
+
+	pctl->ops->pmx_set(pctl->axp_dev, offset, desc->muxval);
+	ret = 0;
+
+error:
+	return ret;
+}
+
+static struct pinmux_ops axp_pmx_ops = {
+	.get_functions_count = axp_pmx_get_functions_count,
+	.get_function_name   = axp_pmx_get_function_name,
+	.get_function_groups = axp_pmx_get_function_groups,
+	.set_mux             = axp_pmx_set,
+	.gpio_set_direction  = axp_pmx_gpio_set_direction,
+};
+
+static int axp_pinconf_get(struct pinctrl_dev *pctldev,
+						unsigned pin,
+						unsigned long *config)
+{
+	struct axp_pinctrl *pctl = pinctrl_dev_get_drvdata(pctldev);
+	int                 data;
+
+	pr_debug("%s enter... pin = %d\n", __func__, pin);
+
+	switch (SUNXI_PINCFG_UNPACK_TYPE(*config)) {
+	case SUNXI_PINCFG_TYPE_DAT:
+		data = pctl->ops->gpio_get_data(pctl->axp_dev, pin);
+		*config = SUNXI_PINCFG_PACK(SUNXI_PINCFG_TYPE_DAT, data);
+		pr_debug("axp pconf get pin [%s] data [%d]\n",
+				 pin_get_name(pctl->pctl_dev, pin), data);
+		break;
+	case SUNXI_PINCFG_TYPE_FUNC:
+		data = pctl->ops->pmx_get(pctl->axp_dev, pin);
+		*config = SUNXI_PINCFG_PACK(SUNXI_PINCFG_TYPE_FUNC, data);
+		pr_debug("axp pconf get pin [%s] funcs [%d]\n",
+				 pin_get_name(pctl->pctl_dev, pin), data);
+		break;
+	default:
+		pr_debug("invalid axp pconf type for get\n");
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int axp_pinconf_set(struct pinctrl_dev *pctldev,
+					unsigned pin,
+					unsigned long *pin_config,
+					unsigned num_configs)
+{
+	struct axp_pinctrl *pctl = pinctrl_dev_get_drvdata(pctldev);
+	unsigned long config = (unsigned long)pin_config;
+	int                  data;
+	int                  func;
+
+	pr_debug("%s enter... pin = %d\n", __func__, pin);
+
+	switch (SUNXI_PINCFG_UNPACK_TYPE(config)) {
+	case SUNXI_PINCFG_TYPE_DAT:
+		data = SUNXI_PINCFG_UNPACK_VALUE(config);
+		pctl->ops->gpio_set_data(pctl->axp_dev, pin, data);
+		pr_debug("axp pconf set pin [%s] data to [%d]\n",
+				 pin_get_name(pctl->pctl_dev, pin), data);
+		break;
+	case SUNXI_PINCFG_TYPE_FUNC:
+		func = SUNXI_PINCFG_UNPACK_VALUE(config);
+		pctl->ops->pmx_set(pctl->axp_dev, pin, func);
+		pr_debug("axp pconf set pin [%s] func to [%d]\n",
+				 pin_get_name(pctl->pctl_dev, pin), func);
+		break;
+	default:
+		pr_debug("invalid axp pconf type for set\n");
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int axp_pinconf_group_get(struct pinctrl_dev *pctldev,
+					unsigned group,
+					unsigned long *config)
+{
+	struct axp_pinctrl *pctl = pinctrl_dev_get_drvdata(pctldev);
+
+	*config = pctl->groups[group].config;
+	return 0;
+}
+
+static int axp_pinconf_group_set(struct pinctrl_dev *pctldev,
+					unsigned group,
+					unsigned long *configs,
+					unsigned num_configs)
+{
+	struct axp_pinctrl *pctl = pinctrl_dev_get_drvdata(pctldev);
+	struct axp_pinctrl_group *g = &pctl->groups[group];
+	int i = 0;
+
+	for (i = 0; i < num_configs; i++) {
+		/* cache the config value */
+		g->config = configs[i];
+	}
+
+	return 0;
+}
+
+static struct pinconf_ops axp_pinconf_ops = {
+	.pin_config_get       = axp_pinconf_get,
+	.pin_config_set       = axp_pinconf_set,
+	.pin_config_group_get = axp_pinconf_group_get,
+	.pin_config_group_set = axp_pinconf_group_set,
+};
+
+static int axp_gpio_request(struct gpio_chip *chip, unsigned offset)
+{
+	return pinctrl_request_gpio(chip->base + offset);
+}
+
+static void axp_gpio_free(struct gpio_chip *chip, unsigned offset)
+{
+	pinctrl_free_gpio(chip->base + offset);
+}
+
+static int axp_gpio_direction_input(struct gpio_chip *chip, unsigned offset)
+{
+	return pinctrl_gpio_direction_input(chip->base + offset);
+}
+
+static int axp_gpio_get(struct gpio_chip *chip, unsigned offset)
+{
+	struct axp_pinctrl *pctl = container_of(chip,
+				struct axp_pinctrl, gpio_chip);
+	return pctl->ops->gpio_get_data(pctl->axp_dev, offset);
+}
+
+static void axp_gpio_set(struct gpio_chip *chip, unsigned offset, int value)
+{
+	struct axp_pinctrl *pctl = container_of(chip,
+				struct axp_pinctrl, gpio_chip);
+	pctl->ops->gpio_set_data(pctl->axp_dev, offset, value);
+}
+
+static int axp_gpio_direction_output(struct gpio_chip *chip,
+					unsigned offset, int value)
+{
+	return pinctrl_gpio_direction_output(chip->base + offset);
+}
+
+static int axp_pinctrl_gpio_of_xlate(struct gpio_chip *gc,
+					const struct of_phandle_args *gpiospec,
+					u32 *flags)
+{
+	struct gpio_config *config = NULL;
+	int pin, base;
+
+	pr_debug("%s enter... gpiospec->args[0] = %d,\"\
+			+ \" gpiospec->args[1] = %d\n",
+			__func__, gpiospec->args[0], gpiospec->args[1]);
+
+	base = AXP_PIN_BASE;
+	pin = base + gpiospec->args[1];
+
+	pin = pin-gc->base;
+	if (pin > gc->ngpio)
+		return -EINVAL;
+
+	if (flags) {
+		config = (struct gpio_config *)flags;
+		config->gpio = base + gpiospec->args[1];
+		config->mul_sel = gpiospec->args[2];
+		config->drv_level = gpiospec->args[3];
+		config->pull = gpiospec->args[4];
+		config->data = gpiospec->args[5];
+	}
+
+	return pin;
+}
+
+static int axp_pinctrl_add_function(struct axp_pinctrl *pctl, const char *name)
+{
+	struct axp_pinctrl_function *func = pctl->functions;
+
+	while (func->name) {
+		/* function already there */
+		if (strcmp(func->name, name) == 0) {
+			func->ngroups++;
+			return -EEXIST;
+		}
+		func++;
+	}
+
+	func->name = name;
+	func->ngroups = 1;
+
+	pctl->nfunctions++;
+
+	return 0;
+}
+
+static struct axp_pinctrl_function *axp_pinctrl_find_function_by_name(
+		struct axp_pinctrl *pctl, const char *name)
+{
+	int i;
+	struct axp_pinctrl_function *func = pctl->functions;
+
+	for (i = 0; i < pctl->nfunctions; i++) {
+		if (!func[i].name)
+			break;
+
+		if (!strcmp(func[i].name, name))
+			return func + i;
+	}
+
+	return NULL;
+}
+
+static int axp_pinctrl_build_state(struct device *dev, struct axp_pinctrl *pctl)
+{
+	int i;
+
+	pctl->ngroups = pctl->desc->npins;
+	/* Allocate groups */
+	pctl->groups = devm_kzalloc(dev,
+		pctl->ngroups * sizeof(*pctl->groups), GFP_KERNEL);
+	if (!pctl->groups)
+		return -ENOMEM;
+
+	for (i = 0; i < pctl->desc->npins; i++) {
+		const struct axp_desc_pin *pin = pctl->desc->pins + i;
+		struct axp_pinctrl_group *group = pctl->groups + i;
+
+		group->name = pin->pin.name;
+		group->pin = pin->pin.number;
+	}
+
+	/*
+	 * We suppose that we won't have any more functions than pins,
+	 * we'll reallocate that later anyway
+	 */
+	pctl->functions = devm_kzalloc(dev,
+		pctl->desc->npins * sizeof(*pctl->functions),
+		GFP_KERNEL);
+	if (!pctl->functions)
+		return -ENOMEM;
+
+	/* Count functions and their associated groups */
+	for (i = 0; i < pctl->desc->npins; i++) {
+		const struct axp_desc_pin *pin = pctl->desc->pins + i;
+		struct axp_desc_function *func = pin->functions;
+
+		while (func->name) {
+			axp_pinctrl_add_function(pctl, func->name);
+			func++;
+		}
+	}
+
+	pctl->functions = krealloc(pctl->functions,
+		pctl->nfunctions * sizeof(*pctl->functions),
+		GFP_KERNEL);
+
+	for (i = 0; i < pctl->desc->npins; i++) {
+		const struct axp_desc_pin *pin = pctl->desc->pins + i;
+		struct axp_desc_function *func = pin->functions;
+
+		while (func->name) {
+			struct axp_pinctrl_function *func_item;
+			const char **func_grp;
+
+			func_item = axp_pinctrl_find_function_by_name(
+				pctl, func->name);
+			if (!func_item)
+				return -EINVAL;
+
+			if (!func_item->groups) {
+				func_item->groups = devm_kzalloc(dev,
+				func_item->ngroups * sizeof(*func_item->groups),
+				GFP_KERNEL);
+				if (!func_item->groups)
+					return -ENOMEM;
+			}
+
+			func_grp = func_item->groups;
+			while (*func_grp)
+				func_grp++;
+
+			*func_grp = pin->pin.name;
+			func++;
+		}
+	}
+
+	return 0;
+}
+
+struct axp_pinctrl *axp_pinctrl_register(struct device *dev,
+					struct axp_dev *axp_dev,
+					struct axp_pinctrl_desc *desc,
+					struct axp_gpio_ops *ops)
+{
+	struct pinctrl_desc *pctrl_desc;
+	struct axp_pinctrl      *pctl;
+	struct pinctrl_pin_desc *pins;
+	int    ret;
+	int    i;
+
+	/* allocate and initialize axp-pinctrl */
+	pr_debug("axp_pinctrl_probe enter...\n");
+	pctl = devm_kzalloc(dev, sizeof(*pctl), GFP_KERNEL);
+	if (!pctl) {
+		dev_err(dev,
+		"allocate memory for axp-pinctrl structure failed\n");
+		return NULL;
+	}
+
+	pctl->dev  = dev;
+	pctl->desc = desc;
+	pctl->ops  = ops;
+	pctl->axp_dev = axp_dev;
+
+	ret = axp_pinctrl_build_state(dev, pctl);
+	if (ret) {
+		dev_err(dev, "dt probe failed: %d\n", ret);
+		return NULL;
+	}
+
+	/* register axp pinctrl */
+	pins = devm_kzalloc(dev, pctl->desc->npins * sizeof(*pins), GFP_KERNEL);
+	if (!pins)
+		return NULL;
+
+	for (i = 0; i < pctl->desc->npins; i++)
+		pins[i] = pctl->desc->pins[i].pin;
+
+	pctrl_desc = devm_kzalloc(dev, sizeof(*pctrl_desc), GFP_KERNEL);
+	if (!pctrl_desc)
+		return NULL;
+
+	pctrl_desc->name = dev_name(dev);
+	pctrl_desc->owner = THIS_MODULE;
+	pctrl_desc->pins = pins;
+	pctrl_desc->npins = pctl->desc->npins;
+	pctrl_desc->pctlops = &axp_pinctrl_ops,
+	pctrl_desc->pmxops  = &axp_pmx_ops,
+	pctrl_desc->confops = &axp_pinconf_ops,
+
+	pctl->pctl_dev = pinctrl_register(pctrl_desc, dev, pctl);
+	if (!pctl->pctl_dev) {
+		gpiochip_remove(&pctl->gpio_chip);
+		return NULL;
+	}
+
+	/* initialize axp-gpio-chip */
+#if  LINUX_VERSION_CODE >= KERNEL_VERSION(4,9,0)
+	pctl->gpio_chip.parent		 = dev;
+#endif
+	pctl->gpio_chip.label            = MODULE_NAME;
+	pctl->gpio_chip.owner            = THIS_MODULE;
+	pctl->gpio_chip.request          = axp_gpio_request;
+	pctl->gpio_chip.free             = axp_gpio_free;
+	pctl->gpio_chip.direction_input  = axp_gpio_direction_input;
+	pctl->gpio_chip.direction_output = axp_gpio_direction_output;
+	pctl->gpio_chip.get              = axp_gpio_get;
+	pctl->gpio_chip.set              = axp_gpio_set;
+	pctl->gpio_chip.of_xlate         = axp_pinctrl_gpio_of_xlate;
+	pctl->gpio_chip.of_gpio_n_cells  = 6;
+	pctl->gpio_chip.base             = AXP_PIN_BASE;
+	pctl->gpio_chip.ngpio            = desc->npins;
+	pctl->gpio_chip.can_sleep        = 0,
+
+	ret = gpiochip_add(&pctl->gpio_chip);
+	if (ret) {
+		dev_err(dev, "could not add GPIO chip\n");
+		return NULL;
+	}
+
+	for (i = 0; i < pctl->desc->npins; i++) {
+		const struct axp_desc_pin *pin = pctl->desc->pins + i;
+
+		ret = gpiochip_add_pin_range(&pctl->gpio_chip, dev_name(dev),
+					pin->pin.number,
+					pin->pin.number, 1);
+		if (ret) {
+			dev_err(dev, "could not add GPIO pin range\n");
+			gpiochip_remove(&pctl->gpio_chip);
+			return NULL;
+		}
+	}
+
+	pr_debug("axp pinctrl driver register ok\n");
+	return pctl;
+}
+EXPORT_SYMBOL_GPL(axp_pinctrl_register);
+
+int axp_pinctrl_unregister(struct axp_pinctrl *pctl)
+{
+	pinctrl_unregister(pctl->pctl_dev);
+	gpiochip_remove(&pctl->gpio_chip);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(axp_pinctrl_unregister);
+
+struct axp_gpio_irq_ops axp_irq_ops[AXP_ONLINE_SUM];
+
+void axp_gpio_irq_ops_set(int pmu_num, struct axp_gpio_irq_ops *ops)
+{
+	axp_irq_ops[pmu_num].irq_request  = ops->irq_request;
+	axp_irq_ops[pmu_num].irq_free     = ops->irq_free;
+	axp_irq_ops[pmu_num].irq_ack      = ops->irq_ack;
+	axp_irq_ops[pmu_num].irq_enable   = ops->irq_enable;
+	axp_irq_ops[pmu_num].irq_disable  = ops->irq_disable;
+	axp_irq_ops[pmu_num].irq_set_type = ops->irq_set_type;
+}
+
+int axp_gpio_irq_request(int pmu_num, int gpio_no,
+				u32 (*handler)(int, void *), void *data)
+{
+	return axp_irq_ops[pmu_num].irq_request(gpio_no, handler, data);
+}
+EXPORT_SYMBOL_GPL(axp_gpio_irq_request);
+
+int axp_gpio_irq_enable(int pmu_num, int gpio_no)
+{
+	return axp_irq_ops[pmu_num].irq_enable(gpio_no);
+}
+EXPORT_SYMBOL_GPL(axp_gpio_irq_enable);
+
+int axp_gpio_irq_disable(int pmu_num, int gpio_no)
+{
+	return axp_irq_ops[pmu_num].irq_disable(gpio_no);
+}
+EXPORT_SYMBOL_GPL(axp_gpio_irq_disable);
+
+int axp_gpio_irq_set_type(int pmu_num, int gpio_no, unsigned long type)
+{
+	return axp_irq_ops[pmu_num].irq_set_type(gpio_no, type);
+}
+EXPORT_SYMBOL_GPL(axp_gpio_irq_set_type);
+
+int axp_gpio_irq_free(int pmu_num, int gpio_no)
+{
+	return axp_irq_ops[pmu_num].irq_free(gpio_no);
+}
+EXPORT_SYMBOL_GPL(axp_gpio_irq_free);
+
+int axp_gpio_irq_valid(struct axp_pinctrl_desc *desc, int gpio_no)
+{
+	int i;
+	struct axp_desc_function *func;
+
+	for (i = 0; i < desc->npins; i++) {
+		func = (desc->pins + i)->functions;
+		while (func->name) {
+			if (!strcmp(func->name, "irq")) {
+				if (i == gpio_no)
+					goto found;
+			}
+			func++;
+		}
+	}
+
+	return 0;
+
+found:
+	return func->irq_valid;
+}
+
+MODULE_DESCRIPTION("ALLWINNERTECH axp gpio");
+MODULE_AUTHOR("pannan");
+MODULE_LICENSE("GPL");

--- a/drivers/power/supply/axp/axp-gpio.h	1969-12-31 19:00:00.000000000 -0500
+++ b/drivers/power/supply/axp/axp-gpio.h	2022-09-01 10:46:35.786464423 -0400
@@ -0,0 +1,118 @@
+/*
+ * drivers/power/axp/axp-gpio.h
+ * (C) Copyright 2010-2016
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * Pannan <pannan@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ */
+
+#ifndef AXP_GPIO_H_
+#define AXP_GPIO_H_
+
+#include <linux/kernel.h>
+#include  "sunxi-gpio.h"
+
+#define AXP_PINCTRL_GPIO(_num)  PINCTRL_PIN(_num, "GPIO"#_num)
+
+/*
+ * GPIO Registers.
+ */
+
+#define AXP_PIN_NAME_MAX_LEN    (8)
+
+struct axp_desc_function {
+	const char *name;
+	u8         muxval;
+	u8         irq_valid;
+};
+
+struct axp_desc_pin {
+	struct pinctrl_pin_desc  pin;
+	struct axp_desc_function *functions;
+};
+
+struct axp_pinctrl_desc {
+	const struct axp_desc_pin *pins;
+	int           npins;
+};
+
+struct axp_pinctrl_function {
+	const char  *name;
+	const char  **groups;
+	unsigned    ngroups;
+};
+
+struct axp_pinctrl_group {
+	const char  *name;
+	unsigned long   config;
+	unsigned    pin;
+};
+
+struct axp_gpio_ops {
+	int (*gpio_get_data)(struct axp_dev *axp_dev, int gpio);
+	int (*gpio_set_data)(struct axp_dev *axp_dev, int gpio, int value);
+	int (*pmx_set)(struct axp_dev *axp_dev, int gpio, int mux);
+	int (*pmx_get)(struct axp_dev *axp_dev, int gpio);
+};
+
+struct axp_pinctrl {
+	struct device                *dev;
+	struct pinctrl_dev           *pctl_dev;
+	struct gpio_chip             gpio_chip;
+	struct axp_dev               *axp_dev;
+	struct axp_gpio_ops          *ops;
+	struct axp_pinctrl_desc      *desc;
+	struct axp_pinctrl_function  *functions;
+	unsigned                     nfunctions;
+	struct axp_pinctrl_group     *groups;
+	unsigned                     ngroups;
+};
+
+#define AXP_PIN_DESC(_pin, ...)         \
+	{                                   \
+		.pin = _pin,                    \
+		.functions = (struct axp_desc_function[]){  \
+			__VA_ARGS__, { } },         \
+	}
+
+#define AXP_FUNCTION(_val, _name)       \
+	{                           \
+		.name = _name,          \
+		.muxval = _val,         \
+	}
+
+#define AXP_FUNCTION_IRQ(_valid)  \
+	{                           \
+		.name = "irq",          \
+		.irq_valid = _valid,    \
+	}
+
+struct axp_gpio_irq_ops {
+	int (*irq_request)(int, u32 (*handler)(int, void *), void *);
+	int (*irq_free)(int);
+	int (*irq_ack)(int);
+	int (*irq_enable)(int);
+	int (*irq_disable)(int);
+	int (*irq_set_type)(int, unsigned long);
+};
+
+struct axp_gpio_irqchip {
+	int gpio_no;
+	u32 (*handler)(int, void *);
+	void *data;
+};
+
+struct axp_pinctrl *axp_pinctrl_register(struct device *dev,
+			struct axp_dev *axp_dev,
+			struct axp_pinctrl_desc *desc,
+			struct axp_gpio_ops *ops);
+int axp_pinctrl_unregister(struct axp_pinctrl *pctl);
+void axp_gpio_irq_ops_set(int pmu_num, struct axp_gpio_irq_ops *ops);
+int axp_gpio_irq_valid(struct axp_pinctrl_desc *desc, int gpio_no);
+
+#endif

--- a/drivers/power/supply/axp/axp-powerkey.c	1969-12-31 19:00:00.000000000 -0500
+++ b/drivers/power/supply/axp/axp-powerkey.c	2022-09-01 10:46:35.786464423 -0400
@@ -0,0 +1,106 @@
+/*
+ * drivers/power/axp/axp-powerkey.c
+ * (C) Copyright 2010-2016
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * Pannan <pannan@allwinnertech.com>
+ *
+ * axp powerkey APIs
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/types.h>
+#include <linux/device.h>
+#include <linux/workqueue.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/power_supply.h>
+#include <linux/delay.h>
+#include <linux/kthread.h>
+#include <linux/slab.h>
+#include <linux/debugfs.h>
+#include <linux/seq_file.h>
+#include <linux/input.h>
+#include <linux/of.h>
+#include "axp-core.h"
+#include "axp-powerkey.h"
+
+static irqreturn_t axp_key_up_handler(int irq, void *data)
+{
+	struct axp_powerkey_info *info = (struct axp_powerkey_info *)data;
+	AXP_DEBUG(AXP_INT, info->chip->pmu_num, "power key up\n");
+	input_report_key(info->idev, KEY_POWER, 0);
+	input_sync(info->idev);
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t axp_key_down_handler(int irq, void *data)
+{
+	struct axp_powerkey_info *info = (struct axp_powerkey_info *)data;
+	AXP_DEBUG(AXP_INT, info->chip->pmu_num, "power key down\n");
+	input_report_key(info->idev, KEY_POWER, 1);
+	input_sync(info->idev);
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t axp_presslong_handler(int irq, void *data)
+{
+	struct axp_powerkey_info *info = (struct axp_powerkey_info *)data;
+	AXP_DEBUG(AXP_INT, info->chip->pmu_num, "power key long\n");
+	input_report_key(info->idev, KEY_POWER, 1);
+	input_sync(info->idev);
+	ssleep(2);
+	input_report_key(info->idev, KEY_POWER, 0);
+	input_sync(info->idev);
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t axp_pressshort_handler(int irq, void *data)
+{
+	struct axp_powerkey_info *info = (struct axp_powerkey_info *)data;
+	AXP_DEBUG(AXP_INT, info->chip->pmu_num, "power key short\n");
+	input_report_key(info->idev, KEY_POWER, 1);
+	input_sync(info->idev);
+	msleep(100);
+	input_report_key(info->idev, KEY_POWER, 0);
+	input_sync(info->idev);
+	return IRQ_HANDLED;
+}
+
+struct axp_interrupts axp_powerkey_irq[4] = {
+	{"PEK_DBR", axp_key_up_handler},
+	{"PEK_DBF", axp_key_down_handler},
+	{"PEK_LONG", axp_presslong_handler},
+	{"PEK_SHORT", axp_pressshort_handler},
+};
+
+int axp_powerkey_dt_parse(struct device_node *node,
+			struct axp_config_info *axp_config)
+{
+	if (!of_device_is_available(node)) {
+		pr_err("%s: failed\n", __func__);
+		return -1;
+	}
+  printk("[axp]parsing node name:%s in line:%d  in:%s \n",node->name,__LINE__,__func__);
+	AXP_OF_PROP_READ(pmu_powkey_off_time,            6000);
+	AXP_OF_PROP_READ(pmu_powkey_off_func,               0);
+	AXP_OF_PROP_READ(pmu_powkey_off_en,                 1);
+	AXP_OF_PROP_READ(pmu_powkey_off_delay_time,         0);
+	AXP_OF_PROP_READ(pmu_powkey_long_time,           1500);
+	AXP_OF_PROP_READ(pmu_powkey_on_time,             1000);
+	AXP_OF_PROP_READ(pmu_pwrok_time,                   64);
+	AXP_OF_PROP_READ(pmu_pwrnoe_time,                2000);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(axp_powerkey_dt_parse);
+
+MODULE_DESCRIPTION("ALLWINNERTECH axp powerkey");
+MODULE_AUTHOR("pannan");
+MODULE_LICENSE("GPL");

--- a/drivers/power/supply/axp/axp-powerkey.h	1969-12-31 19:00:00.000000000 -0500
+++ b/drivers/power/supply/axp/axp-powerkey.h	2022-09-01 10:46:35.786464423 -0400
@@ -0,0 +1,28 @@
+/*
+ * drivers/power/axp/axp-powerkey.h
+ * (C) Copyright 2010-2016
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * Pannan <pannan@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ */
+
+#ifndef AXP_POWERKEY_H
+#define AXP_POWERKEY_H
+
+#include "axp-charger.h"
+
+struct axp_powerkey_info {
+	struct input_dev *idev;
+	struct axp_dev *chip;
+};
+
+extern struct axp_interrupts axp_powerkey_irq[4];
+extern int axp_powerkey_dt_parse(struct device_node *node,
+			struct axp_config_info *axp_config);
+
+#endif /* AXP_POWERKEY_H */

--- a/drivers/power/supply/axp/axp-regulator.c	1969-12-31 19:00:00.000000000 -0500
+++ b/drivers/power/supply/axp/axp-regulator.c	2022-09-01 10:46:35.786464423 -0400
@@ -0,0 +1,893 @@
+/*
+ * drivers/power/axp/axp-regulator.c
+ * (C) Copyright 2010-2016
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * Pannan <pannan@allwinnertech.com>
+ *
+ * axp regulator APIs
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/err.h>
+#include <linux/init.h>
+#include <linux/regmap.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/delay.h>
+#include <linux/slab.h>
+#include <linux/platform_device.h>
+#include <linux/regulator/driver.h>
+#include <linux/regulator/machine.h>
+#include <linux/module.h>
+//#include "axp_depend.h"
+#include <linux/notifier.h>
+#include "axp-core.h"
+#include "axp-regulator.h"
+
+/* pwr_dm_bitmap -> pwr_dm_name */
+struct bitmap_name_mapping pwr_dm_bitmap_name_mapping[] = {
+	{VDD_CPUA_BIT,    "vdd-cpua"    },
+	{VDD_CPUB_BIT,    "vdd-cpub"    },
+	{VCC_DRAM_BIT,    "vcc-dram"    },
+	{VDD_GPU_BIT,     "vdd-gpu"     },
+	{VDD_SYS_BIT,     "vdd-sys"     },
+	{VDD_VPU_BIT,     "vdd-vpu"     },
+	{VDD_CPUS_BIT,    "vdd-cpus"    },
+	{VDD_DRAMPLL_BIT, "vdd-drampll" },
+	{VCC_ADC_BIT,     "vcc-adc"     },
+	{VCC_PL_BIT,      "vcc-pl"      },
+	{VCC_PM_BIT,      "vcc-pm"      },
+	{VCC_IO_BIT,      "vcc-io"      },
+	{VCC_CPVDD_BIT,   "vcc-cpvdd"   },
+	{VCC_LDOIN_BIT,   "vcc-ldoin"   },
+	{VCC_PLL_BIT,     "vcc-pll"     },
+	{VCC_LPDDR_BIT,   "vcc-lpddr"   },
+	{VDD_TEST_BIT,    "vdd-test"    },
+	{VDD_RES1_BIT,    "vdd-res1-bit"},
+	{VDD_RES2_BIT,    "vdd-res2-bit"},
+#if (defined(CONFIG_ARCH_SUN8IW10) || defined(CONFIG_ARCH_SUN8IW11))
+	{VCC_PC_BIT,      "vcc-pc"      },
+#else
+	{VDD_RES3_BIT,    "vdd-res3-bit"},
+#endif
+};
+
+int pwr_dm_bitmap_name_mapping_cnt = sizeof(pwr_dm_bitmap_name_mapping)\
+				/sizeof(pwr_dm_bitmap_name_mapping[0]);
+
+RAW_NOTIFIER_HEAD(axp_regu_notifier);
+
+#if defined(CONFIG_AW_AXPDUMMY) && defined(CONFIG_SUNXI_ARISC)
+struct ldo_type_name_mapping {
+	enum power_voltage_type ldo_type;
+	char *ldo_name;
+};
+
+static struct ldo_type_name_mapping mapping_list[] = {
+	{DUMMY_REGULATOR1, "axpdummy_ldo1"},
+	{DUMMY_REGULATOR2, "axpdummy_ldo2"},
+	{DUMMY_REGULATOR3, "axpdummy_ldo3"},
+	{DUMMY_REGULATOR4, "axpdummy_ldo4"},
+	{DUMMY_REGULATOR5, "axpdummy_ldo5"},
+	{DUMMY_REGULATOR6, "axpdummy_ldo6"},
+};
+
+static enum power_voltage_type get_ldo_type_by_name(const char *name)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(mapping_list); i++) {
+		if (!strcmp(mapping_list[i].ldo_name, name))
+			break;
+	}
+
+	return mapping_list[i].ldo_type;
+};
+#endif
+
+static struct axp_consumer_supply *consumer_supply_count;
+
+static inline struct axp_dev *to_axp_dev(struct regulator_dev *rdev)
+{
+	struct device *dev;
+	struct axp_dev *adev;
+
+	dev = rdev_get_dev(rdev)->parent->parent;
+	adev = dev_get_drvdata(dev);
+
+	return adev;
+}
+
+static inline s32 check_range(struct axp_regulator_info *info,
+							s32 min_uv, s32 max_uv)
+{
+	if (min_uv < info->min_uv || min_uv > info->max_uv)
+		return -EINVAL;
+
+	return 0;
+}
+
+/* AXP common operations */
+static s32 axp_set_voltage(struct regulator_dev *rdev,
+				s32 min_uv, s32 max_uv, unsigned *selector)
+{
+	struct axp_regulator_info *info = rdev_get_drvdata(rdev);
+	struct axp_regmap *regmap = info->regmap;
+	u8 val, mask;
+	s32 ret = -1;
+	int i, flag = 0;
+	struct axp_dev *cur_axp_dev;
+
+	for (i = 0; i < AXP_ONLINE_SUM; i++) {
+		cur_axp_dev = get_pmu_cur_dev(i);
+		if (cur_axp_dev == NULL)
+			continue;
+
+		flag++;
+		if (cur_axp_dev->is_dummy) {
+#if defined(CONFIG_AW_AXPDUMMY) && defined(CONFIG_SUNXI_ARISC)
+			return arisc_pmu_set_voltage(
+				get_ldo_type_by_name(rdev->constraints->name),
+				min_uv / 1000);
+#endif
+			return 0;
+		} else {
+			continue;
+		}
+	}
+
+	BUG_ON(flag == 0);
+
+	if (check_range(info, min_uv, max_uv)) {
+		pr_err("invalid voltage range (%d, %d) uV\n", min_uv, max_uv);
+		return -EINVAL;
+	}
+
+	if ((info->switch_uv != 0) && (info->step2_uv != 0) &&
+		(info->new_level_uv != 0) && (min_uv > info->switch_uv)) {
+		val = (info->switch_uv - info->min_uv + info->step1_uv - 1)
+				/ info->step1_uv;
+		if (min_uv <= info->new_level_uv) {
+			val += 1;
+		} else {
+			val += (min_uv - info->new_level_uv) / info->step2_uv;
+			val += 1;
+		}
+		mask = ((1 << info->vol_nbits) - 1)  << info->vol_shift;
+	} else if ((info->switch_uv != 0) && (info->step2_uv != 0)
+				&& (min_uv > info->switch_uv)
+				&& (info->new_level_uv == 0)) {
+		val = (info->switch_uv - info->min_uv + info->step1_uv - 1)
+				/ info->step1_uv;
+		val += (min_uv - info->switch_uv) / info->step2_uv;
+		mask = ((1 << info->vol_nbits) - 1)  << info->vol_shift;
+	} else {
+		val = (min_uv - info->min_uv + info->step1_uv - 1)
+				/ info->step1_uv;
+		val <<= info->vol_shift;
+		mask = ((1 << info->vol_nbits) - 1)  << info->vol_shift;
+	}
+
+	ret = axp_regmap_update(regmap, info->vol_reg, val, mask);
+	if (ret)
+		return ret;
+
+	if (0 != info->dvm_enable_reg) {
+		ret = axp_regmap_read(regmap, info->dvm_enable_reg, &val);
+		if (ret) {
+			pr_err("read dvm enable reg failed!\n");
+			return ret;
+		}
+
+		if (val & (0x1<<info->dvm_enable_bit)) {
+			if (!info->dvm_finish_flag) {
+				udelay(1000);
+			} else {
+				/* wait dvm status update */
+				udelay(100);
+				do {
+					ret = axp_regmap_read(regmap,
+						info->vol_reg, &val);
+					if (ret) {
+						pr_err("read dvm failed!\n");
+						break;
+					}
+				} while (!(val & (0x1<<7)));
+			}
+		}
+	}
+
+	AXP_DEBUG(AXP_REGU, info->pmu_num, "set %s voltage: %duV\n",
+				rdev->constraints->name, min_uv);
+
+	return ret;
+}
+
+static s32 axp_get_voltage(struct regulator_dev *rdev)
+{
+	struct axp_regulator_info *info = rdev_get_drvdata(rdev);
+	struct axp_regmap *regmap = info->regmap;
+
+	u8 val, mask;
+	s32 ret, switch_val, vol;
+	int i, flag = 0;
+	struct axp_dev *cur_axp_dev;
+/******
+	for (i = 0; i < AXP_ONLINE_SUM; i++) {
+		cur_axp_dev = get_pmu_cur_dev(i);
+		if (cur_axp_dev == NULL)
+			continue;
+
+		flag++;
+		if (cur_axp_dev->is_dummy) {
+#if defined(CONFIG_AW_AXPDUMMY) && defined(CONFIG_SUNXI_ARISC)
+			return arisc_pmu_get_voltage(
+			get_ldo_type_by_name(rdev->constraints->name)) * 1000;
+#endif
+			return INT_MAX;
+		} else {
+			continue;
+		}
+	}
+
+	BUG_ON(flag == 0);
+	****/
+
+	ret = axp_regmap_read(regmap, info->vol_reg, &val);
+	if (ret)
+		return ret;
+
+	mask = ((1 << info->vol_nbits) - 1) << info->vol_shift;
+	if (info->step1_uv != 0)
+		switch_val = ((info->switch_uv - info->min_uv
+			+ info->step1_uv - 1) / info->step1_uv);
+	else
+		switch_val = 0;
+
+	val = (val & mask) >> info->vol_shift;
+
+	if ((info->switch_uv != 0) && (info->step2_uv != 0) &&
+		(val > switch_val) && (info->new_level_uv != 0)) {
+		val -= switch_val;
+		vol = info->new_level_uv + info->step2_uv * val;
+	} else if ((info->switch_uv != 0)
+			&& (info->step2_uv != 0)
+			&& (val > switch_val)
+			&& (info->new_level_uv == 0)) {
+		val -= switch_val;
+		vol = info->switch_uv + info->step2_uv * val;
+	} else {
+		vol = info->min_uv + info->step1_uv * val;
+	}
+
+	if (vol > info->max_uv)
+		vol = info->max_uv;
+
+	return vol;
+}
+
+static s32 axp_enable(struct regulator_dev *rdev)
+{
+	struct axp_regulator_info *info = rdev_get_drvdata(rdev);
+	struct axp_regmap *regmap = info->regmap;
+	int i, flag = 0;
+	struct axp_dev *cur_axp_dev;
+
+	AXP_DEBUG(AXP_REGU, info->pmu_num, "enable %s\n",
+				rdev->constraints->name);
+#if 0
+	for (i = 0; i < AXP_ONLINE_SUM; i++) {
+		cur_axp_dev = get_pmu_cur_dev(i);
+		if (cur_axp_dev == NULL)
+			continue;
+
+		flag++;
+		if (cur_axp_dev->is_dummy) {
+#if defined(CONFIG_AW_AXPDUMMY) && defined(CONFIG_SUNXI_ARISC)
+			return arisc_pmu_set_voltage_state(
+			get_ldo_type_by_name(rdev->constraints->name), 1);
+#endif
+			return 0;
+		} else {
+			continue;
+		}
+	}
+
+	BUG_ON(flag == 0);
+#endif
+	return axp_regmap_update(regmap, rdev->desc->enable_reg,
+			info->enable_val, rdev->desc->enable_mask);
+}
+
+static s32 axp_disable(struct regulator_dev *rdev)
+{
+	struct axp_regulator_info *info = rdev_get_drvdata(rdev);
+	struct axp_regmap *regmap = info->regmap;
+	int i, flag = 0;
+	struct axp_dev *cur_axp_dev;
+
+	AXP_DEBUG(AXP_REGU, info->pmu_num, "disable %s\n",
+				rdev->constraints->name);
+#if 0
+	for (i = 0; i < AXP_ONLINE_SUM; i++) {
+		cur_axp_dev = get_pmu_cur_dev(i);
+		if (cur_axp_dev == NULL)
+			continue;
+
+		flag++;
+		if (cur_axp_dev->is_dummy) {
+#if defined(CONFIG_AW_AXPDUMMY) && defined(CONFIG_SUNXI_ARISC)
+			return arisc_pmu_set_voltage_state(
+			get_ldo_type_by_name(rdev->constraints->name), 0);
+#endif
+			return 0;
+		} else {
+			continue;
+		}
+	}
+
+	BUG_ON(flag == 0);
+#endif
+
+	return axp_regmap_update(regmap, rdev->desc->enable_reg,
+			info->disable_val, rdev->desc->enable_mask);
+}
+
+static s32 axp_is_enabled(struct regulator_dev *rdev)
+{
+	struct axp_regulator_info *info = rdev_get_drvdata(rdev);
+	struct axp_regmap *regmap = info->regmap;
+	u8 reg_val;
+	s32 ret;
+	int i, flag = 0;
+	struct axp_dev *cur_axp_dev;
+#if 0
+	for (i = 0; i < AXP_ONLINE_SUM; i++) {
+		cur_axp_dev = get_pmu_cur_dev(i);
+		if (cur_axp_dev == NULL)
+			continue;
+
+		flag++;
+		if (cur_axp_dev->is_dummy) {
+#if defined(CONFIG_AW_AXPDUMMY) && defined(CONFIG_SUNXI_ARISC)
+			return arisc_pmu_get_voltage_state(
+			get_ldo_type_by_name(rdev->constraints->name));
+#endif
+			return INT_MAX;
+		} else {
+			continue;
+		}
+	}
+
+	BUG_ON(flag == 0);
+#endif
+
+	/* rtc is always enabled, can't disable by software */
+	if (strstr(rdev->constraints->name, "rtc"))
+		return 1;
+
+	ret = axp_regmap_read(regmap, rdev->desc->enable_reg, &reg_val);
+	if (ret)
+		return -1;
+
+	if ((reg_val & rdev->desc->enable_mask) == info->enable_val)
+		return 1;
+	else
+		return 0;
+}
+
+static s32 axp_list_voltage(struct regulator_dev *rdev, unsigned selector)
+{
+	struct axp_regulator_info *info = rdev_get_drvdata(rdev);
+	s32 ret;
+	int i, flag = 0;
+	struct axp_dev *cur_axp_dev;
+#if 0
+	for (i = 0; i < AXP_ONLINE_SUM; i++) {
+		cur_axp_dev = get_pmu_cur_dev(i);
+		if (cur_axp_dev == NULL)
+			continue;
+
+		flag++;
+		if (cur_axp_dev->is_dummy)
+			return 0;
+		else
+			continue;
+	}
+
+	BUG_ON(flag == 0);
+#endif
+	ret = info->min_uv + info->step1_uv * selector;
+	if ((info->switch_uv != 0) && (info->step2_uv != 0) &&
+		(ret > info->switch_uv) && (info->new_level_uv != 0)) {
+		selector -= ((info->switch_uv-info->min_uv)/info->step1_uv);
+		ret = info->new_level_uv + info->step2_uv * selector;
+	} else if ((info->switch_uv != 0) && (info->step2_uv != 0)
+				&& (ret > info->switch_uv)
+				&& (info->new_level_uv == 0)) {
+		selector -= ((info->switch_uv-info->min_uv)/info->step1_uv);
+		ret = info->switch_uv + info->step2_uv * selector;
+	}
+
+	if (ret > info->max_uv)
+		return -EINVAL;
+
+	return ret;
+}
+
+static s32 axp_enable_time_regulator(struct regulator_dev *rdev)
+{
+	struct axp_regulator_info *info = rdev_get_drvdata(rdev);
+	int i, flag = 0;
+	struct axp_dev *cur_axp_dev;
+#if 0
+	for (i = 0; i < AXP_ONLINE_SUM; i++) {
+		cur_axp_dev = get_pmu_cur_dev(i);
+		if (cur_axp_dev == NULL)
+			continue;
+
+		flag++;
+		if (cur_axp_dev->is_dummy)
+			return 0;
+		else
+			continue;
+	}
+
+	BUG_ON(flag == 0);
+#endif
+
+	/* Per-regulator power on delay from spec */
+	if (40 > info->desc.id)
+		return 400;
+	else
+		return 1200;
+}
+
+static int axp_set_voltage_sel(struct regulator_dev *rdev, unsigned selector)
+{
+	struct axp_regulator_info *info = rdev_get_drvdata(rdev);
+	struct axp_regmap *regmap = info->regmap;
+	u8 mask;
+
+	AXP_DEBUG(AXP_REGU, info->pmu_num, "set %s voltage selector: %u\n",
+				rdev->constraints->name, selector);
+
+	selector <<= info->vol_shift;
+	mask = ((1 << info->vol_nbits) - 1)  << info->vol_shift;
+
+	return axp_regmap_update(regmap, info->vol_reg, selector, mask);
+}
+
+static int axp_get_voltage_sel(struct regulator_dev *rdev)
+{
+	struct axp_regulator_info *info = rdev_get_drvdata(rdev);
+	struct axp_regmap *regmap = info->regmap;
+	int ret;
+	u8 val, mask;
+	mask = ((1 << info->vol_nbits) - 1)  << info->vol_shift;
+
+	ret = axp_regmap_read(regmap, info->vol_reg, &val);
+	if (ret != 0)
+		return ret;
+
+	val &= mask;
+	val >>= info->vol_shift;
+
+	return val;
+}
+
+static int axp_list_voltage_sel(struct regulator_dev *rdev, unsigned index)
+{
+	struct axp_regulator_info *info = rdev_get_drvdata(rdev);
+	int ret = -EINVAL;
+
+	if (info->vtable && (index < rdev->desc->n_voltages))
+		ret = info->vtable[index] * 1000;
+
+	return ret;
+}
+
+static struct regulator_ops axp_ops = {
+	.set_voltage         = axp_set_voltage,
+	.get_voltage         = axp_get_voltage,
+	.list_voltage        = axp_list_voltage,
+	.enable              = axp_enable,
+	.disable             = axp_disable,
+	.is_enabled          = axp_is_enabled,
+	.enable_time         = axp_enable_time_regulator,
+	.set_suspend_enable  = axp_enable,
+	.set_suspend_disable = axp_disable,
+};
+
+static struct regulator_ops axp_sel_ops = {
+	.set_voltage_sel     = axp_set_voltage_sel,
+	.get_voltage_sel     = axp_get_voltage_sel,
+	.list_voltage        = axp_list_voltage_sel,
+	.enable              = axp_enable,
+	.disable             = axp_disable,
+	.is_enabled          = axp_is_enabled,
+	.enable_time         = axp_enable_time_regulator,
+	.set_suspend_enable  = axp_enable,
+	.set_suspend_disable = axp_disable,
+};
+
+struct regulator_dev *axp_regulator_register(struct device *dev,
+					struct axp_regmap *regmap,
+					struct regulator_init_data *init_data,
+					struct axp_regulator_info *info)
+{
+	struct regulator_config config = { };
+	struct regulator_dev *rdev;
+
+	config.dev = dev;
+	config.init_data = init_data;
+	info->regmap = regmap;
+	info->desc.ops = &axp_ops;
+	config.driver_data = info;
+
+	rdev = regulator_register(&info->desc, &config);
+
+	return rdev;
+}
+EXPORT_SYMBOL(axp_regulator_register);
+
+struct regulator_dev *axp_regulator_sel_register(struct device *dev,
+					struct axp_regmap *regmap,
+					struct regulator_init_data *init_data,
+					struct axp_regulator_info *info)
+{
+	struct regulator_config config = { };
+	struct regulator_dev *rdev;
+
+	config.dev = dev;
+	config.init_data = init_data;
+	info->regmap = regmap;
+	info->desc.ops = &axp_sel_ops;
+	config.driver_data = info;
+
+	rdev = regulator_register(&info->desc, &config);
+
+	return rdev;
+}
+EXPORT_SYMBOL(axp_regulator_sel_register);
+
+void axp_regulator_unregister(struct regulator_dev *rdev)
+{
+	regulator_unregister(rdev);
+}
+EXPORT_SYMBOL(axp_regulator_unregister);
+#if 0
+static s32 regu_device_tree_do_parse(struct device_node *node,
+				struct regulator_init_data *axp_init_data,
+				s32 (*get_dep_cb)(const char *))
+{
+	int ret;
+	u32 ldo_count = 0, ldo_index = 0;
+	char name[32] = {0};
+	s32 num = 0, supply_num = 0, i = 0, j = 0, var = 0;
+	struct axp_consumer_supply consumer_supply[20];
+	const char *regulator_string = NULL;
+	struct regulator_consumer_supply *regu_consumer_supply = NULL;
+
+	if (of_property_read_u32(node, "regulator_count", &ldo_count)) {
+		pr_err("%s: axp regu get regulator_count failed", __func__);
+		return -ENOENT;
+	}
+
+	for (ldo_index = 1; ldo_index <= ldo_count; ldo_index++) {
+		sprintf(name, "regulator%d", ldo_index);
+		if (of_property_read_string(node,
+			(const char *)&name, &regulator_string)) {
+			pr_err("node %s get failed!\n", name);
+			continue;
+		}
+
+		num = sscanf(regulator_string,
+		"%s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s",
+		consumer_supply[0].supply, consumer_supply[1].supply,
+		consumer_supply[2].supply, consumer_supply[3].supply,
+		consumer_supply[4].supply, consumer_supply[5].supply,
+		consumer_supply[6].supply, consumer_supply[7].supply,
+		consumer_supply[8].supply, consumer_supply[9].supply,
+		consumer_supply[10].supply, consumer_supply[11].supply,
+		consumer_supply[12].supply, consumer_supply[13].supply,
+		consumer_supply[14].supply, consumer_supply[15].supply,
+		consumer_supply[16].supply, consumer_supply[17].supply,
+		consumer_supply[18].supply, consumer_supply[19].supply);
+
+		if (num <= -1) {
+			pr_err("parse ldo%d from sysconfig failed\n",
+				ldo_index);
+			return -1;
+		} else {
+			if (strcmp(consumer_supply[1].supply, "none")) {
+				var = simple_strtoul(
+						consumer_supply[1].supply,
+						NULL, 10);
+				if (var > (ldo_index-1))
+					pr_err("supply rely set err\n");
+				else
+					(*(axp_init_data+(ldo_index-1))).supply_regulator =
+					((*(axp_init_data+(var-1))).consumer_supplies)->supply;
+			}
+
+			supply_num = num-1;
+			(*(axp_init_data+(ldo_index-1))).num_consumer_supplies = supply_num;
+
+			consumer_supply_count = kzalloc(
+				sizeof(struct axp_consumer_supply)*supply_num,
+				GFP_KERNEL);
+			if (!consumer_supply_count) {
+				pr_err("%s: request \"\
+					\"consumer_supply_count failed\n",
+					__func__);
+				return -1;
+			}
+
+			regu_consumer_supply = kzalloc(
+				sizeof(struct regulator_consumer_supply)*supply_num,
+				GFP_KERNEL);
+			if (!regu_consumer_supply) {
+				pr_err("%s: request \"\
+					\"regu_consumer_supply failed\n",
+					__func__);
+				kfree(consumer_supply_count);
+				return -1;
+			}
+
+			for (i = 0; i < supply_num; i++) {
+				if (0 != i)
+					j = i + 1;
+				else
+					j = i;
+
+				strcpy((char *)(consumer_supply_count+i),
+					consumer_supply[j].supply);
+				(regu_consumer_supply+i)->supply =
+					(const char *)(
+					(struct axp_consumer_supply *)
+					(consumer_supply_count+i)->supply);
+
+				{
+					int ret = 0, sys_id_index = 0;
+
+					sys_id_index = axp_check_sys_id(
+					(consumer_supply_count+i)->supply);
+					if (0 <= sys_id_index) {
+						ret = axp_get_ldo_dependence(
+						(const char *)
+						&(consumer_supply[0].supply),
+						sys_id_index, get_dep_cb);
+						if (ret < 0)
+							pr_err("sys_id %s set dependence failed.\n",
+							(consumer_supply_count
+							+i)->supply);
+					}
+				}
+			}
+			(*(axp_init_data+(ldo_index-1))).consumer_supplies =
+					regu_consumer_supply;
+		}
+	}
+
+	ret = __raw_notifier_call_chain(&axp_regu_notifier, AXP_READY,
+					NULL, -1, NULL);
+
+	return notifier_to_errno(ret);
+}
+#endif
+s32 axp_regulator_dt_parse(struct device_node *node,
+				struct regulator_init_data *axp_init_data,
+				s32 (*get_dep_cb)(const char *))
+{
+	s32 ret;
+
+	if (!of_device_is_available(node)) {
+		pr_err("%s: failed\n", __func__);
+		return -1;
+	}
+#if 0
+	ret = regu_device_tree_do_parse(node, axp_init_data, get_dep_cb);
+#endif
+	return ret;
+}
+EXPORT_SYMBOL(axp_regulator_dt_parse);
+
+int axp_get_ldo_count(struct device_node *node, u32 *ldo_count)
+{
+	if (!of_device_is_available(node)) {
+		pr_err("%s: axp regu is disable", __func__);
+		return -EPERM;
+	}
+
+	if (of_property_read_u32(node, "regulator_count", ldo_count)) {
+		pr_err("%s: axp regu get regulator_count failed", __func__);
+		return -ENOENT;
+	}
+
+	return 0;
+}
+
+int axp_mem_regu_init(struct device_node *node,
+				axp_mem_data_t *r_list, u32 ldo_count)
+{
+	u32 ldo_index = 0;
+	char name[32] = {0};
+	s32 num = 0;
+	struct axp_consumer_supply consumer_supply[20];
+	const char *regulator_string = NULL;
+
+	for (ldo_index = 1; ldo_index <= ldo_count; ldo_index++) {
+		sprintf(name, "regulator%d", ldo_index);
+		if (of_property_read_string(node, (const char *)&name,
+					&regulator_string)) {
+			pr_err("node %s get failed!\n",
+				  name);
+			continue;
+		}
+
+		num = sscanf(regulator_string,
+		"%s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s",
+		consumer_supply[0].supply, consumer_supply[1].supply,
+		consumer_supply[2].supply, consumer_supply[3].supply,
+		consumer_supply[4].supply, consumer_supply[5].supply,
+		consumer_supply[6].supply, consumer_supply[7].supply,
+		consumer_supply[8].supply, consumer_supply[9].supply,
+		consumer_supply[10].supply, consumer_supply[11].supply,
+		consumer_supply[12].supply, consumer_supply[13].supply,
+		consumer_supply[14].supply, consumer_supply[15].supply,
+		consumer_supply[16].supply, consumer_supply[17].supply,
+		consumer_supply[18].supply, consumer_supply[19].supply);
+
+		if (num <= -1) {
+			pr_err("get ldo%d from sysconfig failed\n", ldo_index);
+			return -1;
+		} else {
+			strcpy((char *)((r_list + ldo_index - 1)->id_name),
+						consumer_supply[0].supply);
+		}
+	}
+
+	return 0;
+}
+
+static ssize_t workmode_show(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	int ret;
+	uint8_t val;
+	struct regulator_dev *rdev;
+	struct axp_regulator_info *info;
+	struct axp_regmap *regmap;
+
+	rdev = container_of(dev, struct regulator_dev, dev);
+	info = rdev_get_drvdata(rdev);
+	regmap = info->regmap;
+
+	ret = axp_regmap_read(regmap, info->mode_reg, &val);
+	if (ret)
+		return sprintf(buf, "IO ERROR\n");
+
+	if ((val & info->mode_mask) == info->mode_mask)
+		return sprintf(buf, "PWM\n");
+	else
+		return sprintf(buf, "AUTO\n");
+}
+
+static ssize_t workmode_store(struct device *dev,
+				struct device_attribute *attr,
+				const char *buf, size_t count)
+{
+	uint8_t val;
+	struct regulator_dev *rdev;
+	struct axp_regulator_info *info;
+	struct axp_regmap *regmap;
+	unsigned int mode;
+	int ret;
+
+	rdev = container_of(dev, struct regulator_dev, dev);
+	info = rdev_get_drvdata(rdev);
+	regmap = info->regmap;
+
+	ret = kstrtouint(buf, 10, &mode);
+	if (ret)
+		return -EINVAL;
+
+	val = !!mode;
+	if (val)
+		axp_regmap_set_bits(regmap, info->mode_reg, info->mode_mask);
+	else
+		axp_regmap_clr_bits(regmap, info->mode_reg, info->mode_mask);
+
+	return count;
+}
+
+static ssize_t frequency_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	int ret;
+	uint8_t val;
+	struct regulator_dev *rdev;
+	struct axp_regulator_info *info;
+	struct axp_regmap *regmap;
+
+	rdev = container_of(dev, struct regulator_dev, dev);
+	info = rdev_get_drvdata(rdev);
+	regmap = info->regmap;
+
+	ret = axp_regmap_read(regmap, info->freq_reg, &val);
+	if (ret)
+		return ret;
+
+	ret = val & 0x0F;
+
+	return sprintf(buf, "%d\n", (ret * 5 + 50));
+}
+
+static ssize_t frequency_store(struct device *dev,
+				struct device_attribute *attr,
+				const char *buf, size_t count)
+{
+	uint8_t val, tmp;
+	int var, err;
+	struct regulator_dev *rdev;
+	struct axp_regulator_info *info;
+	struct axp_regmap *regmap;
+
+	rdev = container_of(dev, struct regulator_dev, dev);
+	info = rdev_get_drvdata(rdev);
+	regmap = info->regmap;
+
+	err = kstrtoint(buf, 10, &var);
+	if (err)
+		return err;
+
+	if (var < 50)
+		var = 50;
+
+	if (var > 100)
+		var = 100;
+
+	val = (var - 50) / 5;
+	val &= 0x0F;
+
+	axp_regmap_read(regmap, info->freq_reg, &tmp);
+	tmp &= 0xF0;
+	val |= tmp;
+	axp_regmap_write(regmap, info->freq_reg, val);
+
+	return count;
+}
+
+static struct device_attribute axp_regulator_attrs[] = {
+	AXP_REGULATOR_ATTR(workmode),
+	AXP_REGULATOR_ATTR(frequency),
+};
+
+int axp_regulator_create_attrs(struct device *dev)
+{
+	int j, ret;
+
+	for (j = 0; j < ARRAY_SIZE(axp_regulator_attrs); j++) {
+		ret = device_create_file(dev, &axp_regulator_attrs[j]);
+		if (ret)
+			goto sysfs_failed;
+	}
+
+	return 0;
+
+sysfs_failed:
+	while (j--)
+		device_remove_file(dev, &axp_regulator_attrs[j]);
+	return ret;
+}
+
+MODULE_DESCRIPTION("ALLWINNERTECH axp regulator");
+MODULE_AUTHOR("pannan");
+MODULE_LICENSE("GPL");

--- a/drivers/power/supply/axp/axp-regulator.h	1969-12-31 19:00:00.000000000 -0500
+++ b/drivers/power/supply/axp/axp-regulator.h	2022-09-01 10:46:35.786464423 -0400
@@ -0,0 +1,304 @@
+/*
+ * drivers/power/axp/axp-regulator.h
+ * (C) Copyright 2010-2016
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * Pannan <pannan@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ */
+
+#ifndef AXP_REGULATOR_H
+#define AXP_REGULATOR_H
+
+#include <linux/regulator/driver.h>
+#include <linux/regulator/machine.h>
+
+struct  axp_reg_init {
+	struct regulator_init_data axp_reg_init_data;
+	struct axp_regulator_info *info;
+};
+
+/* The values of the various regulator constraints are obviously dependent
+ * on exactly what is wired to each ldo.  Unfortunately this information is
+ * not generally available.  More information has been requested from Xbow
+ * but as of yet they haven't been forthcoming.
+ *
+ * Some of these are clearly Stargate 2 related (no way of plugging
+ * in an lcd on the IM2 for example!).
+ */
+
+struct axp_consumer_supply {
+	char supply[20];    /* consumer supply - e.g. "vcc" */
+};
+
+#define AXP_LDOIO_ID_START      30
+#define AXP_DCDC_ID_START       40
+
+#define AXP_LDO(_pmic, _id, min, max, step1, vreg, shift, nbits, ereg,\
+	emask, enval, disval, switch_vol, step2, new_level,\
+	mode_addr, freq_addr, dvm_ereg, dvm_ebit, dvm_flag)\
+{                                                      \
+	.desc   = {                                        \
+		.name   = #_pmic"_LDO" #_id,                   \
+		.type   = REGULATOR_VOLTAGE,                   \
+		.id = _pmic##_ID_LDO##_id,                     \
+		.n_voltages = (step1) ? ((switch_vol) ?        \
+				((new_level) ? ((switch_vol - min) / step1 + \
+				(max - new_level) / step2 + 2)         \
+				: ((switch_vol - min) / step1 +        \
+				(max - switch_vol) / step2 + 1)) :     \
+				((max - min) / step1 + 1)) : 1,        \
+		.owner  = THIS_MODULE,                         \
+		.enable_reg  = _pmic##_##ereg,                 \
+		.enable_mask = emask,                          \
+	},                                                 \
+	.min_uv     = (min) * 1000,                        \
+	.max_uv     = (max) * 1000,                        \
+	.enable_val  = enval,                              \
+	.disable_val = disval,                             \
+	.step1_uv   = (step1) * 1000,                      \
+	.vol_reg    = _pmic##_##vreg,                      \
+	.vol_shift  = (shift),                             \
+	.vol_nbits  = (nbits),                             \
+	.switch_uv  = (switch_vol)*1000,                   \
+	.step2_uv   = (step2)*1000,                        \
+	.new_level_uv   = (new_level)*1000,                \
+	.mode_reg   = mode_addr,                           \
+	.freq_reg   = freq_addr,                           \
+	.dvm_enable_reg = dvm_ereg,                        \
+	.dvm_enable_bit = dvm_ebit,                        \
+	.dvm_finish_flag = dvm_flag,                       \
+}
+
+#define AXP_DCDC(_pmic, _id, min, max, step1, vreg, shift, nbits, ereg,\
+	emask, enval, disval, switch_vol, step2, new_level,\
+	mode_addr, mode_bit, freq_addr, dvm_ereg, dvm_ebit, dvm_flag)\
+{                                                      \
+	.desc   = {                                        \
+		.name   = #_pmic"_DCDC" #_id,                  \
+		.type   = REGULATOR_VOLTAGE,                   \
+		.id = _pmic##_ID_DCDC##_id,                    \
+		.n_voltages = (step1) ? ((switch_vol) ?        \
+				((new_level) ? ((switch_vol - min) / step1 + \
+				(max - new_level) / step2 + 2)         \
+				: ((switch_vol - min) / step1 +        \
+				(max - switch_vol) / step2 + 1)) :     \
+				((max - min) / step1 + 1)) : 1,        \
+		.owner  = THIS_MODULE,                         \
+		.enable_reg  = _pmic##_##ereg,                 \
+		.enable_mask = emask,                          \
+	},                                                 \
+	.min_uv     = (min) * 1000,                        \
+	.max_uv     = (max) * 1000,                        \
+	.enable_val  = enval,                              \
+	.disable_val = disval,                             \
+	.step1_uv   = (step1) * 1000,                      \
+	.vol_reg    = _pmic##_##vreg,                      \
+	.vol_shift  = (shift),                             \
+	.vol_nbits  = (nbits),                             \
+	.switch_uv  = (switch_vol)*1000,                   \
+	.step2_uv   = (step2)*1000,                        \
+	.new_level_uv   = (new_level)*1000,                \
+	.mode_reg   = mode_addr,                           \
+	.mode_mask  = mode_bit,                            \
+	.freq_reg   = freq_addr,                           \
+	.dvm_enable_reg = dvm_ereg,                        \
+	.dvm_enable_bit = dvm_ebit,                        \
+	.dvm_finish_flag = dvm_flag,                       \
+}
+
+
+#define AXP_SW(_pmic, _id, min, max, step1, vreg, shift, nbits, ereg,\
+	emask, enval, disval, switch_vol, step2, new_level,\
+	mode_addr, freq_addr, dvm_ereg, dvm_ebit, dvm_flag)\
+{                                                      \
+	.desc   = {                                        \
+		.name   = #_pmic"_SW" #_id,                    \
+		.type   = REGULATOR_VOLTAGE,                   \
+		.id = _pmic##_ID_SW##_id,                      \
+		.n_voltages = (step1) ? ((switch_vol) ?        \
+				((new_level) ? ((switch_vol - min) / step1 + \
+				(max - new_level) / step2 + 2)         \
+				: ((switch_vol - min) / step1 +        \
+				(max - switch_vol) / step2 + 1)) :     \
+				((max - min) / step1 + 1)) : 1,        \
+		.owner  = THIS_MODULE,                         \
+		.enable_reg  = _pmic##_##ereg,                 \
+		.enable_mask = emask,                          \
+	},                                                 \
+	.min_uv     = (min) * 1000,                        \
+	.max_uv     = (max) * 1000,                        \
+	.step1_uv   = (step1) * 1000,                      \
+	.enable_val  = enval,                              \
+	.disable_val = disval,                             \
+	.vol_reg    = _pmic##_##vreg,                      \
+	.vol_shift  = (shift),                             \
+	.vol_nbits  = (nbits),                             \
+	.switch_uv  = (switch_vol)*1000,                   \
+	.step2_uv   = (step2)*1000,                        \
+	.new_level_uv   = (new_level)*1000,                \
+	.mode_reg   = mode_addr,                           \
+	.freq_reg   = freq_addr,                           \
+	.dvm_enable_reg = dvm_ereg,                        \
+	.dvm_enable_bit = dvm_ebit,                        \
+	.dvm_finish_flag = dvm_flag,                       \
+}
+
+#define AXP_LDO_SEL(_pmic, _id, min, max, vreg, shift, nbits, ereg,\
+	emask, enval, disval, table_name,\
+	mode_addr, freq_addr, dvm_ereg, dvm_ebit, dvm_flag)\
+{                                                      \
+	.desc   = {                                        \
+		.name   = #_pmic"_LDO" #_id,                   \
+		.type   = REGULATOR_VOLTAGE,                   \
+		.id = _pmic##_ID_LDO##_id,                     \
+		.n_voltages = ARRAY_SIZE(table_name##_table),  \
+		.owner  = THIS_MODULE,                         \
+		.enable_reg  = _pmic##_##ereg,                 \
+		.enable_mask = emask,                          \
+	},                                                 \
+	.min_uv     = (min) * 1000,                        \
+	.max_uv     = (max) * 1000,                        \
+	.enable_val  = enval,                              \
+	.disable_val = disval,                             \
+	.vol_reg    = _pmic##_##vreg,                      \
+	.vol_shift  = (shift),                             \
+	.vol_nbits  = (nbits),                             \
+	.mode_reg   = mode_addr,                           \
+	.freq_reg   = freq_addr,                           \
+	.dvm_enable_reg = dvm_ereg,                        \
+	.dvm_enable_bit = dvm_ebit,                        \
+	.dvm_finish_flag = dvm_flag,                       \
+	.vtable         = (int *)&table_name##_table,      \
+}
+
+#define AXP_DCDC_SEL(_pmic, _id, min, max, vreg, shift, nbits, ereg,\
+	emask, enval, disval, table_name,\
+	mode_addr, mode_bit, freq_addr, dvm_ereg, dvm_ebit, dvm_flag)\
+{                                                      \
+	.desc   = {                                        \
+		.name   = #_pmic"_DCDC" #_id,                  \
+		.type   = REGULATOR_VOLTAGE,                   \
+		.id = _pmic##_ID_DCDC##_id,                    \
+		.n_voltages = ARRAY_SIZE(table_name##_table),  \
+		.owner  = THIS_MODULE,                         \
+		.enable_reg  = _pmic##_##ereg,                 \
+		.enable_mask = emask,                          \
+	},                                                 \
+	.min_uv     = (min) * 1000,                        \
+	.max_uv     = (max) * 1000,                        \
+	.enable_val  = enval,                              \
+	.disable_val = disval,                             \
+	.vol_reg    = _pmic##_##vreg,                      \
+	.vol_shift  = (shift),                             \
+	.vol_nbits  = (nbits),                             \
+	.mode_reg   = mode_addr,                           \
+	.mode_mask  = mode_bit,                            \
+	.freq_reg   = freq_addr,                           \
+	.dvm_enable_reg = dvm_ereg,                        \
+	.dvm_enable_bit = dvm_ebit,                        \
+	.dvm_finish_flag = dvm_flag,                       \
+	.vtable         = (int *)&table_name##_table,      \
+}
+
+
+#define AXP_SW_SEL(_pmic, _id, min, max, vreg, shift, nbits, ereg,\
+	emask, enval, disval, table_name,\
+	mode_addr, freq_addr, dvm_ereg, dvm_ebit, dvm_flag)\
+{                                                      \
+	.desc   = {                                        \
+		.name   = #_pmic"_SW" #_id,                    \
+		.type   = REGULATOR_VOLTAGE,                   \
+		.id = _pmic##_ID_SW##_id,                      \
+		.n_voltages = ARRAY_SIZE(table_name##_table),  \
+		.owner  = THIS_MODULE,                         \
+		.enable_reg  = _pmic##_##ereg,                 \
+		.enable_mask = emask,                          \
+	},                                                 \
+	.min_uv     = (min) * 1000,                        \
+	.max_uv     = (max) * 1000,                        \
+	.enable_val  = enval,                              \
+	.disable_val = disval,                             \
+	.vol_reg    = _pmic##_##vreg,                      \
+	.vol_shift  = (shift),                             \
+	.vol_nbits  = (nbits),                             \
+	.mode_reg   = mode_addr,                           \
+	.freq_reg   = freq_addr,                           \
+	.dvm_enable_reg = dvm_ereg,                        \
+	.dvm_enable_bit = dvm_ebit,                        \
+	.dvm_finish_flag = dvm_flag,                       \
+	.vtable          = (int *)&table_name##_table,     \
+}
+
+#define AXP_REGULATOR_ATTR(_name)                          \
+{                                                          \
+	.attr = { .name = #_name, .mode = 0644 },          \
+	.show =  _name##_show,                             \
+	.store = _name##_store,                            \
+}
+
+struct axp_regulator_info {
+	struct regulator_desc desc;
+	struct axp_regmap *regmap;
+	s32 min_uv;
+	s32 max_uv;
+	s32 enable_val;
+	s32 disable_val;
+	s32 step1_uv;
+	s32 vol_reg;
+	s32 vol_shift;
+	s32 vol_nbits;
+	s32 switch_uv;
+	s32 step2_uv;
+	s32 new_level_uv;
+	s32 mode_reg;
+	s32 mode_mask;
+	s32 freq_reg;
+	s32 dvm_enable_reg;
+	s32 dvm_enable_bit;
+	s32 dvm_finish_flag;
+	s32 *vtable;
+	s32 pmu_num;
+};
+
+struct regulator {
+	struct device *dev;
+	struct list_head list;
+	unsigned int always_on:1;
+	unsigned int bypass:1;
+	int uA_load;
+	int min_uV;
+	int max_uV;
+	char *supply_name;
+	struct device_attribute dev_attr;
+	struct regulator_dev *rdev;
+	struct dentry *debugfs;
+};
+
+typedef struct {
+	unsigned int mem_data;
+	char id_name[20];
+} axp_mem_data_t;
+
+struct regulator_dev *axp_regulator_register(struct device *dev,
+				struct axp_regmap *regmap,
+				struct regulator_init_data *init_data,
+				struct axp_regulator_info *info);
+struct regulator_dev *axp_regulator_sel_register(struct device *dev,
+				struct axp_regmap *regmap,
+				struct regulator_init_data *init_data,
+				struct axp_regulator_info *info);
+void axp_regulator_unregister(struct regulator_dev *rdev);
+s32 axp_regulator_dt_parse(struct device_node *node,
+				struct regulator_init_data *axp_init_data,
+				s32 (*get_dep_cb)(const char *));
+int axp_get_ldo_count(struct device_node *node, u32 *ldo_count);
+int axp_mem_regu_init(struct device_node *node,
+				axp_mem_data_t *regu_list, u32 ldo_count);
+int axp_regulator_create_attrs(struct device *dev);
+
+#endif /* AXP_REGULATOR_H */

--- a/drivers/power/supply/axp/axp-sysfs.c	1969-12-31 19:00:00.000000000 -0500
+++ b/drivers/power/supply/axp/axp-sysfs.c	2022-09-01 10:46:35.786464423 -0400
@@ -0,0 +1,374 @@
+/*
+ * drivers/power/axp/axp-sysfs.c
+ * (C) Copyright 2010-2016
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * Pannan <pannan@allwinnertech.com>
+ *
+ * axp sysfs for users
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ */
+
+#include "axp-core.h"
+
+static int axp_num;
+
+static ssize_t axp_num_show(struct class *class,
+				struct class_attribute *attr, char *buf)
+{
+	return sprintf(buf, "pmuhahaah%d\n", axp_num);
+}
+
+static ssize_t axp_num_store(struct class *class,
+				struct class_attribute *attr,
+				const char *buf, size_t count)
+{
+	int val, err;
+
+	err = kstrtoint(buf, 16, &val);
+	if (err)
+		return err;
+
+	axp_num = val;
+	if ((axp_num >= AXP_ONLINE_SUM) || (axp_num < 0))
+		return -EINVAL;
+
+	return count;
+}
+
+static ssize_t axp_name_show(struct class *class,
+				struct class_attribute *attr, char *buf)
+{
+	return sprintf(buf, "%s\n", get_pmu_cur_name(axp_num));
+}
+
+static u8 axp_reg_addr;
+
+static ssize_t axp_reg_show(struct class *class,
+				struct class_attribute *attr, char *buf)
+{
+	u8 val;
+	struct axp_dev *cur_axp_dev = get_pmu_cur_dev(axp_num);
+
+	if (cur_axp_dev == NULL)
+		return sprintf(buf, "invalid parameters\n");
+
+	if (cur_axp_dev->is_dummy)
+		return sprintf(buf, "unsupported\n");
+
+	axp_regmap_read(cur_axp_dev->regmap, axp_reg_addr, &val);
+	return sprintf(buf, "%s:REG[0x%x]=0x%x\n",
+				get_pmu_cur_name(axp_num), axp_reg_addr, val);
+}
+
+static ssize_t axp_reg_store(struct class *class,
+				struct class_attribute *attr,
+				const char *buf, size_t count)
+{
+	s32 tmp;
+	u8 val;
+	int err;
+	struct axp_dev *cur_axp_dev = get_pmu_cur_dev(axp_num);
+
+	if (cur_axp_dev == NULL) {
+		pr_warn("invalid parameters\n");
+		return -EINVAL;
+	}
+
+	if (cur_axp_dev->is_dummy) {
+		pr_err("unsupported\n");
+		return -EINVAL;
+	}
+
+	err = kstrtoint(buf, 16, &tmp);
+	if (err)
+		return err;
+
+	if (tmp < 256) {
+		axp_reg_addr = tmp;
+	} else {
+		val = tmp & 0x00FF;
+		axp_reg_addr = (tmp >> 8) & 0x00FF;
+		axp_regmap_write(cur_axp_dev->regmap, axp_reg_addr, val);
+	}
+
+	return count;
+}
+
+static u32 axp_regs_data_size = 2;
+static ssize_t axp_regs_show(struct class *class,
+				struct class_attribute *attr, char *buf)
+{
+	u8 val;
+	s32 count = 0, i = 0;
+	struct axp_dev *cur_axp_dev = get_pmu_cur_dev(axp_num);
+
+	if (cur_axp_dev == NULL)
+		return sprintf(buf, "invalid parameters\n");
+
+	if (cur_axp_dev->is_dummy)
+		return sprintf(buf, "unsupported\n");
+
+	for (i = 0; i < axp_regs_data_size; i++) {
+		axp_regmap_read(cur_axp_dev->regmap, axp_reg_addr+i, &val);
+		count += sprintf(buf+count, "%s:REG[0x%x]=0x%x\n",
+				get_pmu_cur_name(axp_num), axp_reg_addr+i, val);
+	}
+
+	return count;
+}
+
+static ssize_t axp_regs_store(struct class *class,
+				struct class_attribute *attr,
+				const char *buf, size_t count)
+{
+	u32 data1 = 0;
+	u8 val[2];
+	char *endp;
+	struct axp_dev *cur_axp_dev = get_pmu_cur_dev(axp_num);
+
+	if (cur_axp_dev == NULL) {
+		pr_warn("invalid parameters\n");
+		return -EINVAL;
+	}
+
+	if (cur_axp_dev->is_dummy) {
+		pr_err("unsupported\n");
+		return -EINVAL;
+	}
+
+	data1 = simple_strtoul(buf, &endp, 16);
+	if (*endp != ' ') {
+		pr_err("%s: %d\n", __func__, __LINE__);
+		return -EINVAL;
+	}
+
+	buf = endp + 1;
+	axp_regs_data_size = simple_strtoul(buf, &endp, 10);
+
+	if (data1 < 256) {
+		axp_reg_addr = data1;
+	} else {
+		axp_reg_addr = (data1 >> 16) & 0xFF;
+		val[0] = (data1 >> 8) & 0xFF;
+		val[1] = data1 & 0xFF;
+		axp_regmap_writes(cur_axp_dev->regmap, axp_reg_addr, 2, val);
+	}
+
+	return count;
+}
+
+int axp_debug_mask;
+
+static ssize_t debugmask_store(struct class *class,
+				struct class_attribute *attr,
+				const char *buf, size_t count)
+{
+	int val, err;
+
+	err = kstrtoint(buf, 16, &val);
+	if (err)
+		return err;
+
+	axp_debug_mask = val;
+
+	return count;
+}
+
+static ssize_t debugmask_show(struct class *class,
+				struct class_attribute *attr, char *buf)
+{
+	char *s = buf;
+	char *end = (char *)((ptrdiff_t)buf + (ptrdiff_t)PAGE_SIZE);
+
+	s += scnprintf(s, end - s, "%s\n", "1: SPLY 2: REGU 4: INT 8: CHG");
+	s += scnprintf(s, end - s, "debug_mask=%d\n", axp_debug_mask);
+
+	return s - buf;
+}
+#if 0
+static ssize_t add_sys_store(struct class *class,
+				struct class_attribute *attr,
+				const char *buf, size_t count)
+{
+	int name_len;
+	const char *arg;
+	char sys_name[20] = {0};
+
+	/* Find length of lock name */
+	arg = buf;
+	while (*arg && !isspace(*arg))
+		arg++;
+
+	name_len = arg - buf;
+	if ((!name_len) && (name_len > 20))
+		goto bad_arg;
+
+	strncpy(sys_name, buf, name_len);
+	axp_add_sys_pwr_dm(sys_name);
+
+	return count;
+
+bad_arg:
+	pr_err("%s para error.\n", __func__);
+	return count;
+}
+
+static ssize_t del_sys_store(struct class *class,
+				struct class_attribute *attr,
+				const char *buf, size_t count)
+{
+	int name_len;
+	const char *arg;
+	char sys_name[20] = {0};
+
+	/* Find length of lock name */
+	arg = buf;
+	while (*arg && !isspace(*arg))
+		arg++;
+
+	name_len = arg - buf;
+	if ((!name_len) && (name_len > 20))
+		goto bad_arg;
+
+	strncpy(sys_name, buf, name_len);
+	axp_del_sys_pwr_dm(sys_name);
+
+	return count;
+
+bad_arg:
+	pr_err("%s para error.\n", __func__);
+	return count;
+}
+
+static ssize_t get_sys_show(struct class *class,
+				struct class_attribute *attr, char *buf)
+{
+	ssize_t count = 0;
+
+	count += sprintf(buf+count, "0x%x\n", axp_get_sys_pwr_dm_mask());
+	return count;
+}
+
+char check_sys_name[20] = {0};
+
+static ssize_t check_sys_store(struct class *class,
+				struct class_attribute *attr,
+				const char *buf, size_t count)
+{
+	int name_len;
+	const char *arg;
+
+	/* Find length of lock name */
+	arg = buf;
+	while (*arg && !isspace(*arg))
+		arg++;
+
+	name_len = arg - buf;
+	if ((!name_len) && (name_len > 20))
+		goto bad_arg;
+
+	strncpy(check_sys_name, buf, name_len);
+
+	return count;
+
+bad_arg:
+	pr_err("%s para error.\n", __func__);
+	return count;
+}
+
+static ssize_t check_sys_show(struct class *class,
+				struct class_attribute *attr, char *buf)
+{
+	s32 sys_id_conut = 0, ret = 0;
+	ssize_t count = 0;
+	char ldo_name[20] = {0};
+
+	if (check_sys_name == NULL) {
+		pr_err("please input sys name\n");
+		return -1;
+	}
+
+	sys_id_conut = axp_check_sys_id(check_sys_name);
+	if (sys_id_conut < 0) {
+		pr_err("%s: %s not sys id.\n", __func__, check_sys_name);
+		return -1;
+	}
+
+	ret = axp_get_ldo_name(check_sys_name, (char *)&ldo_name);
+	if (ret < 0) {
+		pr_err("%s: get ldo name for id: %s failed\n",
+				__func__, check_sys_name);
+		return -1;
+	}
+
+	ret = axp_is_sys_pwr_dm_active(sys_id_conut);
+	count += sprintf(buf+count, "%d\n", ret);
+
+	return count;
+}
+#endif
+static struct class_attribute axp_class_attrs[] = {
+	__ATTR(axp_name,      S_IRUGO,         axp_name_show,  NULL),
+	__ATTR(axp_num,       S_IRUGO|S_IWUSR, axp_num_show,   axp_num_store),
+	__ATTR(axp_reg,       S_IRUGO|S_IWUSR, axp_reg_show,   axp_reg_store),
+	__ATTR(axp_regs,      S_IRUGO|S_IWUSR, axp_regs_show,  axp_regs_store),
+	__ATTR(debug_mask,    S_IRUGO|S_IWUSR, debugmask_show, debugmask_store),
+#if 0
+	__ATTR(sys_pwr_add,   S_IWUSR,         NULL,           add_sys_store),
+	__ATTR(sys_pwr_del,   S_IWUSR,         NULL,           del_sys_store),
+	__ATTR(sys_pwr_get,   S_IRUGO,         get_sys_show,   NULL),
+	__ATTR(sys_pwr_check, S_IRUGO|S_IWUSR, check_sys_show, check_sys_store),
+#endif
+	__ATTR_NULL
+};
+
+struct class axp_class = {
+	.name = "axp",
+	.class_attrs = axp_class_attrs,
+};
+
+#ifdef CONFIG_AXP_TWI_USED
+#include <linux/reboot.h>
+#include <linux/cpufreq.h>
+
+static int axp_reboot_notifier_call(struct notifier_block *this,
+				unsigned long code, void *_cmd)
+{
+	disable_cpufreq();
+	return NOTIFY_DONE;
+}
+
+static struct notifier_block axp_reboot_notifier = {
+	.notifier_call = axp_reboot_notifier_call,
+};
+#endif
+
+static int __init axp_sysfs_init(void)
+{
+	int status;
+#ifdef CONFIG_AXP_TWI_USED
+	register_reboot_notifier(&axp_reboot_notifier);
+#endif
+
+	status = class_register(&axp_class);
+	if (status < 0)
+		pr_err("%s,%d err, status:%d\n", __func__, __LINE__, status);
+
+	return status;
+}
+arch_initcall(axp_sysfs_init);
+
+static void __exit axp_sysfs_exit(void)
+{
+	class_unregister(&axp_class);
+}
+module_exit(axp_sysfs_exit);
+
+MODULE_DESCRIPTION("ALLWINNERTECH axp sysfs");
+MODULE_AUTHOR("pannan");
+MODULE_LICENSE("GPL");

--- a/drivers/power/supply/axp/axp-virtual.c	1969-12-31 19:00:00.000000000 -0500
+++ b/drivers/power/supply/axp/axp-virtual.c	2022-09-01 10:46:35.786464423 -0400
@@ -0,0 +1,268 @@
+/*
+ * drivers/power/axp/axp-virtual.c
+ * (C) Copyright 2010-2016
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * Pannan <pannan@allwinnertech.com>
+ *
+ * virtual driver of axp
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ */
+
+#include <linux/regulator/driver.h>
+#include <linux/platform_device.h>
+#include "axp-virtual.h"
+
+static void update_voltage_constraints(struct virtual_consumer_data *data)
+{
+	int ret = 0;
+	struct regulator *regu;
+
+	regu = regulator_get(NULL, data->regu_name);
+	if (IS_ERR(regu)) {
+		pr_err("%s: regulator get %s failed\n",
+				__func__, data->regu_name);
+		return;
+	}
+
+	if (data->min_uv && data->max_uv && data->min_uv <= data->max_uv) {
+		ret = regulator_set_voltage(regu, data->min_uv, data->max_uv);
+		if (ret != 0) {
+			pr_err("regulator_set_voltage() failed: %d\n", ret);
+			return;
+		}
+	}
+
+	if (data->min_uv && data->max_uv) {
+		ret = regu->rdev->desc->ops->enable(regu->rdev);
+		if (ret != 0)
+			pr_err("regulator_enable() failed: %d\n", ret);
+	}
+
+	if (!(data->min_uv && data->max_uv)) {
+		ret = regu->rdev->desc->ops->disable(regu->rdev);
+		if (ret != 0)
+			pr_err("regulator_disable() failed: %d\n", ret);
+	}
+
+	regulator_put(regu);
+}
+
+static void update_current_limit_constraints(struct virtual_consumer_data *data)
+{
+	int ret;
+	struct regulator *regu;
+
+	regu = regulator_get(NULL, data->regu_name);
+	if (IS_ERR(regu)) {
+		pr_err("%s: regulator get %s failed\n",
+				__func__, data->regu_name);
+		return;
+	}
+
+	if (data->max_ua && data->min_ua <= data->max_ua) {
+		ret = regulator_set_current_limit(regu,
+				data->min_ua, data->max_ua);
+		if (ret != 0) {
+			pr_err("regulator_set_current_limit failed\n");
+			return;
+		}
+	}
+
+	if (data->max_ua && !data->enabled) {
+		ret = regulator_enable(regu);
+		if (ret == 0)
+			data->enabled = 1;
+		else
+			pr_err("regulator_enable() failed: %d\n", ret);
+	}
+
+	if (!(data->min_ua && data->max_ua) && data->enabled) {
+		ret = regulator_disable(regu);
+		if (ret == 0)
+			data->enabled = 0;
+		else
+			pr_err("regulator_disable() failed: %d\n", ret);
+	}
+
+	regulator_put(regu);
+}
+
+static ssize_t show_min_uv(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	struct virtual_consumer_data *data = dev_get_drvdata(dev);
+	struct regulator *regu;
+
+	regu = regulator_get(NULL, data->regu_name);
+	if (IS_ERR(regu))
+		return sprintf(buf, "%s: failed\n", __func__);
+
+	data->min_uv = regulator_get_voltage(regu);
+	regulator_put(regu);
+
+	return sprintf(buf, "%d\n", data->min_uv);
+}
+
+static ssize_t set_min_uv(struct device *dev, struct device_attribute *attr,
+					const char *buf, size_t count)
+{
+	struct virtual_consumer_data *data = dev_get_drvdata(dev);
+	int val, err;
+
+	err = kstrtoint(buf, 10, &val);
+	if (err)
+		return err;
+
+	data->max_uv = (data->max_uv >= data->min_uv) ?
+		data->max_uv : data->min_uv;
+
+	mutex_lock(&data->lock);
+	data->min_uv = val;
+	update_voltage_constraints(data);
+	mutex_unlock(&data->lock);
+
+	return count;
+}
+
+static ssize_t show_max_uv(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	struct virtual_consumer_data *data = dev_get_drvdata(dev);
+
+	return sprintf(buf, "%d\n", data->max_uv);
+}
+
+static ssize_t set_max_uv(struct device *dev, struct device_attribute *attr,
+					const char *buf, size_t count)
+{
+	struct virtual_consumer_data *data = dev_get_drvdata(dev);
+	struct regulator *regu;
+	int val, err;
+
+	err = kstrtoint(buf, 10, &val);
+	if (err)
+		return err;
+
+	regu = regulator_get(NULL, data->regu_name);
+	if (IS_ERR(regu))
+		return (long)regu;
+
+	data->min_uv = regulator_get_voltage(regu);
+
+	mutex_lock(&data->lock);
+	data->max_uv = val;
+	update_voltage_constraints(data);
+	mutex_unlock(&data->lock);
+
+	return count;
+}
+
+static ssize_t show_min_ua(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	struct virtual_consumer_data *data = dev_get_drvdata(dev);
+
+	return sprintf(buf, "%d\n", data->min_ua);
+}
+
+static ssize_t set_min_ua(struct device *dev, struct device_attribute *attr,
+					const char *buf, size_t count)
+{
+	struct virtual_consumer_data *data = dev_get_drvdata(dev);
+	int val, err;
+
+	err = kstrtoint(buf, 10, &val);
+	if (err)
+		return err;
+
+	mutex_lock(&data->lock);
+	data->min_ua = val;
+	update_current_limit_constraints(data);
+	mutex_unlock(&data->lock);
+
+	return count;
+}
+
+static ssize_t show_max_ua(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	struct virtual_consumer_data *data = dev_get_drvdata(dev);
+
+	return sprintf(buf, "%d\n", data->max_ua);
+}
+
+static ssize_t set_max_ua(struct device *dev, struct device_attribute *attr,
+					const char *buf, size_t count)
+{
+	struct virtual_consumer_data *data = dev_get_drvdata(dev);
+	int val, err;
+
+	err = kstrtoint(buf, 10, &val);
+	if (err)
+		return err;
+
+	mutex_lock(&data->lock);
+	data->max_ua = val;
+	update_current_limit_constraints(data);
+	mutex_unlock(&data->lock);
+
+	return count;
+}
+
+static DEVICE_ATTR(min_microvolts, 0644, show_min_uv, set_min_uv);
+static DEVICE_ATTR(max_microvolts, 0644, show_max_uv, set_max_uv);
+static DEVICE_ATTR(min_microamps,  0644, show_min_ua, set_min_ua);
+static DEVICE_ATTR(max_microamps,  0644, show_max_ua, set_max_ua);
+
+struct device_attribute *attributes_virtual[] = {
+	&dev_attr_min_microvolts,
+	&dev_attr_max_microvolts,
+	&dev_attr_min_microamps,
+	&dev_attr_max_microamps,
+};
+
+int axp_add_virtual_regulator_devices(struct platform_device *pdev, int size,
+				struct axp_virtual_dev_mapping *mapping)
+{
+	int i, j, ret = 0;
+
+	for (i = 0; i < size; i++) {
+		pdev[i].name = mapping[i].device_name;
+		pdev[i].id = -1;
+		pdev[i].dev.platform_data = mapping[i].regulator_name;
+		ret = platform_device_register(&pdev[i]);
+		if (ret)
+			goto failed;
+	}
+
+	return 0;
+
+failed:
+	for (j = i - 1; j >= 0; j--)
+		platform_device_unregister(&pdev[j]);
+
+	return ret;
+}
+
+void axp_init_virtual_regulator_drivers(struct platform_driver *pdrv, int size,
+				struct axp_virtual_dev_mapping *mapping,
+				int (*_probe)(struct platform_device *),
+				int (*_remove)(struct platform_device *))
+{
+	int i;
+
+	for (i = 0; i < size; i++) {
+		pdrv[i].probe  = _probe;
+		pdrv[i].remove = _remove;
+		pdrv[i].driver.name = mapping[i].device_name;
+	}
+}
+
+MODULE_DESCRIPTION("Virtual regulator driver of axp");
+MODULE_AUTHOR("pannan");
+MODULE_LICENSE("GPL");

--- a/drivers/power/supply/axp/axp-virtual.h	1969-12-31 19:00:00.000000000 -0500
+++ b/drivers/power/supply/axp/axp-virtual.h	2022-09-01 10:46:35.786464423 -0400
@@ -0,0 +1,59 @@
+/*
+ * drivers/power/axp/axp-virtual.h
+ * (C) Copyright 2010-2016
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * Pannan <pannan@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ */
+
+#include <linux/platform_device.h>
+#include "axp-core.h"
+
+struct axp_virtual_dev_mapping {
+	char device_name[32];
+	char regulator_name[32];
+};
+
+/*
+ * struct regulator
+ *
+ * One for each consumer device.
+ */
+struct regulator {
+	struct device *dev;
+	struct list_head list;
+	unsigned int always_on:1;
+	unsigned int bypass:1;
+	int ua_load;
+	int min_uv;
+	int max_uv;
+	char *supply_name;
+	struct device_attribute dev_attr;
+	struct regulator_dev *rdev;
+	struct dentry *debugfs;
+};
+
+struct virtual_consumer_data {
+	struct mutex lock;
+	int enabled;
+	int min_uv;
+	int max_uv;
+	int min_ua;
+	int max_ua;
+	char regu_name[16];
+};
+
+extern struct device_attribute *attributes_virtual[4];
+extern int axp_add_virtual_regulator_devices(struct platform_device *pdev,
+				int size,
+				struct axp_virtual_dev_mapping *mapping);
+extern void axp_init_virtual_regulator_drivers(struct platform_driver *pdrv,
+				int size,
+				struct axp_virtual_dev_mapping *mapping,
+				int (*_probe)(struct platform_device *),
+				int (*_remove)(struct platform_device *));

--- a/drivers/power/supply/axp/Kconfig	1969-12-31 19:00:00.000000000 -0500
+++ b/drivers/power/supply/axp/Kconfig	2022-09-01 10:51:01.721948799 -0400
@@ -0,0 +1,48 @@
+#menuconfig POWER_SUPPLY
+#	bool "Power supply class support"
+#	help
+#	  Say Y here to enable power supply class support. This allows
+#	  power supply (batteries, AC, USB) monitoring by userspace
+#	  via sysfs and uevent (if available) and/or APM kernel interface
+#	  (if selected below).
+#
+#if POWER_SUPPLY
+
+menuconfig AW_AXP
+	bool "AXP Power drivers"
+	depends on REGULATOR
+	#depends on ARCH_SUNXI
+	select MFD_CORE
+	help
+	  This option allows you to select AXP power driver
+
+if AW_AXP
+
+config AXP_TWI_USED
+	bool "AXP use twi as transfer channel"
+	depends on I2C
+	help
+	  To use twi as transfer channel
+
+config AXP_ARISC_TWI_USED
+	bool "AXP use arisc twi as transfer channel"
+	help
+	  To use arisc twi as transfer channel
+
+config DUAL_AXP_USED
+	bool "Support dual axp online"
+	depends on ARCH_SUN8IW10 || ARCH_SUN8IW15
+
+config AW_AXP2585
+	bool "AXP2585 driver"
+	#depends on ARCH_SUN8IW15
+	help
+	AXP2585 driver, AXP2585 is a BMU,which is just for battery power manager.
+	We could use a BMU and a PMU for high voltage project.The BMU is good
+	at manage battery, and the PMU could be a supplier of  periphrals.
+	Say Y here to enable AXP2585 driver.
+
+
+endif # AW_AXP
+
+#endif # POWER_SUPPLY

--- a/drivers/power/supply/axp/Makefile	1969-12-31 19:00:00.000000000 -0500
+++ b/drivers/power/supply/axp/Makefile	2022-09-01 10:51:09.849810781 -0400
@@ -0,0 +1,15 @@
+obj-$(CONFIG_AW_AXP) += axp-core.o
+obj-$(CONFIG_AW_AXP) += axp-sysfs.o
+obj-$(CONFIG_AW_AXP) += axp-virtual.o
+obj-$(CONFIG_AW_AXP) += axp-powerkey.o
+obj-$(CONFIG_AW_AXP) += axp-charger.o
+obj-$(CONFIG_AW_AXP) += axp-gpio.o
+obj-$(CONFIG_AW_AXP) += axp-regulator.o
+obj-$(CONFIG_AW_AXP) += nmi/sunxi-nmi.o
+
+#AXP2585
+obj-$(CONFIG_AW_AXP2585) += axp2585/axp2585.o
+obj-$(CONFIG_AW_AXP2585) += axp2585/axp2585-charger.o
+obj-$(CONFIG_AW_AXP2585) += axp2585/axp2585-powerkey.o
+
+

--- a/drivers/power/supply/axp/nmi/sunxi-nmi.c	1969-12-31 19:00:00.000000000 -0500
+++ b/drivers/power/supply/axp/nmi/sunxi-nmi.c	2022-09-01 10:46:35.786464423 -0400
@@ -0,0 +1,179 @@
+/*
+ * drivers/power/axp/nmi/sunxi-nmi.c
+ * (C) Copyright 2010-2016
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * Pannan <pannan@allwinnertech.com>
+ *
+ * driver of suxi nmi
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/of_platform.h>
+#include <linux/of_irq.h>
+#include <linux/of_address.h>
+#include <linux/io.h>
+#include <linux/slab.h>
+#ifdef CONFIG_SUNXI_ARISC
+#include <linux/arisc/arisc.h>
+#endif
+#include "sunxi-nmi.h"
+
+void sunxi_nmi_clear_status(void)
+{
+#ifdef CONFIG_SUNXI_ARISC
+	arisc_clear_nmi_status();
+#else
+	__clear_nmi_status();
+#endif
+}
+EXPORT_SYMBOL(sunxi_nmi_clear_status);
+
+void sunxi_nmi_enable(void)
+{
+#ifdef CONFIG_SUNXI_ARISC
+	arisc_enable_nmi_irq();
+#else
+	__enable_nmi_irq();
+#endif
+}
+EXPORT_SYMBOL(sunxi_nmi_enable);
+
+void sunxi_nmi_disable(void)
+{
+#ifdef CONFIG_SUNXI_ARISC
+	arisc_disable_nmi_irq();
+#else
+	__disable_nmi_irq();
+#endif
+}
+EXPORT_SYMBOL(sunxi_nmi_disable);
+
+void sunxi_nmi_set_trigger(u32 trigger)
+{
+	u32 tmp = 0;
+
+	if (IRQF_TRIGGER_LOW == trigger)
+		tmp = NMI_IRQ_LOW_LEVEL;
+	else if (IRQF_TRIGGER_FALLING == trigger)
+		tmp = NMI_IRQ_NE_EDGE;
+	else if (IRQF_TRIGGER_HIGH == trigger)
+		tmp = NMI_IRQ_HIGH_LEVEL;
+	else if (IRQF_TRIGGER_RISING == trigger)
+		tmp = NMI_IRQ_PO_EDGE;
+
+#ifdef CONFIG_SUNXI_ARISC
+	arisc_set_nmi_trigger(tmp);
+#else
+	__set_nmi_trigger(tmp);
+#endif
+}
+EXPORT_SYMBOL(sunxi_nmi_set_trigger);
+
+#ifndef CONFIG_SUNXI_ARISC
+static int sunxi_nmi_probe(struct platform_device *pdev)
+{
+	struct device_node *node = pdev->dev.of_node;
+	struct resource *mem_res = NULL;
+	s32 ret = 0;
+
+	if (!of_device_is_available(node)) {
+		pr_err("%s: nmi status disable!!\n", __func__);
+		return -EPERM;
+	}
+
+	nmi_data = kzalloc(sizeof(*nmi_data), GFP_KERNEL);
+	if (nmi_data == NULL) {
+		pr_err("%s: no memory for nmi data\n", __func__);
+		return -ENOMEM;
+	}
+
+	mem_res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (mem_res == NULL) {
+		pr_err("%s: failed to get MEM res\n", __func__);
+		ret = -ENXIO;
+		goto mem_io_err;
+	}
+
+	if (!request_mem_region(mem_res->start,
+				resource_size(mem_res), mem_res->name)) {
+		pr_err("%s: failed to request mem region\n", __func__);
+		ret = -EINVAL;
+		goto mem_io_err;
+	}
+
+	nmi_data->base_addr = ioremap(mem_res->start, resource_size(mem_res));
+	if (!nmi_data->base_addr) {
+		pr_err("%s: failed to io remap\n", __func__);
+		ret = -EIO;
+		goto mem_io_err;
+	}
+
+	if (of_property_read_u32(node, "nmi_irq_ctrl", &nmi_data->nmi_irq_ctrl))
+		goto of_property_err;
+
+	if (of_property_read_u32(node, "nmi_irq_en", &nmi_data->nmi_irq_en))
+		goto of_property_err;
+
+	if (of_property_read_u32(node, "nmi_irq_status",
+				&nmi_data->nmi_irq_status))
+		goto of_property_err;
+
+	return 0;
+
+of_property_err:
+	iounmap(nmi_data->base_addr);
+mem_io_err:
+	kfree(nmi_data);
+
+	return ret;
+}
+
+static int sunxi_nmi_remove(struct platform_device *pdev)
+{
+	pr_info("%s: module unloaded\n", __func__);
+
+	return 0;
+}
+
+static const struct of_device_id sunxi_nmi_match[] = {
+	{ .compatible = "allwinner,sunxi-nmi", },
+	{},
+};
+MODULE_DEVICE_TABLE(of, sunxi_nmi_match);
+
+static struct platform_driver nmi_platform_driver = {
+	.probe  = sunxi_nmi_probe,
+	.remove = sunxi_nmi_remove,
+	.driver = {
+		.name  = NMI_MODULE_NAME,
+		.owner = THIS_MODULE,
+		.of_match_table = sunxi_nmi_match,
+	},
+};
+
+static int __init sunxi_nmi_init(void)
+{
+	return platform_driver_register(&nmi_platform_driver);
+}
+arch_initcall(sunxi_nmi_init);
+
+static void __exit sunxi_nmi_exit(void)
+{
+	platform_driver_unregister(&nmi_platform_driver);
+}
+module_exit(sunxi_nmi_exit);
+
+MODULE_DESCRIPTION("Driver of nmi");
+MODULE_AUTHOR("pannan");
+MODULE_LICENSE("GPL");
+#endif

--- a/drivers/power/supply/axp/nmi/sunxi-nmi.h	1969-12-31 19:00:00.000000000 -0500
+++ b/drivers/power/supply/axp/nmi/sunxi-nmi.h	2022-09-01 10:46:35.786464423 -0400
@@ -0,0 +1,65 @@
+/*
+ * drivers/power/axp/nmi/sunxi-nmi.h
+ * (C) Copyright 2010-2016
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * Pannan <pannan@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ */
+
+#ifndef _SUNXI_NMI_H
+#define _SUNXI_NMI_H
+
+#define NMI_MODULE_NAME "nmi"
+
+#define NMI_IRQ_LOW_LEVEL       (0x0)
+#define NMI_IRQ_NE_EDGE         (0x1)
+#define NMI_IRQ_HIGH_LEVEL      (0x2)
+#define NMI_IRQ_PO_EDGE         (0x3)
+
+struct nmi_struct {
+	void __iomem *base_addr;
+	u32 nmi_irq_ctrl;
+	u32 nmi_irq_en;
+	u32 nmi_irq_status;
+};
+
+struct nmi_struct *nmi_data;
+
+static inline void __clear_nmi_status(void)
+{
+	if (nmi_data->base_addr)
+		writel(0x1, nmi_data->base_addr + nmi_data->nmi_irq_status);
+	else
+		pr_err("%s: para invalid\n", __func__);
+}
+
+static inline void __enable_nmi_irq(void)
+{
+	if (nmi_data->base_addr)
+		writel(0x1, nmi_data->base_addr + nmi_data->nmi_irq_en);
+	else
+		pr_err("%s: para invalid\n", __func__);
+}
+
+static inline void __disable_nmi_irq(void)
+{
+	if (nmi_data->base_addr)
+		writel(0x0, nmi_data->base_addr + nmi_data->nmi_irq_en);
+	else
+		pr_err("%s: para invalid\n", __func__);
+}
+
+static inline void __set_nmi_trigger(unsigned int value)
+{
+	if (nmi_data->base_addr)
+		writel(value, nmi_data->base_addr + nmi_data->nmi_irq_ctrl);
+	else
+		pr_err("%s: para invalid\n", __func__);
+}
+
+#endif /* _SUNXI_NMI_H */

--- a/drivers/power/supply/axp/sunxi-gpio.h	1969-12-31 19:00:00.000000000 -0500
+++ b/drivers/power/supply/axp/sunxi-gpio.h	2022-09-01 10:46:35.786464423 -0400
@@ -0,0 +1,201 @@
+/*
+ * include/linux/sunxi-gpio.h
+ *
+ * (C) Copyright 2015-2020
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * Wim Hwang <huangwei@allwinnertech.com>
+ *
+ * sunxi gpio utils
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ */
+
+#ifndef __SW_GPIO_H
+#define __SW_GPIO_H
+
+#define SUNXI_PINCTRL	"pio"
+#define SUNXI_R_PINCTRL	"r_pio"
+
+/* pin group base number name space,
+ * the max pin number : 26*32=832.
+ */
+#define SUNXI_BANK_SIZE 32
+#define SUNXI_PA_BASE	0
+#define SUNXI_PB_BASE	32
+#define SUNXI_PC_BASE	64
+#define SUNXI_PD_BASE	96
+#define SUNXI_PE_BASE	128
+#define SUNXI_PF_BASE	160
+#define SUNXI_PG_BASE	192
+#define SUNXI_PH_BASE	224
+#define SUNXI_PI_BASE	256
+#define SUNXI_PJ_BASE	288
+#define SUNXI_PK_BASE	320
+#define SUNXI_PL_BASE	352
+#define SUNXI_PM_BASE	384
+#define SUNXI_PN_BASE	416
+#define SUNXI_PO_BASE	448
+#define AXP_PIN_BASE	1024
+
+#define SUNXI_PIN_NAME_MAX_LEN	8
+
+/* sunxi gpio name space */
+#define GPIOA(n)	(SUNXI_PA_BASE + (n))
+#define GPIOB(n)	(SUNXI_PB_BASE + (n))
+#define GPIOC(n)	(SUNXI_PC_BASE + (n))
+#define GPIOD(n)	(SUNXI_PD_BASE + (n))
+#define GPIOE(n)	(SUNXI_PE_BASE + (n))
+#define GPIOF(n)	(SUNXI_PF_BASE + (n))
+#define GPIOG(n)	(SUNXI_PG_BASE + (n))
+#define GPIOH(n)	(SUNXI_PH_BASE + (n))
+#define GPIOI(n)	(SUNXI_PI_BASE + (n))
+#define GPIOJ(n)	(SUNXI_PJ_BASE + (n))
+#define GPIOK(n)	(SUNXI_PK_BASE + (n))
+#define GPIOL(n)	(SUNXI_PL_BASE + (n))
+#define GPIOM(n)	(SUNXI_PM_BASE + (n))
+#define GPION(n)	(SUNXI_PN_BASE + (n))
+#define GPIOO(n)	(SUNXI_PO_BASE + (n))
+#define GPIO_AXP(n)	(AXP_PIN_BASE  + (n))
+
+/* sunxi specific input/output/eint functions */
+#define SUNXI_PIN_INPUT_FUNC	(0)
+#define SUNXI_PIN_OUTPUT_FUNC	(1)
+#define SUNXI_PIN_EINT_FUNC	(6)
+#define SUNXI_PIN_IO_DISABLE	(7)
+
+/* axp group base number name space,
+ * axp pinctrl number space coherent to sunxi-pinctrl.
+ */
+#define AXP_PINCTRL	        "axp-pinctrl"
+#define AXP_CFG_GRP		(0xFFFF)
+#define AXP_PIN_INPUT_FUNC	(0)
+#define AXP_PIN_OUTPUT_FUNC	(1)
+#define IS_AXP_PIN(pin)		(pin >= AXP_PIN_BASE)
+
+/* sunxi specific pull up/down */
+enum sunxi_pull_up_down {
+	SUNXI_PULL_DISABLE = 0,
+	SUNXI_PULL_UP,
+	SUNXI_PULL_DOWN,
+};
+
+/* sunxi specific data types */
+enum sunxi_data_type {
+	SUNXI_DATA_LOW = 0,
+	SUNXI_DATA_HIGH = 0,
+};
+
+/* sunxi specific pull status */
+enum sunxi_pin_pull {
+	SUNXI_PIN_PULL_DISABLE	= 0x00,
+	SUNXI_PIN_PULL_UP	= 0x01,
+	SUNXI_PIN_PULL_DOWN	= 0x02,
+	SUNXI_PIN_PULL_RESERVED	= 0x03,
+};
+
+/* sunxi specific driver levels */
+enum sunxi_pin_drv_level {
+	SUNXI_DRV_LEVEL0 = 10,
+	SUNXI_DRV_LEVEL1 = 20,
+	SUNXI_DRV_LEVEL2 = 30,
+	SUNXI_DRV_LEVEL3 = 40,
+};
+
+/* sunxi specific data bit status */
+enum sunxi_pin_data_status {
+	SUNXI_PIN_DATA_LOW  = 0x00,
+	SUNXI_PIN_DATA_HIGH = 0x01,
+};
+
+/* sunxi pin interrupt trigger mode */
+enum sunxi_pin_int_trigger_mode {
+	SUNXI_PIN_EINT_POSITIVE_EDGE   =   0x0,
+	SUNXI_PIN_EINT_NEGATIVE_EDGE   =   0x1,
+	SUNXI_PIN_EINT_HIGN_LEVEL      =   0x2,
+	SUNXI_PIN_EINT_LOW_LEVEL       =   0x3,
+	SUNXI_PIN_EINT_DOUBLE_EDGE     =   0x4
+};
+
+/* the source clock of pin int */
+enum sunxi_pin_int_source_clk {
+	SUNXI_PIN_INT_SRC_CLK_32K = 0x0,
+	SUNXI_PIN_INT_SRC_CLK_24M = 0x1
+};
+
+/**
+ * enum sunxi_pincfg_type - possible pin configuration types supported.
+ * @SUNXI_PINCFG_TYPE_FUNC: Function configuration.
+ * @SUNXI_PINCFG_TYPE_DAT : Pin value configuration.
+ * @SUNXI_PINCFG_TYPE_PUD : Pull up/down configuration.
+ * @SUNXI_PINCFG_TYPE_DRV : Drive strength configuration.
+ */
+enum sunxi_pincfg_type {
+	SUNXI_PINCFG_TYPE_FUNC,
+	SUNXI_PINCFG_TYPE_DAT,
+	SUNXI_PINCFG_TYPE_PUD,
+	SUNXI_PINCFG_TYPE_DRV
+};
+
+/*
+ * pin configuration (pull up/down and drive strength) type and its value are
+ * packed together into a 32-bits. The upper 16-bits represent the configuration
+ * type and the lower 16-bits hold the value of the configuration type.
+ */
+#define SUNXI_PINCFG_PACK(type, value)	(((value) << 16) | (type & 0xFFFF))
+#define SUNXI_PINCFG_UNPACK_TYPE(cfg)	((cfg) & 0xFFFF)
+#define SUNXI_PINCFG_UNPACK_VALUE(cfg)	(((cfg) & 0xFFFF0000) >> 16)
+
+static inline int sunxi_gpio_to_name(int gpio, char *name)
+{
+	int bank, index;
+
+	if (!name)
+		return -EINVAL;
+
+	if (IS_AXP_PIN(gpio)) {
+		/* axp gpio name like this : GPIO0/GPIO1/.. */
+		index = gpio - AXP_PIN_BASE;
+		sprintf(name, "GPIO%d", index);
+	} else {
+		/* sunxi gpio name like this : PA0/PA1/PB0 */
+		bank = gpio / SUNXI_BANK_SIZE;
+		index = gpio % SUNXI_BANK_SIZE;
+		sprintf(name, "P%c%d", ('A' + bank), index);
+	}
+
+	return 0;
+}
+
+/* pio end, invalid macro */
+#define GPIO_INDEX_INVALID	(0xFFFFFFF0)
+#define GPIO_CFG_INVALID	(0xEEEEEEEE)
+#define GPIO_PULL_INVALID	(0xDDDDDDDD)
+#define GPIO_DRVLVL_INVALID	(0xCCCCCCCC)
+#define IRQ_NUM_INVALID		(0xFFFFFFFF)
+#define AXP_PORT_VAL		(0x0000FFFF)
+
+/* pio default macro */
+#define GPIO_PULL_DEFAULT	((u32)-1)
+#define GPIO_DRVLVL_DEFAULT	((u32)-1)
+#define GPIO_DATA_DEFAULT	((u32)-1)
+
+/*
+ * struct gpio_config - gpio config info
+ * @gpio:      gpio global index, must be unique
+ * @mul_sel:   multi sel val: 0 - input, 1 - output.
+ * @pull:      pull val: 0 - pull up/down disable, 1 - pull up
+ * @drv_level: driver level val: 0 - level 0, 1 - level 1
+ * @data:      data val: 0 - low, 1 - high, only valid when mul_sel is input/output
+ */
+struct gpio_config {
+	u32	gpio;
+	u32	mul_sel;
+	u32	pull;
+	u32	drv_level;
+	u32	data;
+};
+
+#endif

--- a/drivers/power/supply/Kconfig	2022-09-01 10:43:20.861773918 -0400
+++ b/drivers/power/supply/Kconfig	2022-09-01 10:50:47.442191277 -0400
@@ -897,4 +897,6 @@
 	  device is off or suspended, the functionality of this driver is
 	  limited to reporting capacity only.
 
+source "drivers/power/supply/axp/Kconfig"
+
 endif # POWER_SUPPLY

--- a/drivers/power/supply/Makefile	2022-09-01 10:43:20.861773918 -0400
+++ b/drivers/power/supply/Makefile	2022-09-01 10:50:41.698288814 -0400
@@ -108,3 +108,4 @@
 obj-$(CONFIG_BATTERY_SURFACE)	+= surface_battery.o
 obj-$(CONFIG_CHARGER_SURFACE)	+= surface_charger.o
 obj-$(CONFIG_BATTERY_UG3105)	+= ug3105_battery.o
+obj-$(CONFIG_AW_AXP)		    += axp/
